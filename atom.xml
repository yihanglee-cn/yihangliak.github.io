<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yihangliak.github.io</id>
    <title>一杭的博客</title>
    <updated>2020-02-21T09:45:20.924Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yihangliak.github.io"/>
    <link rel="self" href="https://yihangliak.github.io/atom.xml"/>
    <subtitle>你好  靓仔   :D</subtitle>
    <logo>https://yihangliak.github.io/images/avatar.png</logo>
    <icon>https://yihangliak.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 一杭的博客</rights>
    <entry>
        <title type="html"><![CDATA[MySQL系列入门（一）：数据库的概念]]></title>
        <id>https://yihangliak.github.io/post/b_VV-Uhrz/</id>
        <link href="https://yihangliak.github.io/post/b_VV-Uhrz/">
        </link>
        <updated>2020-02-21T08:29:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-概念">一、概念</h1>
<h2 id="1-什么是数据库">1. 什么是数据库</h2>
<p>**数据库：**按照数据结构来组织、储存和管理数据的仓库</p>
<blockquote>
<p>**疑问：**我的数据可以存在<code>excel</code>等文件中，那还要数据库干嘛？<br>
这就引出以下数据存储的几个阶段：</p>
</blockquote>
<p><strong>人工管理阶段</strong></p>
<p>数据靠人工整理，储存和管理。不方便保存，查询和管理</p>
<p>典型的如古代的<code>结绳记事</code>，以及现代的<code>图书馆</code>等</p>
<figure data-type="image" tabindex="1"><img src="https://pic.downk.cc/item/5e4f985d48b86553ee37e9bf.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://pic.downk.cc/item/5e4f9a2048b86553ee384017.jpg" alt="" loading="lazy"></figure>
<p><strong>文件系统阶段</strong></p>
<p>将文件数据储存在硬盘上，通过文件管理系统，比人工方便很多。</p>
<p>但在查询数据内容时，依旧不太方便。想知道哪个文件里面有什么内容，还得一个个打开确认</p>
<figure data-type="image" tabindex="3"><img src="https://pic.downk.cc/item/5e4f9b2b48b86553ee3872a1.jpg" alt="" loading="lazy"></figure>
<p><strong>数据库系统阶段</strong></p>
<p>网页显示的商品信息</p>
<figure data-type="image" tabindex="4"><img src="https://pic.downk.cc/item/5e4f9c0c48b86553ee38ac7b.jpg" alt="" loading="lazy"></figure>
<p>数据库中储存的商品信息</p>
<figure data-type="image" tabindex="5"><img src="https://pic.downk.cc/item/5e4f9c2448b86553ee38b38e.jpg" alt="" loading="lazy"></figure>
<h2 id="2-关系型数据库rdbms">2. 关系型数据库（RDBMS）</h2>
<ul>
<li><code>RDBMS</code>全称<code>relational database management system</code></li>
<li>中文意思为：<strong>关系型数据库管理系统</strong></li>
<li>关系型数据库采用了关系模型（一对一，多对多... ...）来组织数据</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://pic1.superbed.cn/item/5dfc6ef276085c3289171fde.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>什么是关系型数据库？<br>
比如上图中，有两个表格，一个角色表，一个技能表。这个两个表格中有一列数据-姓名是相同的，我们用这个一列相同的数据来连接两个表格，使它们产生联系，一旦其中一个表格的数据更改了另外一个表格的数据也会跟着更改，这种联系使他们的数据具有一致性，这就是关系型数据库。</p>
</blockquote>
<h2 id="3-数据库分类与排名">3. 数据库分类与排名</h2>
<p>查看数据库排行榜：https://db-engines.com/en/ranking</p>
<figure data-type="image" tabindex="7"><img src="https://pic.superbed.cn/item/5dfc706276085c32891794f5.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>上述排名不与数据库使用安装数量相等</p>
</blockquote>
<p><strong>关系型</strong></p>
<ul>
<li><code>oracle</code>：甲骨文公司开发，收费软件，一般用于大型项目，如：银行，电信等</li>
<li><code>MySQL</code>：甲骨文公司收购<code>sun(java)</code>而来，开源免费数据库，<code>web</code>项目中使用最广泛</li>
<li><code>Microsoft SQL Server</code>：微软开发的项目中使用</li>
</ul>
<p><strong>非关系型</strong></p>
<ul>
<li><code>Redis</code>：高性能缓存数据库</li>
<li><code>SQLite</code>：轻量级数据库，主要用于移动端</li>
</ul>
<p><strong>关系型数据库核心元素</strong></p>
<ul>
<li><code>数据库</code>：这里的数据库指数据仓库，一个数据库系统可以有多个数据仓库</li>
<li><code>数据表</code>：一个数据仓库可以有多张数据表</li>
<li><code>数据列</code>：字段信息</li>
<li><code>数据行</code>：一条数据记录</li>
</ul>
<h2 id="4-sql">4. SQL</h2>
<blockquote>
<p><code>structured query language</code></p>
</blockquote>
<ul>
<li>
<p>结构化查询语言，用来操作关系型数据库的语言</p>
</li>
<li>
<p><code>SQL</code>不区分大小写</p>
</li>
</ul>
<h2 id="5-mysql">5. MySQL</h2>
<p>由瑞典<code>MySQL AB</code>开发，后来被<code>sun</code>收购，<code>sun</code>又被<code>oracle</code>收购。所以现在是<code>Oracle</code>旗下产品</p>
<blockquote>
<p>目前开源版本与收费版并存（其实以后全部闭源也没事，因为有出过其他好用的衍生版本）</p>
</blockquote>
<p>特点</p>
<ul>
<li>开源，免费</li>
<li>支持多平台</li>
<li>是学习数据库的首选</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一张图学习Python3]]></title>
        <id>https://yihangliak.github.io/post/he1qEtsn3/</id>
        <link href="https://yihangliak.github.io/post/he1qEtsn3/">
        </link>
        <updated>2019-11-26T06:46:04.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://ae01.alicdn.com/kf/Hd08faf2fb079423585c8fdda933016b9b.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[国庆快乐]]></title>
        <id>https://yihangliak.github.io/post/Happy-National-Day/</id>
        <link href="https://yihangliak.github.io/post/Happy-National-Day/">
        </link>
        <updated>2019-10-02T03:17:06.000Z</updated>
        <content type="html"><![CDATA[<p>国庆快乐！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP Runner]]></title>
        <id>https://yihangliak.github.io/post/F__PjWJCK/</id>
        <link href="https://yihangliak.github.io/post/F__PjWJCK/">
        </link>
        <updated>2019-09-27T01:35:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>HttpRunner 是一款面向 HTTP(S) 协议的通用测试框架，只需编写维护一份 YAML/JSON 脚本，即可实现自动化测试。</p>
<p><strong>优势</strong></p>
<ul>
<li>继承 Requests 的全部特性，轻松实现 HTTP(S) 的各种测试需求</li>
<li>采用 YAML/JSON 的形式描述测试场景，保障测试用例描述的统一性和可维护性</li>
<li>借助辅助函数（debugtalk.py），在测试脚本中轻松实现复杂的动态计算逻辑</li>
<li>支持完善的测试用例分层机制，充分实现测试用例的复用</li>
<li>测试前后支持完善的 hook 机制</li>
<li>响应结果支持丰富的校验机制</li>
<li>基于 HAR 实现接口录制和用例生成功能（har2case）</li>
<li>结合 Locust 框架，无需额外的工作即可实现分布式性能测试</li>
<li>执行方式采用 CLI 调用，可与 Jenkins 等持续集成工具完美结合</li>
<li>测试结果统计报告简洁清晰，附带详尽统计信息和日志记录</li>
<li>极强的可扩展性，轻松实现二次开发和 Web 平台化</li>
</ul>
<h1 id="环境准备">环境准备</h1>
<p><strong>HttpRunner</strong>目前有2个版本，1.x和2x版本</p>
<p>详见仓库：<a href="https://github.com/HttpRunner/HttpRunner">https://github.com/HttpRunner/HttpRunner</a></p>
<p><strong>使用pip安装：</strong></p>
<pre><code>pip install httprunner
</code></pre>
<p><strong>验证版本</strong></p>
<pre><code>hrun -V
</code></pre>
<h1 id="登录案例">登录案例</h1>
<p><strong>接口文档如下</strong></p>
<figure data-type="image" tabindex="1"><img src="https://ae01.alicdn.com/kf/H9faba9dad2a2470ba59e4e11eac4074aS.jpg" alt="" loading="lazy"></figure>
<p><strong>yml格式脚本如下</strong></p>
<pre><code class="language-yml">- config:                          # 全局配置项，作用域为整个测试用例文件
    name: logincase                # 测试用例名
    variables: {}
- test:                            # 测试步骤（可以有多个）
    name: login case1
    request:
        url: http://appapi.fecshop.com/v1/account/login
        method: POST
        headers:
            Content-Type: application/json
            User-Agent: python-requests/2.18.4
        json:
            username: admin
            password: admin123
    validate:                      # 断言
        - eq: [status_code, 200]
        - eq: [content.status, success]
        - eq: [content.code, 200]

</code></pre>
<p><strong>命令行中执行该脚本</strong></p>
<pre><code>hrun fecshop01_login.yml
</code></pre>
<p><strong>查看报告</strong><br>
<img src="https://ae01.alicdn.com/kf/H6ab4d4a855e54c0ea5d012468829066er.jpg" alt="" loading="lazy"></p>
<h1 id="关联token">关联token</h1>
<p>如何将上个接口的返回token，传给下个接口当做请求参数?这是最常见的一个问题了。解决这个问题其实很简单，我们只需取出token值，设置为一个中间变量a，下个接口传这个变量a就可以了。</p>
<p>比如 <strong>查询商品详情</strong> 接口，在请求中需要传入登录后token，接口文档如下：</p>
<figure data-type="image" tabindex="2"><img src="https://ae01.alicdn.com/kf/Hf3791bcadb304b608ca4b090a81bf292B.jpg" alt="" loading="lazy"></figure>
<p>那么在<code>HttpRunner</code>中可以使用<code>extract</code>提取<code>token</code>，比如：</p>
<pre><code class="language-yml">extract:
	- token: content.token
</code></pre>
<p><strong>案例脚本</strong></p>
<blockquote>
<p>查询商品详情（需登录）</p>
</blockquote>
<pre><code class="language-yml">- config:                          
    name: fetch_product              
    variables: {}
- test:                            
    name: login_success
    request:
        url: http://appapi.fecshop.com/v1/account/login
        method: POST
        headers:
            Content-Type: application/json
        json:
            username: admin
            password: admin123
    extract:
        - token: content.access-token           # 提取token
    validate:
        - eq: [status_code, 200]
        - eq: [content.status, success]
        - eq: [content.code, 200]

- test:
    name: fetch_product_success
    request:
        url: http://appapi.fecshop.com/v1/product/fetchone
        method: GET 
        headers:
            Content-Type: application/json
            Access-Token: $token               # 引用token
        json:
            id: 57bab0d5f656f2940a3bf56e
    validate:
        - eq: [content.code, 200]
        - eq: [content.message, fetch product success]

</code></pre>
<p><strong>测试报告</strong></p>
<figure data-type="image" tabindex="3"><img src="https://ae01.alicdn.com/kf/H1e08664510f940bb90331fc8433bd6a9M.jpg" alt="" loading="lazy"></figure>
<h1 id="测试执行">测试执行</h1>
<p><strong>指定测试报告存放目录</strong></p>
<pre><code>hrun xxx.yml --report-dir report_dir
</code></pre>
<p><strong>指定日志级别</strong></p>
<pre><code>hrun xxx.yml --log-level debug   # 最详细级别
</code></pre>
<h1 id="录制脚本">录制脚本</h1>
<p>使用<code>Fiddler</code>或其他抓包工具，将抓取到的数据保存成<code>har</code>文件，然后使用<code>HttpRunner</code>测试用例生成功能，快速生成测试用例。</p>
<p><strong>使用抓包工具抓取数据</strong></p>
<blockquote>
<p>以<code>幕布</code>登录为例</p>
</blockquote>
<pre><code>POST https://mubu.com/api/login/submit HTTP/1.1
Host: mubu.com
Connection: keep-alive
Content-Length: 51
Accept: application/json, text/javascript, */*; q=0.01
Origin: https://mubu.com
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Referer: https://mubu.com/login/password
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cookie: _ga=GA1.2.2093024221.1563846010; csrf_token=c91c2dd6-c26b-42ba-90fc-59997418fd82; data_unique_id=f8f42b69-299d-4ac7-9311-699f0e469ab3; SESSION=ZTc2Y2Q0YzgtYjdlNS00ZGRmLWI1ZDYtNmI3MDg4N2FlMmYz; _gid=GA1.2.347269472.1569567796; reg_entrance=https%3A%2F%2Fmubu.com%2F; user_persistence=59c84236-124f-4071-86d3-a1edef6dba3f; _gat=1

phone=手机号&amp;password=密码&amp;remember=true
</code></pre>
<p><strong>导出<code>har</code>文件</strong></p>
<figure data-type="image" tabindex="4"><img src="https://ae01.alicdn.com/kf/Hd67aef48078f47ea8bc6b610d85fe2c5S.jpg" alt="" loading="lazy"></figure>
<p><strong>转换脚本</strong><br>
进入<code>har</code>文件保存目录，打开命令行，输入如下命令将数据包转为<code>yml</code>格式的脚本文件：</p>
<pre><code>har2case xxx.har -2y
</code></pre>
<p><strong>转换后效果</strong></p>
<pre><code class="language-yml">config:
    name: testcase description
    variables: {}
teststeps:
-   name: /api/login/submit
    request:
        data:
            password: 密码
            phone: '手机'
            remember: 'true'
        headers:
            Content-Type: application/x-www-form-urlencoded; charset=UTF-8
            User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36
                (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36
            X-Requested-With: XMLHttpRequest
        method: POST
        url: https://mubu.com/api/login/submit
    validate:
    -   eq:
        - status_code
        - 200
    -   eq:
        - headers.Content-Type
        - application/json;charset=UTF-8
    -   eq:
        - content.code
        - 0
    -   eq:
        - content.msg
        - null

</code></pre>
<p><strong>测试报告</strong></p>
<figure data-type="image" tabindex="5"><img src="https://ae01.alicdn.com/kf/Hc8cf1a1932574fd798aa1669bc943e9cz.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML基础]]></title>
        <id>https://yihangliak.github.io/post/dYxAqQpcF/</id>
        <link href="https://yihangliak.github.io/post/dYxAqQpcF/">
        </link>
        <updated>2019-09-20T09:18:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-什么是html">1. 什么是HTML</h2>
<p>HTML是用来描述网页的一种语言，英文全称是：<code>Hyper Text markup language</code></p>
<blockquote>
<p>注意：HTML不是编程语言，是一种标记语言</p>
</blockquote>
<p>HTML使用标记标签来描述网页，然后通过浏览器读取 HTML 文档，并以网页的形式显示出它们</p>
<h2 id="2-html标签">2. HTML标签</h2>
<p>HTML标签是由尖括号包围的关键词，比如<code>&lt;html&gt;</code></p>
<p>HTML标签一般都是成对出现的，比如<code>&lt;html&gt; &lt;/html&gt;</code></p>
<p>标签对中的第一个标签是<code>开始标签</code>，第二个标签是<code>结束标签</code></p>
<h2 id="3-html文件编辑以及文件格式">3. HTML文件编辑以及文件格式</h2>
<p>编辑HTML文件，可以使用<code>Notepad++</code></p>
<p>HTML文件的格式为：<code>htm 或 html</code>，两者没有任何差别，根据自己喜好选择即可</p>
<p>HTML文件保存好以后，可以通过浏览器<code>（chrome/IE/FireFox...）</code>打开进行浏览</p>
<h2 id="4-注释">4. 注释</h2>
<p>html文档代码中可以插入注释，注释是对代码的说明和解释，注释的内容不会显示在页面上，html代码中插入注释的方法是：</p>
<pre><code>&lt;!-- 这是一段注释  --&gt;
</code></pre>
<h2 id="5-html常用标签">5. HTML常用标签</h2>
<h3 id="51标题">5.1标题</h3>
<p>HTML标题通过<code>&lt;h1&gt;-&lt;h6&gt;</code>标签进行定义的，其中<code>&lt;h1&gt;</code>为最大级别标题，<code>&lt;h6&gt;为最小级别标题</code></p>
<p>搜索引擎会爬取标题标签编制索引，所以标题标签很重要</p>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="language-html">&lt;h1&gt;This is heading 1&lt;/h1&gt;
&lt;h2&gt;This is heading 2&lt;/h2&gt;
&lt;h3&gt;This is heading 3&lt;/h3&gt;
&lt;h4&gt;This is heading 4&lt;/h4&gt;
&lt;h5&gt;This is heading 5&lt;/h5&gt;
&lt;h6&gt;This is heading 6&lt;/h6&gt;
</code></pre>
<blockquote>
<p>效果图</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://www.z4a.net/images/2019/08/21/Snipaste_2019-08-21_11-04-51.png" alt="Snipaste_2019-08-21_11-04-51.png" loading="lazy"></figure>
<h3 id="52段落">5.2段落</h3>
<p>HTML 段落是通过 <code>&lt;p&gt;</code> 标签进行定义的</p>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="language-html">&lt;p&gt;这是段落。&lt;/p&gt;
&lt;p&gt;这是段落。&lt;/p&gt;
&lt;p&gt;这是段落。&lt;/p&gt;
</code></pre>
<blockquote>
<p>效果图</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://www.z4a.net/images/2019/08/21/Snipaste_2019-08-21_11-11-07.png" alt="Snipaste_2019-08-21_11-11-07.png" loading="lazy"></figure>
<p><strong>换行</strong></p>
<p>换行标签是单个出现的</p>
<pre><code>不规范写法：&lt;br&gt;
规范写法：&lt;br /&gt;
</code></pre>
<p><strong>字符实体</strong></p>
<blockquote>
<p>有的时候需要在段落中插入一些空格，但是直接在代码中写入空格的话是无法被正常渲染成空格的，需要使用字符实体</p>
</blockquote>
<pre><code>&lt;!--  在段落前想缩进两个文字的空格，使用空格的字符实体：&amp;nbsp;   --&gt;
&lt;p&gt;
&amp;nbsp;&amp;nbsp;一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用&lt;br /&gt;
文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件&lt;br /&gt;
渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。&lt;/p&gt;
</code></pre>
<p>注意：如果只是加入少量空格，是可以用 <strong>字符实体</strong> ，但如果需要大量插入空格，推荐使用样式去控制</p>
<h3 id="53链接">5.3链接</h3>
<p>HTML 链接是通过<code>&lt;a&gt;</code>标签进行定义的</p>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="language-html">&lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;This is a link&lt;/a&gt;
</code></pre>
<blockquote>
<p>效果图</p>
</blockquote>
<figure data-type="image" tabindex="3"><a href="https://www.z4a.net/image/Ucix29"><img src="https://www.z4a.net/images/2019/08/21/Snipaste_2019-08-21_11-17-07.png" alt="" loading="lazy"></a></figure>
<h3 id="54-块标签">5.4 块标签</h3>
<p><code>div</code>标签，表示一块内容，没有具体语义</p>
<p><code>p</code>标签与<code>div</code>的区别：</p>
<ul>
<li><code>p</code>带有空行等样式</li>
<li><code>div</code>标签不带任何样式</li>
<li><code>div</code>一般里面是可以嵌套的，比如嵌套<code>h，p</code>标签等</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python全栈（三）：多态]]></title>
        <id>https://yihangliak.github.io/post/phI3IExH8/</id>
        <link href="https://yihangliak.github.io/post/phI3IExH8/">
        </link>
        <updated>2019-09-13T15:44:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="面向对象三大特性">面向对象三大特性</h3>
<ol>
<li><strong>封装</strong> ： 根据职责将属性与方法封装到一个抽象的类中
<ul>
<li>定义类的准则</li>
</ul>
</li>
<li><strong>继承</strong> ： 实现代码的重用，相同的代码不需要重复的编写
<ul>
<li>设计类的技巧</li>
<li>子类针对自己特有的需求，编写特定的代码</li>
</ul>
</li>
<li><strong>多态</strong> ： 不同的子类对象调用相同的父类方法，产生不同的执行结果
<ul>
<li>多态可以增加代码的灵活度</li>
<li>多态以继承和重写父类方法为前提</li>
<li>多态不会影响到类的内部设计</li>
</ul>
</li>
</ol>
<blockquote>
<p>实例代码结构图示</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://ae01.alicdn.com/kf/H0b8155e7965844d0a5903c42093acf00R.png" alt="" loading="lazy"></figure>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="language-python">class Dog(object):

    def __init__(self, name):
        self.name = name

    def game(self):
        print('%s正在玩耍... ...' %self.name)


class XiaoTianQuan(Dog):

    def game(self):
        print('%s正在天上玩耍... ...' %self.name)


class Person(object):

    def __init__(self, name):
        self.name = name

    def game_with_dog(self, dog):  # 将狗对象传入
        print(&quot;%s和%s正在玩耍&quot; %(self.name, dog.name))
        dog.game()  # 调用狗对象中的game方法


# xiaohei = Dog(&quot;小黑&quot;)    # 创建一条狗
xiaohei = XiaoTianQuan(&quot;哮天犬&quot;)  # 小黑传入game with dog只是普通玩耍，哮天犬传入以后再天上玩耍

xiaoming = Person(&quot;小明&quot;)  # 创建一个人
xiaoming.game_with_dog(xiaohei)  # 调用人类中的与狗玩耍方法，并将xiaohei传入
# 不同的子类对象，调用相同的父类对象，产生不同的结果，这就是多态
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python全栈（二）：私有属性与私有方法]]></title>
        <id>https://yihangliak.github.io/post/dz4T-djIi/</id>
        <link href="https://yihangliak.github.io/post/dz4T-djIi/">
        </link>
        <updated>2019-09-11T03:51:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>基本介绍</p>
</blockquote>
<ul>
<li><strong>私有属性</strong> 就是 <strong>对象</strong> 不希望公开的属性</li>
<li><strong>私有方法</strong> 就是 <strong>对象</strong> 不希望公开的方法</li>
</ul>
<blockquote>
<p>定义方式</p>
</blockquote>
<p>在定义属性或者方法时，在属性或者方法名前增加 <strong>两个下划线</strong> ，这就是定义私有属性或者私有方法</p>
<blockquote>
<p>提示</p>
</blockquote>
<ul>
<li>私有属性或者私有方法，在类外无法访问，但是在类中是可以访问的</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<p><strong>私有方法</strong></p>
<pre><code class="language-python">class Test():
    def test1(self):
        print('普通方法')
        self.__test3()     # 私有方法可以在类内部被调用

    def _test2(self):
        print('普通方法')

    def __test3(self):      # 双斜线开头则为私有方法
        print('私有方法')

t = Test()
t.test1()
t._test2()
# t.__test3()        # 私有方法在外部不能被调用
</code></pre>
<p><strong>私有属性</strong></p>
<pre><code class="language-python">class Person():
    def __init__(self, name):
        self.__name = name   # 双下划线+属性名=私有属性
        self.sex = 'boy'

    def get_name(self):
        return self.__name

    def set_name(self, new_name):   # 定义一个修改name属性的方法，一旦name长度小于5则报错
        if len(new_name)&gt;=5:
            self.__name = new_name   # 私有属性在类中是可以访问的
        else:
            print('error:名字长度需要大于或者等于5')


p = Person('zs')
print(p.sex)           # 普通属性在类外是可以访问到的
# print(p.__name)      # 私有属性在类外不能访问
p.set_name('hiiii')    # 调用修改name属性的方法
print(p.get_name())    # 访问被修改之后的name属性
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python全栈（一）：子类扩展父类方法]]></title>
        <id>https://yihangliak.github.io/post/QpPt8XA7M/</id>
        <link href="https://yihangliak.github.io/post/QpPt8XA7M/">
        </link>
        <updated>2019-09-10T15:54:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>基本介绍</p>
</blockquote>
<p>如果在开发中，<strong>子类方法的实现中包含父类方法的实现</strong>，即<strong>父类封装的方法是子类实现的一部分</strong></p>
<p>则可以使用 <strong>扩展</strong>的方式</p>
<blockquote>
<p>使用步骤：</p>
</blockquote>
<ol>
<li>在子类中 <strong>重写</strong> 父类方法</li>
<li>在需要的位置使用<code>super().父类方法</code>来调用父类方法的执行</li>
<li>代码其他位置针对子类的需求，编写 <strong>子类特有的代码实现</strong></li>
</ol>
<blockquote>
<p>关于super</p>
</blockquote>
<ul>
<li>在python中，super是一个 <strong>特殊</strong> 的类</li>
<li>super（）就是使用super类创建出来的对象</li>
<li>最常使用的场景就是在 <strong>重写父类方法时</strong>，调用 <strong>在父类中的方法实现</strong></li>
</ul>
<blockquote>
<p>代码实现</p>
</blockquote>
<pre><code class="language-python"># 定义父类：动物类
class Animal():
    def eat(self):
        print('吃')

    def run(self):
        print('跑')

    def bark(self):
        print('狗吠')

xiaohei = Animal()  # 实例化狗类
xiaohei.eat()       # 生成对象调用父类方法

print('='*50)

class Dog(Animal):   # 定义狗类，并继承动物类
    def bark(self):
        print('汪汪叫')

xiaobai = Dog()
xiaobai.bark()       # 调用狗吠方法

print('='*50)

class xiaotianquan(Dog):   # 定义哮天犬类继承狗类
    def bark(self):
        super().bark()  # 使用super().父类方法调用父类方法并执行
        print('eqweqdasdasdasdsad')  # 编写子类特有的功能，哮天犬除了狗吠还会鸟语...

xtq = xiaotianquan()
xtq.bark()  # 哮天犬除了不仅会狗吠，还会说鸟语...
</code></pre>
<pre><code>吃
==================================================
汪汪叫
==================================================
汪汪叫
eqweqdasdasdasdsad
</code></pre>
<blockquote>
<p>提示</p>
</blockquote>
<p>在Python2.x时，如果需要调用父类方法，还可以使用以下方式实现：</p>
<pre><code>父类名.方法（self）
</code></pre>
<ul>
<li>这种方式，在目前的Python3.x中依旧支持</li>
<li>但是不推荐使用这种方法，因为一旦父类名发生变化，子类中涉及到父类 <strong>类名</strong> 的位置同样需要修改</li>
</ul>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>在开发时，父类名和super（）两种方式不要混用</li>
<li>如果使用当前子类名调用方法，会形成递归调用，<strong>出现死循环</strong></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实用工具大搜罗]]></title>
        <id>https://yihangliak.github.io/post/UQ96yPt5M/</id>
        <link href="https://yihangliak.github.io/post/UQ96yPt5M/">
        </link>
        <updated>2019-09-10T06:30:01.000Z</updated>
        <summary type="html"><![CDATA[<p>盘点那些不为人知的工具-们！</p>
]]></summary>
        <content type="html"><![CDATA[<p>盘点那些不为人知的工具-们！</p>
 <!-- more -->
<h1 id="文字编辑">文字编辑    📕</h1>
<p><strong>思维导图</strong></p>
<ul>
<li>幕布：<a href="https://mubu.com/">https://mubu.com</a></li>
<li>xmind<br>
xmind ZEN：<a href="http://dl2.xmind.cn/XMind-ZEN-Update-2019-for-Windows-64bit-9.2.0-201904271935.exe">http://dl2.xmind.cn/XMind-ZEN-Update-2019-for-Windows-64bit-9.2.0-201904271935.exe</a><br>
破解补丁：<a href="https://carrot.ctfile.com/dir/11269771-31680249-fdf2c2/">https://carrot.ctfile.com/dir/11269771-31680249-fdf2c2/</a></li>
</ul>
<p><strong>Markdown编辑器</strong></p>
<ul>
<li>Typora：<a href="https://www.typora.io/">https://www.typora.io/</a></li>
</ul>
<p><strong>万能编辑器</strong></p>
<ul>
<li>notepad ++</li>
</ul>
<p><strong>文档，表格，幻灯片</strong></p>
<ul>
<li>WPS（政企专版，无广告）：<a href="http://wpspro.support.wps.cn/gov/heilongjiang/daqing/installation/WPS_Office_2019_%E5%A4%A7%E5%BA%86%E5%B8%82%E5%85%9A%E6%94%BF%E6%9C%BA%E5%85%B3%E4%B8%93%E7%94%A8%E7%89%88.exe">http://wpspro.support.wps.cn/gov/heilongjiang/daqing/installation/WPS_Office_2019_大庆市党政机关专用版.exe</a></li>
<li>在线emoji：<a href="http://emojihomepage.com/">http://emojihomepage.com/</a></li>
</ul>
<h1 id="开发工具">开发工具    💻</h1>
<p><strong>图形化Git工具</strong></p>
<ul>
<li>sourcetree：<a href="https://www.sourcetreeapp.com/">https://www.sourcetreeapp.com/</a></li>
</ul>
<p><strong>python编辑器</strong></p>
<ul>
<li>pycharm：<a href="http://www.jetbrains.com/pycharm/">http://www.jetbrains.com/pycharm/</a></li>
</ul>
<p><strong>MySQL连接软件</strong></p>
<ul>
<li>Navicat for mysql 绿色版：<a href="https://www.cr173.com/soft/38153.html">https://www.cr173.com/soft/38153.html</a></li>
</ul>
<p><strong>Java8</strong></p>
<ul>
<li>JDK下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li>
</ul>
<p><strong>淘宝镜像站</strong></p>
<ul>
<li>地址：<a href="https://npm.taobao.com">https://npm.taobao.com</a></li>
</ul>
<h1 id="生活类">生活类    👀</h1>
<p><strong>护眼</strong></p>
<ul>
<li>护眼宝：<a href="http://www.huyanapp.com/portal.php">http://www.huyanapp.com/portal.php</a></li>
</ul>
<h1 id="图片处理类">图片处理类    🎨</h1>
<p><strong>截图工具</strong></p>
<ul>
<li>Snipaste：<a href="https://www.snipaste.com/">https://www.snipaste.com/</a></li>
</ul>
<p><strong>免费图床</strong></p>
<ul>
<li>smpic：<a href="https://github.com/kookob/smpic">https://github.com/kookob/smpic</a></li>
<li>聚合图床：<a href="https://www.superbed.cn/">https://www.superbed.cn/</a></li>
<li>智图图片压缩：<a href="https://zhitu.isux.us/">https://zhitu.isux.us/</a></li>
</ul>
<h1 id="系统美化类">系统美化类    🐼</h1>
<p><strong>任务栏全透明</strong></p>
<ul>
<li>TranslucentTB：<a href="https://translucenttb.en.softonic.com/">https://translucenttb.en.softonic.com/</a></li>
</ul>
<p><strong>Windows字体优化</strong></p>
<ul>
<li>Mactype：<a href="https://www.mactype.net/">https://www.mactype.net/</a></li>
</ul>
<p><strong>超美壁纸</strong></p>
<ul>
<li>Pexels：<a href="https://www.pexels.com/">https://www.pexels.com/</a></li>
</ul>
<h1 id="效率类">效率类     📚</h1>
<p><strong>待办事项管理</strong></p>
<ul>
<li>MicrosoftToDo：<a href="https://todo.microsoft.com/">https://todo.microsoft.com/</a></li>
</ul>
<p><strong>本地文件搜索工具（一秒找到文件）</strong></p>
<ul>
<li>everything：<a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></li>
</ul>
<p><strong>百度云不限速下载</strong></p>
<ul>
<li>speedpan：<a href="https://www.speedpan.com/">https://www.speedpan.com/</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dcoker 安装MySQL]]></title>
        <id>https://yihangliak.github.io/post/SuD1zwuyw/</id>
        <link href="https://yihangliak.github.io/post/SuD1zwuyw/">
        </link>
        <updated>2019-08-30T08:40:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="dcoker-安装mysql">Dcoker 安装MySQL</h1>
<h2 id="前言">前言</h2>
<blockquote>
<p>什么是Docker？</p>
</blockquote>
<p>Docker是一个开源的应用容器引擎，可以将应用程序打包成镜像，然后发布到任何的Linux机器上，也可以实现虚拟化</p>
<p>简单来说，Docker就好比是虚拟机，虚拟机可以模拟出电脑硬件，并且可以很方便的克隆，但是虚拟机的缺点也非常明显，它会占用宿主机非常多的硬件资源，而且启动速度也非常慢。而Linux在此基础之上发展出了一种新的容器技术，容器与宿主机共用硬件资源，启动速度也非常快，这个容器就是Docker。</p>
<h2 id="1-安装docker">1. 安装Docker</h2>
<p>Docker的安装十分简单，在Linux系统中，使用<code>yum</code>安装即可（需联网）</p>
<pre><code>yum -r install docker
# -r表示后续所有的需要确认的步骤都默认选择“是”
</code></pre>
<h2 id="2启动docker">2.启动Docker</h2>
<pre><code>service docker start
</code></pre>
<h2 id="3镜像-容器-仓库">3.镜像 容器 仓库</h2>
<p>Docker中有仓库，镜像，容器这个三个比较重要的概念。</p>
<ul>
<li>仓库类似代码仓库，集中存放镜像的场所</li>
<li>镜像类似虚拟机的镜像</li>
<li>容器则是从镜像创建的一个运行实例</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://ae01.alicdn.com/kf/H508f8c2700f043c79194c1ef521c17fao.jpg" alt="" loading="lazy"></figure>
<h2 id="4拉取镜像">4.拉取镜像</h2>
<p>拉取MySQL镜像，版本选择5.7</p>
<pre><code>docker pull mysql:5.7
</code></pre>
<h2 id="5查看镜像">5.查看镜像</h2>
<p>验证刚刚拉取的镜像是否成功</p>
<pre><code>docker images
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://ae01.alicdn.com/kf/Hb52cbf8cac344605b2c688b9bff42b73t.jpg" alt="" loading="lazy"></figure>
<h2 id="6创建mysql目录">6.创建MySQL目录</h2>
<p>创建MySQL的储存目录，用来存放数据库数据</p>
<p><code>mkdir -p</code>可以递归创建目录</p>
<pre><code>mkdir -p /usr/local/mysql/conf /usr/local/mysql/data /usr/local/mysql/logs
</code></pre>
<h2 id="7运行容器">7.运行容器</h2>
<pre><code class="language-shell">docker run -p 3309:3306 --name firstmysql -v /usr/local/mysql/conf:/etc/mysql/conf.d -v /usr/local/mysql/logs:/logs -v /usr/local/mysql/data:/var/lib/mysql -e mysql_root_password=123456 -d mysql:5.7
</code></pre>
<p>命令说明：</p>
<ul>
<li><code>--name</code>：容器命名为firstmysql</li>
<li><code>-p 3309:3306</code>：将容器的3309端口映射到宿主机的3306</li>
<li><code>-v</code>：将容器的某个目录挂载到主机的目录</li>
<li><code>-e mysql_root_password=123456</code>：初始化数据库root用户的密码为123456</li>
<li><code>-d</code>：挂后台运行</li>
</ul>
<h2 id="8查看容器状态">8.查看容器状态</h2>
<p>查看容器状态命令：</p>
<pre><code>docker ps -a
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://ae01.alicdn.com/kf/H30935c3f43784024a3b9d640e6a4baf0w.jpg" alt="" loading="lazy"></figure>
<h2 id="9进入容器">9.进入容器</h2>
<pre><code>docker exec -i -t firstmysql bash
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://ae01.alicdn.com/kf/Ha34afe45477240aa8e74e6a1d5eec0fdu.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>