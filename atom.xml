<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yihangliak.github.io</id>
    <title>Alex&apos;s Blog</title>
    <updated>2019-08-27T06:21:06.002Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yihangliak.github.io"/>
    <link rel="self" href="https://yihangliak.github.io/atom.xml"/>
    <subtitle>你好  靓仔   :D</subtitle>
    <logo>https://yihangliak.github.io/images/avatar.png</logo>
    <icon>https://yihangliak.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Alex&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Jemeter性能测试完整入门]]></title>
        <id>https://yihangliak.github.io/post/begin_jemeter</id>
        <link href="https://yihangliak.github.io/post/begin_jemeter">
        </link>
        <updated>2019-07-23T01:18:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一章-性能基础知识">第一章 性能基础知识</h1>
<h2 id="1-性能测试的概念">1. 性能测试的概念</h2>
<p>通过性能测试工具模拟多种正常，峰值，以及异常负载条件来对系统的各项性能指标进行测试</p>
<h2 id="2性能测试的目的">2.性能测试的目的</h2>
<ul>
<li>评估系统能力</li>
<li>测试系统可靠性</li>
<li>识别系统的弱点（内存泄漏）</li>
<li>性能调优（满足用户需求，优化瓶颈，提高整体性能）</li>
</ul>
<blockquote>
<p>性能测试时间点，功能测试之后</p>
</blockquote>
<h2 id="3性能测试归属">3.性能测试归属</h2>
<p>测试阶段划分：系统测试</p>
<p>性能测试属于黑盒测试</p>
<p>属于6大质量特性中的：效率特性</p>
<h1 id="第二章-性能测试的分类">第二章 性能测试的分类</h1>
<h2 id="1-负载测试">1 负载测试</h2>
<ul>
<li>通过逐步给服务器增加压力，直到某项数据不达标，测试软件的瓶颈</li>
<li>评测和评估对象在不同工作量条件下的性能行为</li>
<li>负载的目标是确保系统测试超出预期工作量的情况下仍然可以继续运行</li>
</ul>
<h2 id="2-压力测试">2 压力测试</h2>
<ul>
<li>强度测试，通过高负载的手段来使服务器资源处于极限状态，直到某项数据失效，测试系统的极限</li>
<li>通过高负载的手段，可以更快的发现系统内存泄漏以及稳定性等问题</li>
</ul>
<h2 id="3-失效恢复性测试">3 失效恢复性测试</h2>
<ul>
<li>出现问题后能否根据预先制定的策略恢复，且恢复后能正常工作</li>
</ul>
<h2 id="4-并发测试">4 并发测试</h2>
<ul>
<li>测试多用户按照预定的场景请求某个业务或者功能时，是否会出现问题</li>
<li>几乎所有的性能测试都会涉及到并发测试，并发测试的主要目的是找出并发问题（资源争用）</li>
</ul>
<h2 id="5-稳定性测试">5 稳定性测试</h2>
<ul>
<li>一般使用目标负载的1.5-2倍的负载量或者CPU占用达到70%，测试系统长时间运行（7x24），观察系统稳定性</li>
</ul>
<h2 id="6-配置测试">6 配置测试</h2>
<ul>
<li>通过调整系统软件、硬件环境，了解在不同情况下系统性能指标情况，从而找到系统最优配置</li>
</ul>
<blockquote>
<p>新产品上线以前，先做一个配置测试，找到最优配置，然后进行负载，压力，稳定，失效恢复性等测试</p>
<p>产品上线以后主要做压力测试</p>
<p>当然，具体做什么类型的性能测试，需要根据项目背景去灵活选择</p>
</blockquote>
<h1 id="第三章-性能术语">第三章 性能术语</h1>
<h2 id="1-事务">1 事务</h2>
<p>一个任务从开始到结束的过程</p>
<blockquote>
<p>事务具有原子性</p>
<p>原子性：整个程序操作过程中的所有操作，要么全部完成，要么全部不完成</p>
</blockquote>
<h2 id="2-响应时间">2 响应时间</h2>
<p>系统对请求作出响应的时间（一个事务处理完成的时间）</p>
<blockquote>
<p>响应时间=网络传输时间+web服务器处理时间+DB服务器处理时间+浪费时间</p>
<p>258原则：</p>
<p>&lt;2秒快<br>
大于2小于5秒可以<br>
大于5小于8秒勉强接受<br>
大于8秒不耐烦了，或者认为系统已经失去响应，而选择离开这个Web站点，或者发起第二次请</p>
</blockquote>
<h2 id="3-吞吐量">3 吞吐量</h2>
<p>每秒服务器处理的请求或者事务数</p>
<p>吞吐量衡量单位：</p>
<ul>
<li>每秒请求数</li>
<li>每秒事务数（TPS）</li>
<li>每秒页面数</li>
<li>每秒查询数（QPS）</li>
</ul>
<h2 id="4-并发">4 并发</h2>
<ul>
<li>绝对并发：不同用户，在同一时刻，做同一个操作</li>
<li>相对并发：不用用户，在同一时刻，做不同操作</li>
</ul>
<h2 id="5-并发数">5 并发数</h2>
<p>同一时间操作的用户个数</p>
<h2 id="6-场景">6 场景</h2>
<p>模拟用户的真实操作过程</p>
<p>分类：</p>
<ul>
<li>单一场景：单个操作</li>
<li>混合场景：多个组合操作</li>
</ul>
<h2 id="7-思考时间">7 思考时间</h2>
<p>用户每个操作之间的间隔时间，增加间隔时间可以更真实地模拟用户使用的场景</p>
<h2 id="8-性能瓶颈">8 性能瓶颈</h2>
<p>软件的性能缺陷</p>
<p>这个缺陷主要分布在：</p>
<ul>
<li>硬件：如cpu等配置过低</li>
<li>应用服务器：如web服务器，数据库系统等</li>
<li>程序：程序设计的问题</li>
<li>操作系统：如Windows虚拟内存交换效果不理想等</li>
<li>网络设备：防火墙，交换机等</li>
</ul>
<h1 id="第四章-性能测试工具">第四章 性能测试工具</h1>
<h2 id="1-工具分类">1 工具分类</h2>
<p><strong>jmeter</strong></p>
<ul>
<li>免费，开源</li>
<li>支持二次开发</li>
<li>支持分布式部署</li>
<li>支持命令行模式</li>
</ul>
<p><strong>LoadRunner</strong></p>
<ul>
<li>商业，收费</li>
</ul>
<p><strong>Locust</strong></p>
<ul>
<li>python开源性能测试工具</li>
</ul>
<p><strong>Apache ab</strong></p>
<ul>
<li>Apache的web性能测试工具</li>
</ul>
<h1 id="第五章-jmeter原理与安装">第五章  Jmeter原理与安装</h1>
<h2 id="1-工作原理">1 工作原理</h2>
<p>使用取样器向服务器发送请求，从服务器获取响应结果，然后通过线程组模拟服务器压力</p>
<h2 id="2-安装">2 安装</h2>
<p>安装JDK并配置环境变量</p>
<p>官网下载jmeter压缩包，并解压</p>
<p>双击bin目录下的jmeter.bat启动即可</p>
<h2 id="3-常用组件">3 常用组件</h2>
<p>Test Plan：测试计划（场景）</p>
<ul>
<li>Thread Group：线程组，模拟并发数
<ul>
<li>http request ：取样器，模拟用户请求
<ul>
<li>view result tree：查看结果树，监听取样器的结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/05/23/5ce651c23611220681.png" alt=""></p>
<p>在取样器中添加响应断言</p>
<p><img src="https://i.loli.net/2019/05/23/5ce654857964383456.png" alt=""></p>
<p>断言界面详解</p>
<p><img src="https://i.loli.net/2019/05/23/5ce655cf44fc126049.png" alt=""></p>
<p>添加聚合报告</p>
<p><img src="https://i.loli.net/2019/05/23/5ce656572cffc62167.png" alt=""></p>
<p>聚合报告详情</p>
<p><img src="https://i.loli.net/2019/05/23/5ce658c11d59d64211.png" alt=""></p>
<h2 id="4-第一个脚本">4 第一个脚本</h2>
<p>1.新建测试计划</p>
<p>2.创建线程组</p>
<p>3.添加http取样器</p>
<p>4.添加监听器-view result tree</p>
<p>5.添加断言-response assertion</p>
<p>6.添加聚合报告</p>
<p>ecshop登录脚本</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66637dacc955298.png" alt=""></p>
<h1 id="第六章-jmeter常用组件">第六章 jmeter常用组件</h1>
<h2 id="1-参数化">1 参数化</h2>
<p>1.设置用户自定义变量</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66b3899da523409.png" alt=""></p>
<p>调用方式与RF一致，${变量名}</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66f8a9d53b90774.png" alt=""></p>
<p>添加参数化文件读取组件</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66f2c1f19c73246.png" alt=""></p>
<p><img src="https://i.loli.net/2019/05/23/5ce66fa76129952059.png" alt=""></p>
<h2 id="2-cookie关联">2 cookie关联</h2>
<p>把上一个取样器的结果关联到一下个取样器</p>
<p>http cookie manager 可以把cookie自动关联到下一个取样器的请求中</p>
<p>在同一个线程组中添加一个 HTTP cookie manager</p>
<p><img src="https://i.loli.net/2019/05/24/5ce75a94d259889153.png" alt=""></p>
<p>添加完成以后无需配置，即可将第一个取样器中的cookie自动同步至所有线程组</p>
<h2 id="3-上传文件">3  上传文件</h2>
<p>以ecshop留言上传文件为例</p>
<p>首先添加一个发表留言并且要上传文件的取样器，并配置好取样器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce75d54d671b93977.png" alt=""></p>
<p>配置文件上传参数</p>
<p><img src="https://i.loli.net/2019/05/24/5ce75e271af0025911.png" alt=""></p>
<p>运行成功示意图</p>
<h2 id="4-正则提取器">4  正则提取器</h2>
<p>提取取样器结果中的任何内容</p>
<p>通过表达式从一堆数据中提取符合表达式规则的数据</p>
<p>语法：</p>
<pre><code>[0-9]  : 表示任意一个数字，等价于/d
[a-z]  : 表示任意一个小写字母
[A-Z]  : 表示任意一个大写字母
\w     : 表示任意一个字符，包含大小写字母，中文，数字以及一个_
\s     : 表示一个空格
{}     : 表示匹配前面表达式的连续n个
{m,n}  : 表示匹配前面表达式的连续m-n个
+      : 表示匹配前面表达式的一个或多个
\      : 去转义
.      : 表示出了换行符之外的任意一个字符
$      : 结尾
^      : 开头
？     ： 非贪婪匹配，匹配到一个结果后结束匹配
()     : 需要提取的内容用小括号包围

</code></pre>
<p>添加正则提取器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce79fbf48c9a19994.png" alt=""></p>
<p>配置正则提取器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7a0dc8de5817775.png" alt=""></p>
<p>在一下个查询订单详情的取样器中使用上述提取出的变量</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7a1a2cae6f21453.png" alt=""></p>
<h2 id="5-添加debug组件">5  添加debug组件</h2>
<p>该组件可以查看所有使用过的变量</p>
<p>添加debug组件</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7aa82246b181060.png" alt=""></p>
<p>为该组件添加一个结果树，即可查看使用过的变量</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1558686516491.png" alt=""></p>
<h2 id="6-逻辑控制器">6  逻辑控制器</h2>
<p>逻辑控制器，可以控制取样器的执行顺序</p>
<h3 id="61-for">6.1 for</h3>
<p>添加for循环控制器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ae70d9dda97533.png" alt=""></p>
<p>将查询订单详情挪至for控制器里面</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ae13e19b824772.png" alt=""></p>
<p>配置for控制器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ba0abf23475823.png" alt=""></p>
<p>修改正则提取中的配置</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7af62df31663732.png" alt=""></p>
<p>在查询订单中使用遍历出来得变量即可</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ba3b3d35a16894.png" alt=""></p>
<h3 id="62-if">6.2 if</h3>
<p>添加if控制器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7bb8e3673832089.png" alt=""></p>
<p>确定判断逻辑</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1558691180942.png" alt=""></p>
<p>在第一步登录取样器中提取登录结果</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7bdb68b02631353.png" alt=""></p>
<p>然后分别配置登录成功与登录失败需要执行的步骤</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7be22baf8b41429.png" alt=""></p>
<p><img src="https://i.loli.net/2019/05/24/5ce7be509b33387820.png" alt=""></p>
<h2 id="7-开关控制器">7 开关控制器</h2>
<p>方式一：通过0和1决定执行哪个，0执行第一个，1执行第二个</p>
<p>方式二：通过取样器名字决定执行哪个，名字必须与取样器完成一致才会执行</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7c63a893d843848.png" alt=""></p>
<h2 id="8-循环控制器">8  循环控制器</h2>
<p>对单个取样器进行循环操作</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7c6e140e4d40844.png" alt=""></p>
<h1 id="第七章-并发数">第七章  并发数</h1>
<h2 id="1-平均并发数">1 平均并发数</h2>
<p>计算平均并发数</p>
<pre><code>平均并发数 = 每日活跃用户数*用户使用时间/访问时间段
</code></pre>
<p>一个系统，每天2000个用户访问，访问时间集中在上午9-12点，平均每个用户访问10分钟，计算并发数</p>
<pre><code>(2000*10)/(60*3)=111(大约)
# 2000为用户数量
# 10为用户使用时间
# 60*3是为了前后单位统一，访问时间段为3个小时
</code></pre>
<h2 id="2-峰值用户数">2 峰值用户数</h2>
<pre><code>峰值用户数 = 平均并发数 + 3*sqrt（平均并发数）
</code></pre>
<h1 id="第八章-搭建资源监控环境">第八章  搭建资源监控环境</h1>
<h2 id="1服务端">1.服务端</h2>
<ul>
<li>在服务器端安装java，并且配置环境变量</li>
</ul>
<pre><code>创建java存放目录：/usr/local/java
Linux配置环境变量
cd ~   # 进入root目录
vi .bash_profile


yum -y install java-1.8.0-openjdk*
</code></pre>
<ul>
<li>上传ServerAgent.zip到/opt目录，然后解压</li>
<li>进入ServerAgent目录，启动该代理</li>
</ul>
<pre><code>./startAgent.sh     # 启动监控代理
./startAgent.sh &amp;   # 以进程方式启动监控代理
</code></pre>
<h2 id="2-jmeter端">2. jmeter端</h2>
<ul>
<li>jmeter安装插件管理器</li>
</ul>
<pre><code>将jmeter-plugins-manager-1.3.jar放至jmeter安装目录下的lib\ext中
重启jmeter
</code></pre>
<ul>
<li>在option菜单中启动插件管理器</li>
<li>在打开的插件管理器安装</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebad6c81ac693657.png" alt=""></p>
<ul>
<li>在jmeter脚本线程组中添加jpgc监听器</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebadd487f8598359.png" alt=""></p>
<ul>
<li>配置该监听器</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebae25df76815710.png" alt=""></p>
<ul>
<li>不要忘了设置线程组，配置几个线程，运行时间等</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebaf5d655f499007.png" alt=""></p>
<h1 id="第九章-性能测试流程">第九章  性能测试流程</h1>
<ul>
<li>需求分析(学习业务，分析规格文档)</li>
<li>场景设计(测试场景、测试类型、并发数、步长、思考时间)</li>
<li>编写计划</li>
<li>环境搭建、数据准备、脚本开发</li>
<li>性能测试(性能数据收集)</li>
<li>性能分析、性能调优</li>
<li>性能测试报告</li>
<li>结束</li>
</ul>
<h1 id="第十章-centos搭建ecshop">第十章  centos搭建ecshop</h1>
<p>1.上传xampp压缩包并解压</p>
<pre><code>tar -xzvf xampp-linux-1.7.7.tar.gz
</code></pre>
<p>2.进入lampp目录</p>
<p>3.输入命令启动xampp</p>
<pre><code class="language-shell">./lampp start

# 如果提示xampp只能在32位系统运行
# 使用yum命令安装32位包
yum install -y glibc*i686
</code></pre>
<p>3.启动成功后，验证是否启动成功</p>
<pre><code>netstat -anp|grep 80   # 查看httpd端口是否启动，httpd就是Apache的进程
netstat -anp|grep 3306 # 查看mysql的端口是否存在
</code></pre>
<p><img src="https://i.loli.net/2019/05/27/5cec07cf0cd3824063.png" alt=""></p>
<p>4.上传ecshop项目包到htdocs目录</p>
<p>5.解压安装即可</p>
<h1 id="第十一章-练习">第十一章  练习</h1>
<h2 id="1-ecshop登录实现参数化">1. ecshop登录实现参数化</h2>
<h3 id="11-创建登录脚本">1.1 创建登录脚本</h3>
<p>创建测试计划</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81d0f7d9b041641.png" alt=""></p>
<p>添加线程组</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81d3fdfca938484.png" alt=""></p>
<p>添加取样器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81d6076a3d26826.png" alt=""></p>
<p>配置取样器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81f7d0f95e89886.png" alt=""></p>
<p>添加观察结果树</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81f9cb20ea79058.png" alt=""></p>
<p>验证是否登录成功</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81fe80066343193.png" alt=""></p>
<h3 id="12-添加参数化组件">1.2 添加参数化组件</h3>
<p>添加参数读取组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82020025e261962.png" alt=""></p>
<p>创建参数化文件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce820debcf3155100.png" alt=""></p>
<p>配置参数化组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce821bec8c8c90652.png" alt=""></p>
<p>重新用参数化形式配置取样器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce823c7235d651409.png" alt=""></p>
<h3 id="13-添加循环控制器">1.3 添加循环控制器</h3>
<p>添加一个循环控制器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce8229f4b87e20141.png" alt=""></p>
<p>配置循环控制器，循环执行次数为3次，与参数化源文件数量对应</p>
<p><img src="https://i.loli.net/2019/05/25/5ce822c29a73c34944.png" alt=""></p>
<h3 id="14-验证结果">1.4 验证结果</h3>
<p>执行，验证是否三个账号都登录成功</p>
<p>添加断言</p>
<p><img src="https://i.loli.net/2019/05/25/5ce825276b49549803.png" alt=""></p>
<p>手工验证</p>
<p><img src="https://i.loli.net/2019/05/25/5ce824161278f49947.png" alt=""></p>
<h2 id="2-ecshop浏览器商品">2. ecshop浏览器商品</h2>
<h3 id="21-准备工作">2.1 准备工作</h3>
<p>以登录脚本为基础</p>
<ul>
<li>去掉参数化配置</li>
<li>去掉循环控制器</li>
<li>保证登录成功</li>
</ul>
<h3 id="22-关联cookie">2.2 关联cookie</h3>
<p>添加cookie关联</p>
<p><img src="https://i.loli.net/2019/05/25/5ce8282a21f5839026.png" alt=""></p>
<h3 id="23-配置用户自定义变量">2.3 配置用户自定义变量</h3>
<p>配置用户自定义变量可以在创建多个取样器时，方便取样器的配置统一性</p>
<p>添加用户自定义变量组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce829196fa8387851.png" alt=""></p>
<p>配置用户自定义变量组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82962c2e9b75133.png" alt=""></p>
<p>修改登录取样器，调用用户自定义变量</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82999679b343666.png" alt=""></p>
<p>修改浏览商品取样器配置</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82a15dd3b776964.png" alt=""></p>
<h3 id="24-观察结果与断言">2.4 观察结果与断言</h3>
<p>为浏览器商品分别添加结果树，断言，以及整个线程组的聚合报告</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82af98792689035.png" alt=""></p>
<h3 id="25-验证结果">2.5 验证结果</h3>
<p>执行脚本，查看聚合报告中的结果是否正确</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82b68eefdf11673.png" alt=""></p>
<h1 id="第十二章-图形化报告">第十二章 图形化报告</h1>
<p>以命令行的模式运行jmeter脚本,生成图形化的报告</p>
<pre><code>jmeter -n -t C:\Users\Administrator\Desktop\lejifen.jmx -l result.jtl -e -o E:\apache-jmeter-5.1.1\bin\WebReport
</code></pre>
<ul>
<li>n：非GUI模式执行JMeter；</li>
<li>t： 脚本文件(.jmx文件)的路径；</li>
<li>l： 指定生成测试结果的保存文件(.jtl格式)，此文件必须不存在；</li>
<li>e：测试结束后，生成测试报告；</li>
<li>o：用于存放测试报告的路径；</li>
</ul>
<blockquote>
<p>注意：如果要重新生成一份测试报告，都需要将Jmeter的bin目录下的jtl文件以及webreport文件夹进行删除。<br>
可以在Jmeter的bin目录下手动直接删除，也可以通过命令删除。</p>
</blockquote>
<pre><code>del /s /Q D:\Jmeter\apache-jmeter-3.2\bin\result.jtl //删除jtl文件
rd /s /Q D:\Jmeter\apache-jmeter-3.2\bin\WebReport //删除webreport文件夹
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2019 年中总结]]></title>
        <id>https://yihangliak.github.io/post/2019_mid_year</id>
        <link href="https://yihangliak.github.io/post/2019_mid_year">
        </link>
        <updated>2019-07-22T08:22:12.000Z</updated>
        <summary type="html"><![CDATA[<p>月亮总不会被太阳抛弃  所以等你的日子不值一提</p>
]]></summary>
        <content type="html"><![CDATA[<p>月亮总不会被太阳抛弃  所以等你的日子不值一提</p>
<!-- more -->
<p>不知不觉，19年已经过去大半啦<br>
马上就要再一次经历<code>happy birthday</code>的洗礼<br>
回顾这大半年  除了工作 好像没干啥事儿<br>
<strong>视力不断<code>↓</code></strong><br>
走在路上   四五米开外的东西  已是时见一斑<br>
<strong>体重不断<code>↑</code></strong><br>
办了张健身卡 从刚开始拿到卡的打鸡血模式 现在演变成了 耶 又下雨了 可以不用去跑步了的状态<br>
6月份  公司组织去桂林旅游<br>
WTF  大学毕业旅行就是去的桂林   时隔多年 竟想不到以这种方式故地重游<br>
想我一湖南人  张家界都没有去过 竟然去了桂林两次  还是旅游<br>
心态崩了<br>
最近迷上焦迈奇的歌   有一首里面写到<br>
<code>月亮总不会被太阳抛弃 所以等你的日子不值一提</code><br>
唱的真好  干的漂亮<br>
原来有时候  一个人干着不为人知的事情  very洒脱<br>
写这篇总结断断续续<br>
从早上写到晚上<br>
绞尽脑汁   东拼西凑<br>
可是到现在还是混乱得 宛如一片残垣<br>
得<br>
还是来根<code>寂寞</code>再说<br>
记忆是个好东西  可惜我没有<br>
以摆动的二郎腿结束这篇<code>zongjie</code><br>
愿顺利度过余下半年 白发少几根  体重减几斤  工资涨几分</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python Requests]]></title>
        <id>https://yihangliak.github.io/post/python-requests</id>
        <link href="https://yihangliak.github.io/post/python-requests">
        </link>
        <updated>2019-07-20T01:53:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="requests">Requests</h1>
<h1 id="1-安装requests">1. 安装requests</h1>
<p>命令行使用pip安装：<code>pip install requests</code></p>
<h1 id="2-get请求">2. get请求</h1>
<h2 id="21-get请求">2.1 get请求</h2>
<p>该方法用于向目标网址发送请求，接收响应</p>
<p><code>get</code>方法中的参数说明：</p>
<ul>
<li>url：必填，指定请求的目标网址</li>
<li>params：字典类型，指定请求参数</li>
</ul>
<p>该方法返回一个response对象，常用的方法和属性如下：</p>
<pre><code class="language-python">import requests

r = requests.get('https://api.github.com/events')  # 使用get请求访问github
print(r.status_code)                      # 打印响应状态码
print(r.text)                             # 返回str类型的响应
print(r.url)                              # 返回请求网站的url
print(r.encoding)                         # 返回响应时间的编码方式
print(r.cookies)                          # 返回响应的cookies信息
print(r.headers)                          # 返回响应头部
print(r.content)                          # 返回bytes类型的响应体
print(r.json())                           # 返回字典类型的响应体
</code></pre>
<h2 id="22-传递url参数">2.2 传递URL参数</h2>
<blockquote>
<p>注意：<code>httpbin.org</code>是一个开源的，用于测试网页请求的网站</p>
</blockquote>
<p>在get请求中，使用<code>params</code>关键字参数，可将字典类型的自定义参数传入到URL中进行拼接</p>
<pre><code class="language-python">import requests

url = 'http://httpbin.org/get'   # 定义请求目标网址
params = {                       # 定义自定义请求参数
    'key1':'value1',
    'key2':'value2'
}
r = requests.get(url, params=params)  # get请求中传入自定义参数
print(r.status_code)               # 打印状态码
print(r.url)                       # 打印传入参数后的URL
print(r.json())                    # 返回dict响应
</code></pre>
<pre><code># 状态码
200
# 传入参数后的url
http://httpbin.org/get?key1=value1&amp;key2=value2    
# 返回的dict类型数据中可以看到自定义参数
{'args': {'key1': 'value1', 'key2': 'value2'}, 'headers': {'Accept': '*/*', 'Accept-Encodinh': 'gzip, deflate', 'Connectioo': 'keep-alive', 'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.18.4'}, 'origin': '119.123.77.203, 119.123.77.203', 'url': 'https://httpbin.org/get?key1=value1&amp;key2=value2'}

</code></pre>
<h2 id="23-实例">2.3 实例</h2>
<p>以百度搜索为例</p>
<pre><code class="language-python">import requests

url = 'http://www.baidu.com/s'
params = {'wd':'python'}
r = requests.get(url, params=params)  # get方法中传入params参数，可以讲自定义参数拼接到URL中
print(r.url)                          # 打印拼接过后的URL
print(r.text)                         # 打印响应文本内容
</code></pre>
<pre><code>http://www.baidu.com/s?wd=python
</code></pre>
<h1 id="3-post请求">3. post请求</h1>
<p>在web课程中我们已经知晓了，客户端发送一些敏感的信息时，我们需要通过post请求方式，这种传输方式比get请求安全，而且是通过加密的方式传输比较安全，下面我们就介绍一下怎样通过requests库进行发送post请求</p>
<h2 id="31-data">3.1 data</h2>
<p>如果想要发送一些编码为表单形式的数据，只需要传递一个字典给<code>data</code>关键字参数，你的字典数据在发出请求时自动编码为表单形式</p>
<pre><code class="language-python">import requests

# 给data传入字典数据
r = requests.post('http://httpbin.org/post', data={'key1':'value1', 'key2':'value2'})
print(r.text)
</code></pre>
<pre><code>{
  &quot;args&quot;: {}, 
  &quot;data&quot;: &quot;&quot;, 
  &quot;files&quot;: {}, 
  &quot;form&quot;: {               # data传入到这里，以表单形式
    &quot;key1&quot;: &quot;value1&quot;, 
    &quot;key2&quot;: &quot;value2&quot;
  }, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Content-Length&quot;: &quot;23&quot;, 
    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot;
  }, 
  &quot;json&quot;: null, 
  &quot;origin&quot;: &quot;119.123.77.203, 119.123.77.203&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/post&quot;
}
</code></pre>
<h2 id="32-json">3.2 json</h2>
<p>post方法还可以以<code>json</code>关键字参数传入json数据，传入json数据时，<code>header</code>中的<code>Content-Type</code>默认为<code>application/json</code></p>
<p>将字典数据转化为<code>json</code>数据，需要导入<code>json</code>模块，并用<code>dumps</code>进行转换</p>
<pre><code class="language-python">import requests

data = {'key1':'value1', 'key2':'value2'}   # 定义字典数据

# 将字典转化为json并传入请求中
r = requests.post('http://httpbin.org/post', json=json.dumps(data))  
print(r.text)
</code></pre>
<pre><code>{
  &quot;args&quot;: {}, 
  &quot;data&quot;: &quot;\&quot;{\\\&quot;key1\\\&quot;: \\\&quot;value1\\\&quot;, \\\&quot;key2\\\&quot;: \\\&quot;value2\\\&quot;}\&quot;&quot;,   # json传到这里
  &quot;files&quot;: {}, 
  &quot;form&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Content-Length&quot;: &quot;46&quot;, 
    &quot;Content-Type&quot;: &quot;application/json&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot;
  }, 
  &quot;json&quot;: &quot;{\&quot;key1\&quot;: \&quot;value1\&quot;, \&quot;key2\&quot;: \&quot;value2\&quot;}&quot;, 
  &quot;origin&quot;: &quot;119.123.77.203, 119.123.77.203&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/post&quot;
}

</code></pre>
<h2 id="33-实例">3.3 实例</h2>
<blockquote>
<p>在真实场景中，如何能够确定<code>post</code>请求中应该传入<code>data</code>还是<code>json</code>呢？</p>
</blockquote>
<p>确定<code>post</code>请求中，应该传入<code>data</code>还是<code>json</code>，可以通过抓包工具抓取请求数据，查看请求<code>header</code>中<code>Content-Type</code>的值：</p>
<ul>
<li><code>Content-Type：application/from</code>：传入data</li>
<li><code>Content-Type：application/json</code>：传入json</li>
</ul>
<p>ecshop登录实例：</p>
<p>首先，通过<code>fiddler</code>抓包，查看ecshop登录请求头中的<code>Content-Type</code>，可以看到请求中的数据是以<code>from</code>的形式发送到服务器的，如图：</p>
<p><img src="https://i.loli.net/2019/07/22/5d352bcc4179d47999.png" alt=""></p>
<p>所以，在使用<code>requests</code>发送<code>post</code>请求时，用户名与密码都会以<code>data</code>关键字参数传入</p>
<pre><code class="language-python">import requests
import re

url = 'http://localhost:82/ecshop/user.php'
datas = {'username':'liyihang', 'password':'tashi123', 'act':'act_login'}
r = requests.post(url, data=datas)
print(r.text)

# 加入判断进行断言
if &quot;欢迎您回来！&quot; in result:
    print('登录成功')
else:
	print('登录失败')
</code></pre>
<h1 id="4-保持会话">4. 保持会话</h1>
<p>一般在项目中，很多操作都是需要先登录再进行，所以需要先发送登录请求，登录成功后，保持登录状态，再进行后续操作，在requests中保持会话，我们可以用<code>session</code>来保持登录状态</p>
<blockquote>
<p><strong>为什么session可以实现保持会话呢？</strong></p>
<p>因为底层使用的是urllib3.connectionpool 一看到连接池就会联想到数据库的连接池，对就是池化的概念。且链接是采用的HTTP 长链接，再底层是用HTTP1.1 Connection: keep-alive来实现的</p>
</blockquote>
<pre><code class="language-python">import requests

# 保持登录，然后充值100
s = requests.session()  # 建立一个session

# 定义登录与充值需要的数据
url = 'http://localhost:82/ecshop/user.php'
datas1 = {'username':'liyihang', 'password':'tashi123', 'act':'act_login'}
datas2 = {'amount':'100', 'user_note':'jiekou', 'payment_id':'2', 'act':'act_account'}

# 使用建立的session对象发送登录请求
# 登录成功后会返回的cookie会被保存在该session中
r = s.post(url, data=datas1)
# print(r.cookies)
# 发送充值请求
r2 = s.post(url, data=datas2 )
print(r2.text)

# 这里可以加一个简单判断用来断言结果是否正确
</code></pre>
<h1 id="5自定义请求头">5.自定义请求头</h1>
<h2 id="51-获取请求头">5.1 获取请求头</h2>
<blockquote>
<p><code>httpbin.org/headers</code>会返回发送请求的请求头</p>
</blockquote>
<p>请求头内容可以用<code>r.headers</code>获取</p>
<pre><code class="language-python">import requests

r = requests.get('http://httpbin.org/headers')
print(r.headers)
print(r.text)

</code></pre>
<p>结果如下，可以看到<code>user-agent</code>为requests</p>
<pre><code>{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate&quot;, 
    &quot;Connectioo&quot;: &quot;keep-alive&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot;   
  }
}
</code></pre>
<h2 id="52-自定义请求头">5.2 自定义请求头</h2>
<p>很多网站为了保证安全会设置<code>反爬虫机制</code>，也就是说对于<code>非浏览器</code>的访问拒绝响应，在这种情况下，就需要修改请求中的<code>headers</code>信息<code>伪装</code>成浏览器访问</p>
<p><strong>使用浏览器访问httpbin 获取headers</strong></p>
<p>打开浏览器，在地址栏中输入：<code>http://httpbin.org/headers</code></p>
<p>该URL会返回发送请求的请求头，所以会将浏览器发送的请求头部返回，如下：</p>
<pre><code>{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, 
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate&quot;, 
    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, 
    &quot;Connectioo&quot;: &quot;keep-alive&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, 
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
  }
}
</code></pre>
<p><strong><code>headers</code>中各参数的作用如下：</strong></p>
<ul>
<li>accept：指定客户单接受的内容类型，<code>/</code>表示任意类型，其余按照字义</li>
<li><s>accept-encoding：指定客户端接受的编码类型</s></li>
<li><s>accept-language：指定客户端接受的语言类型，<code>q=0.9</code>表示喜欢程度，不写则是1，数值越高越喜欢</s></li>
<li>connection：指定长链接处理方式，<code>keep-alive</code>表示希望保持传输链接，http本身是无状态的</li>
<li>host：服务器主机名</li>
<li>user-agent：用户代理，服务器从此处知道客户端的系统类型以及版本等信息</li>
</ul>
<p><strong>将获取到的headers 传给<code>get</code></strong></p>
<pre><code class="language-python">import requests

url = 'http://httpbin.org/headers'
header = {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;,
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate&quot;,
    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;,
    &quot;Connectioo&quot;: &quot;keep-alive&quot;,
    &quot;Host&quot;: &quot;httpbin.org&quot;,
    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
  }
# url = 'http://www.baidu.com'
r = requests.get(url, headers=header)  # 将自定义headers信息通过headers关键字参数传入
# print(r.headers)
print(r.text)
</code></pre>
<p>自定义headers后，返回的结果如下：</p>
<pre><code>{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, 
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate,gzip, deflate&quot;, 
    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, 
    &quot;Connectioo&quot;: &quot;keep-alive,keep-alive&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, 
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
  }
}

</code></pre>
<h2 id="53-实例">5.3 实例</h2>
<p>以<code>知乎发现</code>页面为例，在没有通过自定义请求头<code>伪装</code>成真实浏览器时，是获取不到该页面中的信息的，只有在将请求头伪装成与真实浏览器一样以后，才可以获取到该页面的信息</p>
<p>首先，用<code>fiddler</code>抓取知乎-发现页面请求信息，在headers中找到<code>user-agent</code>信息，并将其复制</p>
<p><img src="https://mypic-1256006100.cos.ap-chengdu.myqcloud.com/markdown_pic/Snipaste_2019-07-24_10-24-41.png" alt=""></p>
<p>然后在代码中自定义header</p>
<pre><code class="language-python">import requests

# 未定义请求头之前
# r = requests.get('https://www.zhihu.com/explore')
# print(r.text)   # 不能正常访问页面信息

header = {
    &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 &quot;
                 &quot;(KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
}

# 通过headers关键字参数将自定义header传入
r = requests.get('https://www.zhihu.com/explore', headers=header)
print(r.text)    # 正常访问知乎发现页面

</code></pre>
<h1 id="6发送https请求">6.发送HTTPS请求</h1>
<h2 id="61-sslerror">6.1 SSLError</h2>
<p>requests在发送<code>HTTPS</code>请求时，有时会报证书错误，</p>
<p>别在开启<code>Fiddler</code>抓包工具时，发送访问百度首页时会报证书错误</p>
<p>代码与错误如下：</p>
<pre><code class="language-python">import requests

r = requests.get(&quot;https://www.baidu.com&quot;)
print(r.status_code)
</code></pre>
<p>执行上述代码会报证书错误：<code>requests.exceptions.SSLError: HTTPSConnectionPool</code></p>
<h2 id="62-关闭证书验证">6.2 关闭证书验证</h2>
<blockquote>
<p>解决办法为：关闭证书验证</p>
</blockquote>
<p>Requests的请求默认<code>verify=True</code>，如果你将<code>verify</code>设置为<code>False</code>，Requests 也能忽略对 SSL 证书的验<br>
证</p>
<pre><code class="language-python">import requests

r = requests.get(&quot;https://www.baidu.com&quot;, verify=False)  # 关闭证书验证
print(r.status_code)
</code></pre>
<h2 id="63-忽略警告信息">6.3 忽略警告信息</h2>
<pre><code class="language-python">import urllib3

# 关闭警告
urllib3.disable_warnings()
r = requests.get(&quot;https://www.baidu.com&quot;, verify=False)  # 关闭证书验证
print(r.status_code)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Postman使用技巧]]></title>
        <id>https://yihangliak.github.io/post/postman-shi-yong-ji-qiao</id>
        <link href="https://yihangliak.github.io/post/postman-shi-yong-ji-qiao">
        </link>
        <updated>2019-07-19T03:40:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="postman使用教程">Postman使用教程</h1>
<h1 id="1介绍">1.介绍</h1>
<p>postman是一个接口测试工具，在做接口测试的时候，postman相当于一个客户端，他可以模拟用户发起各类的<code>HTTP请求</code>，将<code>请求</code>你数据发送至<code>服务端</code>，获取对应的响应结果，从而验证响应中的结果是否与预期值匹配；并确保开发人员能够及时处理接口中的bug，进而保证产品上线后的<code>稳定性</code>与<code>安全性</code></p>
<h1 id="2优势">2.优势</h1>
<ul>
<li>简单易用的图形用户界面</li>
<li>可以保存API请求历史记录</li>
<li>可用集合Runner来自动化测试</li>
<li>灵活的API监控</li>
</ul>
<h1 id="3安装">3.安装</h1>
<p>官网下载地址：<a href="https://www.getpostman.com/downloads/">https://www.getpostman.com/downloads/</a></p>
<p>下载安装包安装即可，注意系统位数</p>
<h1 id="4工具界面简介">4.工具界面简介</h1>
<p><img src="https://i.loli.net/2019/07/19/5d3122915979f43319.png" alt=""></p>
<h1 id="5发送请求">5.发送请求</h1>
<h2 id="51-创建请求选项卡">5.1 创建请求选项卡</h2>
<p>点击请求构建器中的<code>+</code>号，创建一个新的选项卡</p>
<p><img src="https://i.loli.net/2019/07/19/5d3123fcbb04589086.png" alt=""></p>
<h2 id="52-填写请求地址">5.2 填写请求地址</h2>
<p>以百度首页为例，在请求地址栏中填写请求地址：<code>https://www.baidu.com/s?wd=python</code></p>
<p>请求方式选择<code>get</code></p>
<p><img src="https://i.loli.net/2019/07/23/5d365e4b03f0020602.png" alt=""></p>
<p>在响应内容中：</p>
<ul>
<li>
<p><code>pretty</code>显示为格式化后的json</p>
</li>
<li>
<p><code>raw</code>是未经处理的数据</p>
</li>
<li>
<p><code>preview</code>可以预览HTML页面</p>
</li>
<li>
<p><code>status</code>为状态码</p>
</li>
</ul>
<h1 id="6使用用例集">6.使用用例集</h1>
<p>postman中可以通过新建<code>Collections</code>的方式来保存测试请求</p>
<h2 id="61-新建用例集">6.1 新建用例集</h2>
<p><img src="https://i.loli.net/2019/07/19/5d313511d1a8180663.png" alt=""></p>
<h2 id="62-添加请求到用例集">6.2 添加请求到用例集</h2>
<p>点击发送请求后的<code>save</code>按钮，保存请求到用例集</p>
<p><img src="https://i.loli.net/2019/07/19/5d3135a1c1aff47874.png" alt=""></p>
<h1 id="7断言">7.断言</h1>
<p>postman中可以为每个请求设置<code>断言</code>，用来判断接口功能是否正常</p>
<h2 id="71-添加断言">7.1 添加断言</h2>
<p>在请求界面中，点击<code>test</code>选项卡，然后在断言输入框中写入断言即可，注意要按<code>ctrl +s</code>保存</p>
<p><img src="https://i.loli.net/2019/07/19/5d31395bc5a2485354.png" alt=""></p>
<h2 id="72-查看断言结果">7.2 查看断言结果</h2>
<p>在响应界面中，点击<code>Test Results</code>可以查看到断言的结果</p>
<p><img src="https://i.loli.net/2019/07/19/5d3139b3199e187114.png" alt=""></p>
<h2 id="73-常用的断言方法">7.3 常用的断言方法</h2>
<pre><code class="language-js">pm.test(&quot;Status code is 200&quot;, function () {
    pm.response.to.have.status(200);
}); //断言状态码是200可以

pm.test(&quot;Body matches string “yunda”&quot;, function () {
    pm.expect(pm.response.text()).to.include(&quot;yunda&quot;);
}); //检查响应主体中是否包含指定字符串

pm.test(&quot;Response time is less than 200ms&quot;, function () {
    pm.expect(pm.response.responseTime).to.be.below(200);
}); //检查响应时间是否小于200ms
</code></pre>
<h1 id="8批量运行用例集">8.批量运行用例集</h1>
<p>用例集创建好并且每个请求都写好断言以后，则可以批量执行用例集，并生成相应的报告</p>
<p>首先点击用例集列表中的箭头，调出批量执行界面，点击<code>run</code></p>
<p><img src="https://i.loli.net/2019/07/19/5d3161067b60254081.png" alt=""></p>
<p>配置执行参数</p>
<p><img src="https://i.loli.net/2019/07/19/5d3161e332ee623513.png" alt=""></p>
<p>执行结果页面</p>
<p><img src="https://i.loli.net/2019/07/19/5d31622bc6e0673691.png" alt=""></p>
<h1 id="9设置环境变量">9.设置环境变量</h1>
<h2 id="91-添加环境变量">9.1 添加环境变量</h2>
<p>在postman中，设置环境变量可以快速变换接口地址</p>
<p>比如分别设置<code>生产环境</code>与<code>测试环境</code>环境变量，之后需要改变接口地址只需切换不同的环境即可</p>
<p><img src="https://i.loli.net/2019/07/19/5d3166b3ec8f688394.png" alt=""></p>
<h2 id="93-切换环境">9.3 切换环境</h2>
<p>在接口请求界面右上角可以切换该接口的环境，</p>
<p>在接口地址使用变量为双花括号包围变量名，如：</p>
<p><code>{{url}}autonumber/autoComNum?resultv2=1&amp;text=3102615141528</code></p>
<p><img src="https://i.loli.net/2019/07/19/5d31681ac9dbb19061.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL  整理]]></title>
        <id>https://yihangliak.github.io/post/mysql-lian-xi</id>
        <link href="https://yihangliak.github.io/post/mysql-lian-xi">
        </link>
        <updated>2019-06-24T02:11:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="准备数据">准备数据</h1>
<p><strong>创建学生表</strong></p>
<pre><code>CREATE TABLE `student`(
	`s_id` VARCHAR(20),
	`s_name` VARCHAR(20) NOT NULL DEFAULT '',
	`s_birth` VARCHAR(20) NOT NULL DEFAULT '',
	`s_sex` VARCHAR(10) NOT NULL DEFAULT '',
	PRIMARY KEY(`s_id`)
);
</code></pre>
<p><strong>创建课程表</strong></p>
<pre><code>CREATE TABLE `course`(
	`c_id` VARCHAR(20),
    `c_name` VARCHAR(20) NOT NULL DEFAULT '',
    `t_id` VARCHAR(20) NOT NULL,
    PRIMARY KEY(`c_id`)
);
</code></pre>
<p><strong>创建教师表</strong></p>
<pre><code>CREATE TABLE `teacher`(
	`t_id` VARCHAR(20),
    `t_name` VARCHAR(20) NOT NULL DEFAULT '',
    PRIMARY KEY(`t_id`)
);
</code></pre>
<p><strong>创建成绩表</strong></p>
<pre><code>CREATE TABLE `score`(
	`s_id` VARCHAR(20),
    `c_id` VARCHAR(20),
    `s_score` INT(3),
    PRIMARY KEY(`s_id`, `c_id`)
);
</code></pre>
<p><strong>在学生表中插入数据</strong></p>
<pre><code>insert into student values('01', '赵雷', '1990-01-01', '男');
insert into student values('02' , '钱电' , '1990-12-21' , '男');
insert into student values('03' , '孙风' , '1990-05-20' , '男');
insert into student values('04' , '李云' , '1990-08-06' , '男');
insert into student values('05' , '周梅' , '1991-12-01' , '女');
insert into student values('06' , '吴兰' , '1992-03-01' , '女');
insert into student values('07' , '郑竹' , '1989-07-01' , '女');
insert into student values('08' , '王菊' , '1990-01-20' , '女');

</code></pre>
<p><strong>在课程表中插入数据</strong></p>
<pre><code>insert into course values('01' , '语文' , '02');
insert into course values('02' , '数学' , '01');
insert into course values('03' , '英语' , '03');
</code></pre>
<p><strong>在教师表中插入数据</strong></p>
<pre><code>insert into teacher values('01' , '张三');
insert into teacher values('02' , '李四');
insert into teacher values('03' , '王五');
</code></pre>
<p><strong>在成绩表中插入数据</strong></p>
<pre><code>insert into score values('01' , '01' , 80);
insert into score values('01' , '02' , 90);
insert into score values('01' , '03' , 99);
insert into score values('02' , '01' , 70);
insert into score values('02' , '02' , 60);
insert into score values('02' , '03' , 80);
insert into score values('03' , '01' , 80);
insert into score values('03' , '02' , 80);
insert into score values('03' , '03' , 80);
insert into score values('04' , '01' , 50);
insert into score values('04' , '02' , 30);
insert into score values('04' , '03' , 20);
insert into score values('05' , '01' , 76);
insert into score values('05' , '02' , 87);
insert into score values('06' , '01' , 31);
insert into score values('06' , '03' , 34);
insert into score values('07' , '02' , 89);
insert into score values('07' , '03' , 98);
</code></pre>
<p><strong>最终数据结构</strong></p>
<p><img src="https://i.loli.net/2019/06/24/5d1047a00429076901.png" alt=""></p>
<h1 id="练习">练习</h1>
<ol>
<li>查询<code>01</code>课程比<code>02</code>课程成绩高的学生的信息及课程分数</li>
</ol>
<pre><code>select a.* ,b.s_score as 01_score,c.s_score as 02_score from student a join
score b on a.s_id=b.s_id and b.c_id='01'left join score c on a.s_id=c.s_id 
and c.c_id='02' or c.c_id = NULL where b.s_score&gt;c.s_score;
</code></pre>
<ol start="2">
<li>查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</li>
</ol>
<pre><code>select b.s_id,b.s_name,ROUND(AVG(a.s_score),2) as avg_score from student b
join score a on b.s_id=a.s_id GROUP BY b.s_id HAVING avg_score&gt;=60;
</code></pre>
<ol start="3">
<li>查询平均成绩小于60的同学的学生编号和学生姓名和平均成绩</li>
</ol>
<pre><code>SELECT b.s_id,b.s_name,AVG(a.s_score) as avg_score FROM student
b join score a ON b.s_id=a.s_id GROUP BY b.s_id HAVING avg_score&lt;=60;
</code></pre>
<ol start="4">
<li>查询所有同学的编号，姓名，选课总数，所有课程总成绩</li>
</ol>
<pre><code>SELECT a.s_id,a.s_name,COUNT(b.c_id) as sum_course,SUM(b.s_score) as
sum_score FROM student a JOIN score b ON a.s_id=b.s_id GROUP BY a.s_id;
</code></pre>
<ol start="5">
<li>查询姓<code>李</code>的老师的数量</li>
</ol>
<pre><code>SELECT COUNT(t_id) FROM teacher t WHERE t_name LIKE '李%'; 
</code></pre>
<ol start="6">
<li>查询学过<code>张三</code>老师课程的所有同学的信息</li>
</ol>
<pre><code>SELECT a.* FROM student a JOIN score b ON a.s_id=b.s_idWHERE b.c_id
IN(SELECT c_id FROM course WHERE t_id=(SELECT t_id FROM teacher WHERE
t_name='张三'));
</code></pre>
<ol start="7">
<li>查询没有学过<code>张三</code>老师课程的所有同学的信息</li>
</ol>
<pre><code>SELECT * FROM student c WHERE c.s_id NOT IN( SELECT a.s_id from student a 
JOIN score b on a.s_id=b.s_id WHERE b.c_id IN( SELECT a.c_id FROM course a
JOIN teacher b ON a.t_id=b.t_id WHERE t_name='张三' ) )
</code></pre>
<ol start="8">
<li>查询每个学生姓名的人数</li>
</ol>
<pre><code>SELECT s_name,COUNT(*) FROM student GROUP BY s_name;
</code></pre>
<ol start="9">
<li>查询没有<code>学全</code>所有课程的同学的信息</li>
</ol>
<pre><code>SELECT s.* FROM student s 
LEFT JOIN score s1 ON s.s_id=s1.s_id 
GROUP BY s.s_id 
HAVING COUNT(s1.c_id) &lt; (SELECT COUNT(*) FROM course);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进入Flask世界！ ]]></title>
        <id>https://yihangliak.github.io/post/flask-chao-qing-dao-wu-fa-xiang-xiang</id>
        <link href="https://yihangliak.github.io/post/flask-chao-qing-dao-wu-fa-xiang-xiang">
        </link>
        <updated>2019-06-21T08:44:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="flask简介">Flask简介</h1>
<blockquote>
<p>Flask是一个使用<code>Python</code>编写的轻量级web应用框架<br>
WSGI工具箱采用<code>Werzeug</code>，模板引擎使用<code>Jinjia2</code></p>
</blockquote>
<h1 id="进入flask世界">进入Flask世界</h1>
<h2 id="1安装python">1.安装Python</h2>
<p>略</p>
<h2 id="2安装python虚拟环境">2.安装Python虚拟环境</h2>
<p>Python虚拟环境常用命令</p>
<pre><code>安装virtualenv  pip install virtualenv
安装虚拟环境管理工具  virtualenvwrapper-win（Windows系统） 
创建虚拟环境：mkvirtualenv   xxx
切换到某个虚拟环境：workon xxx
退出当前虚拟环境：deactivate xxx
删除某个虚拟环境：rmvirtualenv  xxx
列出所有虚拟环境：lsvirtualenv
进入虚拟环境目录：cdvirtualenv
</code></pre>
<p>在虚拟环境中安装Flask</p>
<pre><code>cmd中：
1.首先切换到已经创建好的虚拟环境
2.输入：pip install flask
</code></pre>
<h1 id="url与视图">URL与视图</h1>
<h2 id="1服务器解释">1.服务器解释</h2>
<p><img src="https://i.loli.net/2019/06/05/5cf698581159673776.png" alt=""></p>
<h2 id="2第一个flask程序">2.第一个Flask程序</h2>
<p>Flask的优势：</p>
<ul>
<li>微型框架，简洁，扩展性强</li>
<li>flask相关依赖非常优秀（jinja2）</li>
<li>开发效率高</li>
<li>社会活跃度高</li>
</ul>
<p>新建一个first_flask_project.py文件</p>
<pre><code class="language-python">from flask import Flask #导入Flask类

from demo import config

app = Flask(__name__)  # 实例化Flask

@app.route('/')   # URL映射到对应视图函数
def hello_world():
    return 'Hello World!'


if __name__=='__main__':
    app.run(debug=True, port=81) # 测试使用的应用服务器


</code></pre>
<p>执行这个py文件</p>
<p><img src="https://i.loli.net/2019/06/05/5cf69949b9fd033530.png" alt=""></p>
<p>浏览器访问hello_world视图函数对应的网址</p>
<p><img src="https://i.loli.net/2019/06/05/5cf6998ce1e2a79941.png" alt=""></p>
<h2 id="3dubug模式">3.DUBUG模式</h2>
<h3 id="31-为什么要开启dubug模式">3.1 为什么要开启DUBUG模式</h3>
<ul>
<li>代码抛出异常后，在浏览器中可以看到错误信息</li>
<li>更新代码以后，只要保存就会使代码自动生效</li>
</ul>
<h3 id="32-开启debug模式的4种方式">3.2 开启DEBUG模式的4种方式</h3>
<p>第一种：在app.run()中传递一个debug=True参数</p>
<pre><code class="language-python">if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
<p>第二种：使用app.debug=True</p>
<pre><code class="language-python">app = Flask(__name__)  
app.debug = True
</code></pre>
<p>第三种：使用update方法，以字典追加的形式将debug参数加到config字典中</p>
<pre><code class="language-python">app = Flask(__name__) 
app.config.update(DEBUG=True)
print(isinstance(app.config, dict))  # 确认config是否是字典
</code></pre>
<p>第四种：加载配置文件的形式</p>
<ul>
<li>
<p>创建一个配置文件，再以模块形式导入</p>
</li>
<li>
<p><img src="https://i.loli.net/2019/06/05/5cf69af23e58681823.png" alt=""></p>
<pre><code class="language-python">from demo import config

app = Flask(__name__)  
app.config.from_object(config)
</code></pre>
</li>
<li>
<p>导入配置文件的形式加载配置</p>
<pre><code class="language-python">from flask import Flask 

app = Flask(__name__)  
app.config.from_pyfile('config.py') # 这样可以少些一行倒模块方法
# 注意要写文件全名（包含文件路径）
# 不仅仅是py文件，其他格式文件也可以
# 这里还有一个silent参数，设为True的话，即使文件不存在也不会报错
</code></pre>
</li>
</ul>
<h2 id="4-url的传参方式">4. URL的传参方式</h2>
<ul>
<li>视图函数上面的装饰器中URL的传参语法为：<code>/&lt;参数名&gt;</code></li>
</ul>
<blockquote>
<p>视图函数中要定义同名参数</p>
</blockquote>
<ul>
<li>
<p>举例，新增一个url_view.py文件，url为文章详情页面</p>
</li>
<li>
<pre><code class="language-python">from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World'

@app.route('/p/&lt;articel_id&gt;')
def article_detail(articel_id):  # 在视图函数中也要定义同名参数
    return '您请求的文章是：{}'.format(articel_id)

if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
</li>
</ul>
<h2 id="5url参数的数据类型">5.URL参数的数据类型</h2>
<p>1.如果没有指定具体的数据类型,那么就是使用<code>string</code>类型</p>
<p>2.<code>int</code>类型只能传递整数类型</p>
<ul>
<li>
<pre><code>@app.route('/article/&lt;int:test&gt;')
</code></pre>
</li>
</ul>
<p>3.<code>float</code>传递浮点型数据</p>
<p>4.<code>path</code>数据类型和<code>string</code>类型都可以接受任意的字符串,但是path可以接收路径,也就是说可以包含斜杠</p>
<pre><code class="language-python">@app.route('/article/&lt;path:test&gt;')
def page_detail(test):
    return '您请求的页面是:{}'.format(test)
</code></pre>
<p>请求之后的页面：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8cf06db0f727689.png" alt=""></p>
<p>5.uuid：接受符合<code>uuid</code>规则的字符串，全宇宙唯一，缺点就是太长了，一般用来做表的主键</p>
<p>先导包生成一个uuid</p>
<pre><code class="language-python">import uuid

print(uuid.uuid4())
</code></pre>
<p>在URL对应的视图函数中验证</p>
<pre><code class="language-python">@app.route('/u/&lt;uuid:user_id&gt;')
def user_detail(user_id):
    return '用户的uuid为：%s' %user_id
</code></pre>
<p>效果图</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8d2853c4ba94451.png" alt=""></p>
<p>6.any：多个URL映射到同一个视图函数</p>
<p>代码</p>
<pre><code class="language-python">@app.route('/&lt;any(user,blog):url_path&gt;/&lt;id&gt;/')
def detail(url_path, id):
    if url_path == 'user':
        return '用户id是：%s' %id
    else:
        return '博客详情是：%s' %id
</code></pre>
<p>验证<img src="https://i.loli.net/2019/06/06/5cf8d4b30d41953293.png" alt=""></p>
<h2 id="6接收用户传递的参数">6.接收用户传递的参数</h2>
<p>第一种：使用path形式（将参数嵌入到路径中）（就是上面说的）</p>
<p>第二种：使用查询字符串的方式，就是通过<code>?key=value</code>形式传递</p>
<p>代码：</p>
<pre><code class="language-python">@app.route('/d/')
def d():
    wd = request.args.get('wd')  # 注意到导入request
    return '通过字符串传递的参数是：%s' %wd
</code></pre>
<p>验证</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8dad77772c11673.png" alt=""></p>
<p>如果有多个键值对做为参数时，使用<code>&amp;</code>符号进行分割</p>
<p>实例</p>
<pre><code class="language-python">@app.route('/d/')
def d():
    wd = request.args.get('wd')
    ie = request.args.get('ie')  # 多个参数再写一个请求即可
    return '通过字符串传递的参数是：wd=%s,ie=%s' %(wd,ie)
</code></pre>
<p><img src="https://i.loli.net/2019/06/06/5cf8dbe03246a52713.png" alt=""></p>
<p><mark>如果页面想要做SEO优化，就是被搜索引擎搜索到，那么推荐使用第一种（path）传递方式，如果不在乎SEO，则可以使用第二种</mark></p>
<h2 id="7-url_for">7. url_for</h2>
<p>url_for第一个参数，应该是视图函数的名字的字符串，后面的参数传递给url</p>
<h2 id="8自定义url转换器">8.自定义URL转换器</h2>
<p>1.定义一个类，集成<code>BaseConverter</code></p>
<p>2.在这个类中，重写<code>regex</code>，也就是正则表达式</p>
<p>3.将自定义好的类，映射到<code>app.url_map.converters</code>上</p>
<pre><code class="language-python">from flask import Flask
from werkzeug.routing import BaseConverter

app = Flask(__name__)

# 定义自己的参数转换器，匹配手机号
class TelephoneConverter(BaseConverter):
    regex = r'1[85734]\d{9}'

app.url_map.converters['tel'] = TelephoneConverter # 将自定转换器添加到url_map中（字典方式添加）

@app.route('/')
def hello():
    return 'hello world'

@app.route('/user/&lt;int:user_id&gt;/')   # 自带url转换器
def user_profile(user_id):
    return '您输入的user_id为%s' %user_id

@app.route('/telephone/&lt;tel:user_phone&gt;/')   # 使用自定义url转换器
def user_phone(user_phone):
    return '您的手机号为：%s' %user_phone

if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
<p>to_python的作用：这个方法的返回值，将会传递到view函数中作为参数</p>
<pre><code class="language-python">class ListConverter(BaseConverter):
    def to_python(self, value):
        return value.split('+')
app.url_map.converters['list'] = ListConverter

@app.route('/post/&lt;list:borads&gt;/')
def posts(borads):
    return '您提交的版块是：%s' %borads
</code></pre>
<p>to_url的作用：这个方法的返回值，将会调用url_for函数的时候生成符合要求的url形式</p>
<h2 id="9其他细节知识点">9.其他细节知识点</h2>
<h3 id="91-其他电脑访问">9.1 其他电脑访问</h3>
<p>如果想在同一个局域网下让其他电脑访问本机上的flask网站</p>
<p>要设置<code>host=0.0.0.0</code>才能访问得到</p>
<h3 id="92-指定端口">9.2 指定端口</h3>
<p>设置<code>port=端口号</code></p>
<h3 id="93-url唯一">9.3 URL唯一</h3>
<p>在定义URL时，一定要记得在最后加一个斜杠</p>
<ul>
<li>如果不加斜杠，那么在浏览器中访问这个url时，如果加了斜杠就会访问不到，这样用户体验不好</li>
<li>搜索引擎会将加与不加的视为两个不同的URL，其实两个都是同一个URL，会给搜索引擎造成误解</li>
</ul>
<p>代码里面加了斜杠以后，访问时 加与不加 都可以访问</p>
<h3 id="94-请求方式">9.4 请求方式</h3>
<p>flask中的route方法，默认使用get请求</p>
<p>如果想要自定义请求方式，那么应该传递一个<code>method</code>参数</p>
<pre><code class="language-python">@app.route('/list/', methods=['GET', 'POST'])
def list():
    return 'hi'
</code></pre>
<h2 id="10页面跳转和重定向">10.页面跳转和重定向</h2>
<p>重定向分为永久性重定向和暂时性重定向，在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面</p>
<p>比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面</p>
<ul>
<li>永久性重定向：<code>http</code>的状态码是<code>301</code>，多用于旧网址被废弃了要转到一个新的网址确保用户的访问</li>
<li>暂时性重定向，<code>http</code>的状态码是<code>302</code>，表示页面的暂时性跳转。比如一个需要权限的网址，如果当前用户没有登录，应该重定向登录页面，这种情况下，应该暂时性重定向</li>
</ul>
<p>在flask中，重定向是通过<code>flask.redirect(location, code=302)</code>这个函数来实现的，<code>location</code>表示需要重定向到的URL，应该配合之前的<code>url_for</code>函数来使用，<code>code</code>表示采用哪个重定向，默认是<code>302</code>，即<code>暂时性重定向</code>，也可以修改成<code>301</code>来实现永久性重定向</p>
<p>代码案例：</p>
<pre><code class="language-python">from flask import Flask, request, url_for
from werkzeug.utils import redirect

app = Flask(__name__)

@app.route('/')
def hello():
    return 'hello world'

@app.route('/login/')
def login():
    return '这是登录页面'

@app.route('/profile/')   # 个人中心视图函数
def profile():
    if request.args.get('name'):  # 使用request检查url中是否有name参数
        return '个人中心页面'
    else:
        return redirect(url_for('login'))  # 使用redirect+url_for重定向url，注意，可以定义code参数，默认302即暂时性重定向

if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
<p>访问profile在没有加name参数的情况下会自动暂时性重定向到登录页面</p>
<p><img src="https://i.loli.net/2019/06/11/5cff5e9c07a6469200.gif" alt=""></p>
<p>访问profile加了name参数以后，正常访问到个人中心页面</p>
<p><img src="https://i.loli.net/2019/06/11/5cff5f0d7c57687406.png" alt=""></p>
<h2 id="11关于响应response">11.关于响应（Response）</h2>
<p>视图函数的返回值会被自动转换为一个响应对象，flask的转换逻辑如下：</p>
<ul>
<li>如果返回的是一个合法的响应对象，则直接返回</li>
<li>如果返回的是一个字符串，那么flask会重新创建一个<code>werkzeug.wrappers.Response</code>对象，<code>Response</code>对象将该字符串作为主体，状态码为<code>200</code>，<code>MIME</code>类型为<code>text/html</code>，然后返回该<code>Response</code>对象</li>
<li>如果返回的是一个元祖，元祖中的数据类型是（response,status,headers）。status值会覆盖默认的200状态码，headers可以是一个列表或者字典，作为额外的消息头</li>
<li>如果以上条件都不满足，flask会假设返回值是一个合法的<code>WSGI</code>应用程序，并通过<code>Response.force_type(rv,request,environ)</code>转换为一个请求对象</li>
</ul>
<blockquote>
<p>第一个例子，直接使用<code>Response</code>创建：</p>
</blockquote>
<pre><code class="language-python">from flask import Flask, Response

@app.route('/about/')
def about():
    resp = Response(response='about page', status=200, content_type='text/html;charset=utf-8')
    return resp
</code></pre>
<blockquote>
<p>第二个例子，使用<code>字符串</code>创建：</p>
</blockquote>
<pre><code class="language-python">@app.route('/')
def hello():
    return 'hello world' # 直接返回字符串，flask也会自动组装成一个Response对象返回
</code></pre>
<blockquote>
<p>第三个例子，使用<code>元祖</code>创建：</p>
</blockquote>
<pre><code class="language-python">@app.route('/about2/')
def about2():
    return 'about2',200,{'X-NAME':'Alex'}
</code></pre>
<p><img src="https://i.loli.net/2019/06/12/5d00680c5542521648.png" alt=""></p>
<blockquote>
<p>第四个例子，<code>自定义响应</code>，自定义响应必须满足三个条件：</p>
</blockquote>
<ul>
<li>必须继承自<code>Respone</code>类</li>
<li>实现类方法<code>force_type(cls,rv,nviron=None)</code></li>
<li>必须指定<code>app.respone_class</code>为你自定义的<code>Respone</code></li>
</ul>
<p><code>Restful API</code>都是通过<code>json</code>的形式进行传递，如果你的后台跟前台进行交互，所有的<code>URL</code>参数都是发送<code>json</code>数据，那么此时，可以定义一个叫做<code>JSONResponse</code>的类来代替<code>Response</code>类</p>
<pre><code class="language-python">from flask import Flask, Response, jsonify

# 将视图函数中返回的字典，转换成json对象，然后返回
class JSONResponse(Response):
    @classmethod
    def force_type(cls, response, environ=None):
        if isinstance(response, dict):
            response = jsonify(response)
        return super(JSONResponse, cls).force_type(response,environ)

app.response_class = JSONResponse

@app.route('/json/')
def json_response():
    return {'username':'alex'}
</code></pre>
<p><img src="https://i.loli.net/2019/06/12/5d0099fd2a97e99449.png" alt=""></p>
<h1 id="jinja2模板">Jinja2模板</h1>
<h2 id="1模板基础">1.模板基础</h2>
<p>在渲染模板的时候，默认会从项目根目录下的<code>templates</code>目录下查找模板</p>
<p>如果不想把模板文件放在<code>templates</code>目录下，那么可以在<code>Flask</code>初始化的时候给<code>template_folder</code>参数传值，来指定模板的路径</p>
<blockquote>
<p>在默认模板目录下查找模板</p>
</blockquote>
<pre><code class="language-python">from flask import Flask, render_template

@app.route('/')
def hello():
    return render_template('index.html')  # 在templates目录下查找模板
</code></pre>
<h2 id="2模板参数">2.模板参数</h2>
<p>在使用<code>render_template</code>渲染模板的时候，可以传递关键字参数，以后直接在模板中使用就可以了</p>
<p>如果参数过多，那么可以将所有的参数放到一个字典中，然后在传这个字典参数的时候，使用两个星号，将字典中的数据组成关键字参数传递</p>
<blockquote>
<p>举例</p>
</blockquote>
<p>视图函数中渲染模板传递参数：</p>
<pre><code class="language-python">@app.route('/')
def hello():
    context = {
        'username':'alex',
        'tel':17688165555
    }
    return render_template('index.html',**context)
</code></pre>
<p><code>HTML</code>中调用<code>视图函数</code>中的参数</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;alex&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;这是模板渲染的数据&lt;/h1&gt;
    &lt;p&gt;{{username}}&lt;/p&gt;  &lt;!-- 调用视图函数中的参数 --&gt;
    &lt;p&gt;{{tel}}&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3模板中的url_for">3.模板中的url_for</h2>
<p>模板中的<code>url_for</code>与后台视图函数中的使用基本是一致的</p>
<p>也是传递视图函数的名字，也可以传递参数</p>
<blockquote>
<p>注意：在模板中使用url_for需要在左右两边加上一对花括号，{{ url_for() }}</p>
</blockquote>
<p>举例：</p>
<p>在首页模板中添加一个<code>登录</code>链接</p>
<blockquote>
<p>在这个首页模板中使用<code>url_for</code>来与login视图函数对应</p>
<p>这个的好处就是，一旦视图函数的url变化，模板中使用url的地方会相应变化</p>
</blockquote>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt; &lt;a href=&quot;{{ url_for('login')}}&quot;&gt;登录&lt;/a&gt; &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>然后新建一个<code>login</code>模板</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;alex&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;这是登录页面&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>新建一个<code>login</code>视图函数</p>
<pre><code class="language-python">from flask import Flask, render_template, url_for

app = Flask(__name__)


@app.route('/')
def hello():
    context = {
        'username':'alex',
        'tel':17688165555
    }
    return render_template('index.html',**context)

@app.route('/login/')
def login():
    # url_for('login')
    return render_template('login.html')

if __name__ == '__main__':
    app.run(debug=True, port=81)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Selenium 从入门到实战]]></title>
        <id>https://yihangliak.github.io/post/selenium-cong-ru-men-dao-shi-zhan</id>
        <link href="https://yihangliak.github.io/post/selenium-cong-ru-men-dao-shi-zhan">
        </link>
        <updated>2019-06-21T03:29:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一章-自动化环境搭建">第一章  自动化环境搭建</h1>
<h2 id="1安装python3">1.安装Python3</h2>
<ul>
<li>安装好Python3</li>
<li>配置好环境变量</li>
</ul>
<h2 id="2安装selenium">2.安装Selenium</h2>
<ul>
<li>
<p>win+r，打开命令行窗口</p>
</li>
<li>
<p>使用pip安装Selenium</p>
<pre><code>  # 安装Selenium的最新版本
  pip install selenium

  # 安装Selenium指定版本
  pip install selenium==2.53.0
</code></pre>
</li>
</ul>
<h2 id="3下载webdriver驱动">3.下载webdriver驱动</h2>
<ul>
<li>以chrome浏览器为例</li>
<li>查看chrome浏览器版本：在地址栏输入<code>chrome://version</code></li>
</ul>
<p><img src="https://i.loli.net/2018/12/21/5c1c98f627bb7.png" alt="查看chrome版本"></p>
<ul>
<li>chromedriver下载地址：http://chromedriver.storage.googleapis.com/index.html</li>
<li>淘宝镜像站：http://npm.taobao.org/mirrors/chromedriver/</li>
<li>下载与浏览器版本对应的chrome driver</li>
<li>将下载好的chrome driver 解压，并放至到Python安装路径的根目录</li>
</ul>
<h2 id="4第一个自动化测试脚本">4.第一个自动化测试脚本</h2>
<ul>
<li>需求
<ul>
<li>打开浏览器</li>
<li>访问百度首页</li>
</ul>
</li>
</ul>
<pre><code class="language-python">from selenium import webdriver   # 导入webdriver

d = webdriver.Chrome()           # 创建浏览器对象
d.get('https://www.baidu.com')   # 调用get方法访问百度首页

d.close()                        # 关闭浏览器
</code></pre>
<h1 id="第二章-webdriver-api">第二章  webdriver API</h1>
<h2 id="1浏览器操作">1.浏览器操作</h2>
<h3 id="11浏览器最大化">1.1浏览器最大化</h3>
<ul>
<li>
<p><code>driver.maximize_window()</code></p>
</li>
<li>
<p>在统一的浏览器大小下运行用例，可以提高用例的适用性</p>
</li>
</ul>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

print('浏览器最大化')
driver.maximize_window()
driver.close()
</code></pre>
<h3 id="12-设置浏览器宽-高">1.2 设置浏览器宽、高</h3>
<ul>
<li>在不同浏览器大小下运行用例，可以对缩放、样式等进行评估</li>
<li><code>driver.set_window_size(480, 800)</code></li>
</ul>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

print('设置浏览器宽480，高800显示')
driver.set_window_size(480, 800)

sleep(2)
driver.close()
</code></pre>
<h3 id="13-控制浏览器前进-后退">1.3 控制浏览器前进、后退</h3>
<ul>
<li>前进：<code>driver.forward()</code></li>
<li>后退：<code>driver.back()</code></li>
</ul>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()

#访问百度首页
driver.get('https://www.baidu.com')
#访问百度新闻
driver.find_element_by_link_text('新闻').click()
#暂停1秒
sleep(1)
#后退到百度首页
driver.back()
#暂停1秒
sleep(1)
#前进到百度新闻
driver.forward()
#暂停1秒
sleep(1)

#关闭浏览器
driver.close()
</code></pre>
<h3 id="14-关闭浏览器">1.4 关闭浏览器</h3>
<ul>
<li>关闭当前窗口：<code>driver.close()</code></li>
<li>关闭浏览器：<code>driver.quit()</code></li>
</ul>
<h3 id="15-浏览器刷新">1.5 浏览器刷新</h3>
<ul>
<li><code>driver.refresh()</code></li>
</ul>
<h3 id="16-获取当前url">1.6 获取当前URL</h3>
<ul>
<li>
<p><code>driver.current_url</code></p>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 获取当前页面的URL
url = driver.current_url
print(url)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code>https://www.baidu.com/
</code></pre>
</li>
</ul>
<h3 id="17-获取当前title">1.7 获取当前title</h3>
<ul>
<li>
<p><code>driver.title</code></p>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

title = driver.title
print(title)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code>百度一下，你就知道
</code></pre>
</li>
</ul>
<h3 id="18-浏览器截图">1.8 浏览器截图</h3>
<ul>
<li>
<p><code>driver.save_screenshot()</code></p>
<ul>
<li>路径参数必填</li>
<li>图片格式必须为png</li>
</ul>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 截图并保存到当前路径下，名字为s1.png
driver.save_screenshot('s1.png')

# 关闭浏览器
driver.close()
</code></pre>
<h2 id="2html基础">2.HTML基础</h2>
</li>
</ul>
<h3 id="21-什么是html">2.1 什么是HTML</h3>
<ul>
<li>HTML：超文本标记语言（Hyper Text Markup Language）</li>
<li>HTML使用标记标签来描述网页</li>
</ul>
<h3 id="22-html标签">2.2 HTML标签</h3>
<ul>
<li>标签由尖括号包围</li>
<li>标签是成对出现的</li>
<li>标签对中：第一个为开始标签，第二个为结束标签</li>
</ul>
<h3 id="23-第一个网页">2.3 第一个网页</h3>
<pre><code class="language-html">&lt;html&gt;
    &lt;body&gt;
        &lt;h1&gt;我的第一个标题&lt;/h1&gt;
        &lt;p&gt;我的第一个段落&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="24-元素常见的属性">2.4 元素常见的属性</h3>
<ul>
<li>class：元素的类名</li>
<li>id：元素的唯一id</li>
<li>name：元素名，大部分情况唯一</li>
</ul>
<h3 id="25-常见的标签">2.5 常见的标签</h3>
<ul>
<li><code>&lt;a&gt;</code>：超链接</li>
<li><code>&lt;input&gt;</code>：输入标签，如输入框，按钮等</li>
<li><code>&lt;div&gt;</code>：块级元素，把文档分割为独立的、不同的部分</li>
<li><code>&lt;form&gt;</code>：为用户输入创建HTML表单</li>
<li><code>&lt;img&gt;</code>：图片</li>
<li><code>&lt;iframe&gt;</code>：定义内嵌框架，在一个HTML中嵌入另一个HTML（QQ邮箱）</li>
<li><code>&lt;span&gt;</code>：组合行内元素</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
    &lt;body&gt;
        &lt;h1&gt;我的第一个标题&lt;/h1&gt;
        &lt;p&gt;我的第一个段落&lt;/p&gt;
        &lt;form&gt;
            账号
            &lt;input type=&quot;text&quot; name=&quot;uaername&quot;&gt;
            &lt;/br&gt;
            密码
            &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3元素定位">3.元素定位</h2>
<ul>
<li>元素定位和操作是自动化测试的核心部分</li>
<li>一个元素就像一个人，有自己的特征（属性）</li>
<li>webdriver提供了一系列的元素定位方法，常用的有下面几种：
<ul>
<li>id：根据元素id值</li>
<li>name：根据元素name值</li>
<li>class name：根据元素class值</li>
<li>tag name：根据元素标签名字</li>
<li>link text：根据超链接的文本内容</li>
<li>partial link text：根据超链接的部分文本内容</li>
<li>xpath：根据xpath</li>
<li>css selector：通过css定位</li>
</ul>
</li>
</ul>
<h3 id="31-id和name定位">3.1 id和name定位</h3>
<ul>
<li>id：规定元素的唯一id</li>
<li><code>driver.find_element_by_id('su')</code></li>
<li><code>driver.find_element_by_name('wd')</code></li>
</ul>
<pre><code class="language-html"># 百度搜索框元素
&lt;input id=&quot;kw&quot; name=&quot;wd&quot; class=&quot;s_ipt&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt;

# 搜索按钮元素
&lt;input type=&quot;submit&quot; id=&quot;su&quot; value=&quot;百度一下&quot; class=&quot;bg s_btn&quot;&gt;
</code></pre>
<ul>
<li>根据id定位搜索框，根据name定位到搜索按钮</li>
</ul>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

driver.maximize_window()

# 根据id定位到百度搜索框,并输入Selenium
driver.find_element_by_name('wd').send_keys('Selenium')

# 根据name定位到搜索按钮，并点击
driver.find_element_by_id('su').click()

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
<h3 id="32-tag-name和class-name定位">3.2 tag name和class name定位</h3>
<p>HTML文本</p>
<pre><code class="language-html">&lt;div id=&quot;searchform&quot; class=&quot;jhp_big&quot; style=&quot;margin-top:-2px&quot;&gt;
&lt;form id=&quot;tsf&quot; onsubmit=&quot;return name=&quot;f&quot; method=&quot;GET&quot; action=&quot;/search&quot;&gt;
&lt;input id=&quot;kw&quot; class=&quot;s_ipt&quot; type=&quot;text&quot; name=&quot;wd&quot; autocomplete=&quot;off&quot;&gt;
</code></pre>
<ul>
<li>tag name
<ul>
<li>通过标签名定位</li>
<li>不推荐使用，因为HTML文件中有很多同名的标签名，不唯一</li>
</ul>
</li>
</ul>
<pre><code class="language-python">&lt;div&gt;
find_element_by_tag_name('div')
</code></pre>
<ul>
<li>class name：直接访问百度首页讲解，可以通过class name定位到输入框</li>
</ul>
<pre><code>class=&quot;s_ipt&quot;
find_element_by_class_name('s_ipt')
</code></pre>
<h3 id="33-link-text和partial-link-text定位">3.3 link text和partial link text定位</h3>
<ul>
<li>根据链接文本定位：<code>driver.find_element_by_link_text('新闻')</code></li>
<li>根据链接部分文本定位：<code>driver.find_element_by_partial_link_text('央视快评')</code></li>
<li>根据超链接中的文本内容定位</li>
</ul>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 根据link_text定位到百度新闻超链接，并点击
driver.find_element_by_link_text('新闻').click()
# 暂停1秒
sleep(1)
# 在新闻新闻页面，根据一条新闻链接的部分文本定位，并点击
driver.find_element_by_partial_link_text('央视快评').click()
# 暂停1秒
sleep(1)

# 关闭浏览器,quit关闭所有浏览器窗口
driver.quit()
</code></pre>
<h3 id="34-xpath定位">3.4 XPath定位</h3>
<ul>
<li>
<p>XPath是一种在XML文档中定位元素的语言，有多种可能性</p>
</li>
<li>
<p>语法</p>
<ul>
<li><code>/</code>：从根节点选取（绝对路径）</li>
<li><code>//</code>：从当前节点选取，不考虑节点的位置（相对路径）</li>
<li><code>.</code>：选取当前节点</li>
<li><code>..</code>：选取当前节点的父节点    搜索框的上两级父节点：<code>//*[@id='kw']/../..</code></li>
<li><code>@</code>：选取属性</li>
</ul>
</li>
<li>
<p>绝对路径定位上面文档中的输入框</p>
<ul>
<li>不推荐使用绝对路径定位</li>
<li>难以阅读和维护</li>
</ul>
</li>
<li>
<p>xpath定位元素时，元素没有属性，可以定位他的父节点再定位到他本身</p>
</li>
</ul>
<blockquote>
<p>注意：如果一个元素本身没有任何属性值，则可以通过xapth定位到它的父级元素再定位到它自己</p>
</blockquote>
<p><code>案例：</code><br>
使用<code>绝对路径</code>定位百度首页输入框：<code>/html/body/div/div/div/div/div/form/span/input</code><br>
使用<code>相对路径</code>定位百度首页输入框：<code>//input[@id=&quot;kw&quot;]</code><br>
当子节点有多个<code>同名</code>标签时，可以用[数字]的方法按顺序选取元素：<code>//input[@id=&quot;kw&quot;]/input[2]</code>  (选取百度首页输入框下的第二个input)</p>
<pre><code>百度搜索框：//*[@id=&quot;form&quot;]/span/input
</code></pre>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 通过绝对路径定位到输入框，并且输入selenium
driver.find_element_by_xpath(&quot;/html/body/div/div/div/div/div/form/span/input&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
<ul>
<li>相对路径定位上面文档中的输入框</li>
</ul>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 通过相对路径定位到输入框，并且输入selenium
# // 从当前节点选取
# *：匹配任何标签
# @：选取id属性为kw的节点
# 另一种写法：//input[@id='kw']
driver.find_element_by_xpath(&quot;//*[@id='kw']&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
<h3 id="35-css定位">3.5 CSS定位</h3>
<ul>
<li>
<p>语法</p>
<ul>
<li><code>#</code>：元素id属性选取，如 #kw：id为kw的元素</li>
<li><code>.</code>：元素class属性选取，如 .s_ipt：class值为s_ipt的元素</li>
<li><code>[]</code>：其他属性选取，如 [id='kw']</li>
<li>层级关系选取，如 #form &gt; span:nth-of-type(1) &gt;input
<ul>
<li>第几个span用“span:nth-of-type(n)”表示</li>
</ul>
</li>
</ul>
</li>
<li>
<p>范例</p>
<ul>
<li>
<p><code>#</code>：元素id属性选取</p>
</li>
<li>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 使用# 通过id属性定位到百度首页搜索框，并输入selenium
driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code class="language-python">
from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 使用. 通过class值定位百度首页搜索框，并输入selenium
driver.find_element_by_css_selector(&quot;.s_ipt&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()

</code></pre>
</li>
<li>
<p><code>[]</code>：其他属性选取</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 使用[] 通过id属性定位百度首页搜索框，并输入selenium
driver.find_element_by_css_selector(&quot;[id='kw']&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
</li>
<li>
<p>层级关系选取</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# css层级关系定位
# 首先通过id属性定位到form
# 然后定位form里面的第一个span
# 最后再span的子节点input为最终选取的节点
driver.find_element_by_css_selector(&quot;#form &gt; span:nth-of-type(1) &gt;input&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="36-捕获元素定位失败异常">3.6 捕获元素定位失败异常</h3>
<p>在元素可能定位失败时，为了让代码继续执行，可以捕获异常</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
from selenium.common.exceptions import NoSuchElementException # 需要先导入异常包

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

try:
    driver.find_element_by_id('kw123').send_keys('python')
except NoSuchElementException as e:
    print('元素定位失败，异常信息是：{}'.format(e))

sleep(2)
driver.quit()
</code></pre>
<p>输出信息：</p>
<pre><code>元素定位失败，异常信息是：Message: no such element: Unable to locate element: {&quot;method&quot;:&quot;id&quot;,&quot;selector&quot;:&quot;kw123&quot;}
  (Session info: chrome=73.0.3683.86)
  (Driver info: chromedriver=70.0.3538.97 (d035916fe243477005bc95fe2a5778b8f20b6ae1),platform=Windows NT 10.0.14393 x86_64)
</code></pre>
<h2 id="4元素操作">4.元素操作</h2>
<h3 id="41-输入内容">4.1 输入内容</h3>
<ul>
<li>
<p>send_keys()</p>
<pre><code class="language-python">driver.find_element_by_id('kw').send_keys('selenium')
</code></pre>
</li>
</ul>
<h3 id="42-点击元素">4.2 点击元素</h3>
<ul>
<li>
<p>click（）</p>
<pre><code class="language-python">driver.find_element_by_id('kw').click()
</code></pre>
</li>
</ul>
<h3 id="43-清空元素中的内容">4.3 清空元素中的内容</h3>
<ul>
<li>
<p>clear（）</p>
<pre><code class="language-python">driver.find_element_by_id('kw').clear()
</code></pre>
</li>
</ul>
<h3 id="44-获取元素文本内容">4.4 获取元素文本内容</h3>
<ul>
<li>
<p>text</p>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 定位到新闻超链接，再获取元素文本
text = driver.find_element_by_link_text(&quot;新闻&quot;).text
print(text)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code>新闻
</code></pre>
</li>
</ul>
<h3 id="45-获取元素的尺寸">4.5 获取元素的尺寸</h3>
<ul>
<li>
<p>size</p>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 定位到搜索框，再获取元素尺寸
size = driver.find_element_by_css_selector('#kw').size
print(size)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code>{'height': 22, 'width': 500}
</code></pre>
</li>
</ul>
<h3 id="46-获取元素属性">4.6 获取元素属性</h3>
<ul>
<li>
<p>get_attribute（）</p>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 定位到搜索框，再获取元素属性
attribute = driver.find_element_by_css_selector('#kw').get_attribute('type')
print(attribute)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code>text
</code></pre>
</li>
</ul>
<h3 id="47-提交表单">4.7 提交表单</h3>
<ul>
<li>
<p>submit（）</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 定位到搜索框
driver.find_element_by_css_selector('#kw').send_keys('selenium')
# 使用submit，代替click
driver.find_element_by_css_selector('#su').submit()

sleep(2)
# 关闭浏览器
driver.close()
</code></pre>
</li>
</ul>
<h2 id="5设置等待时间">5.设置等待时间</h2>
<h3 id="51-强制等待">5.1 强制等待</h3>
<ul>
<li>导入time模块下的sleep</li>
<li>强制让代码等待若干秒</li>
</ul>
<h3 id="52-隐式等待">5.2 隐式等待</h3>
<ul>
<li>
<p><code>driver.implicitly_wait（）</code></p>
</li>
<li>
<p>隐式等待是在等待周期内一直检测元素是否出现，元素出现后则马上继续，如果等待超时就会报错</p>
</li>
<li>
<p>隐式等待只需设置一次即可对整个测试周期生效</p>
</li>
<li>
<p>任何时候都应该加上隐式等待</p>
</li>
<li>
<p>建议设置等待时间：30s内</p>
</li>
<li>
<p>隐式等待缺陷</p>
<ul>
<li>对一些一直存在但值在变化的元素没有意义</li>
<li>如网页title</li>
</ul>
<pre><code class="language-python">
from selenium import webdriver

from time import sleep

driver = webdriver.Chrome()

driver.get('https://www.baidu.com')

# 添加智能等待

driver.implicitly_wait(10)

# 获取当前页面的title

old_title  = driver.title

print(old_title)

# 进行搜索操作

driver.find_element_by_css_selector('#kw').send_keys('selenium')

driver.find_element_by_css_selector('#su').click()

# 实验：添加强制等待后再获取新title

#sleep(3)

# 获取搜索界面的title

new_title = driver.title

print(new_title)

if old_title == new_title:

    print('智能等待对title失效，title还没有变化')

else:

    print('智能等待对title已生效')

driver.close()
</code></pre>
</li>
</ul>
<h3 id="53-显示等待ex">5.3 显示等待（ex）</h3>
<h4 id="531-title-is">5.3.1 title is</h4>
<pre><code class="language-python">from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait  # 导入webdriverwait类
from selenium.webdriver.support.expected_conditions import title_is

driver = webdriver.Chrome()         # 创建浏览器对象

# 创建webdriverwait对象
# 最长超时时间为10s
wait = WebDriverWait(driver, 10)

# 访问百度首页
driver.get('https://www.baidu.com')

# 百度首页的页面标题为：百度一下，你就知道
# 使用title_is判断
title = wait.until(title_is('百度一下，你就知道'))

# 打印title值，true表示页面标题正确，反之不正确
print(title)

# 这部分会抛出timeout异常
# 因为10s后，页面标题还是百度一下，你就知道
# 注意是用的until_not
title2 = wait.until_not(title_is('百度一下，你就知道'))
print(title2)

driver.quit()
</code></pre>
<h2 id="6浏览器控制滚动条">6.浏览器控制滚动条</h2>
<ul>
<li>
<p>阅读用户协议等页面时，通过滚动条是否拉到最下方判断用户阅读情况</p>
</li>
<li>
<p>需要操作的元素不在视觉范围内，需要拖动滚动条</p>
</li>
<li>
<p><mark>注意：拖动滚动条要加强制等待，不然拖不了</mark></p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 添加智能等待
driver.implicitly_wait(10)

# 进行搜索操作
driver.find_element_by_css_selector('#kw').send_keys('selenium')
driver.find_element_by_css_selector('#su').click()

# 加一个等待，避免页面没有加载完成导致不能拖动
sleep(1)

# 将页面滚动条拖动到底部（纵坐标）
js = 'window.scrollTo(0,10000)'
driver.execute_script(js)

# 横坐标可以与纵坐标结合使用

sleep(1)

# 将滚动条拖动到最右（横坐标）
js2 = 'window.scrollTo(10000,0)'
driver.execute_script(js2)

sleep(2)

driver.quit()
</code></pre>
</li>
</ul>
<h2 id="7下拉框操作">7.下拉框操作</h2>
<ul>
<li>下拉框源码</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
	&lt;body&gt;
		&lt;select  id='kw'&gt;
			&lt;option  value='1'&gt;湖南&lt;/option&gt;
			&lt;option  value='2'&gt;广东&lt;/option&gt;
			&lt;option  value='3'&gt;湖北&lt;/option&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="71-使用二次定位">7.1 使用二次定位</h3>
<ul>
<li>
<p>先定位到下拉框，再点击里面的选项</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
import os

driver = webdriver.Chrome()
file_path = 'file:///' + os.path.abspath('下拉框.html')
driver.get(file_path)

sleep(2)

# 定位到下拉框
m = driver.find_element_by_id('kw')
# 再点击选择里面的选项
m.find_element_by_xpath(&quot;//option[@value='2']&quot;).click()

sleep(3)

driver.quit()
</code></pre>
</li>
</ul>
<h3 id="73-使用select库">7.3 使用Select库</h3>
<ul>
<li>
<p>导入selenium自带的select库</p>
</li>
<li>
<p>再通过索引、值、文本等定位下拉框选项</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
import os
from selenium.webdriver.support.select import Select # 导入select

driver = webdriver.Chrome()
file_path = 'file:///' + os.path.abspath('下拉框.html')
driver.get(file_path)

sleep(2)

# 定位到下拉框
m = driver.find_element_by_id('ShippingMethod')

# 使用select库选择
#Select(m).select_by_index(2)  # 根据索引选择，注意索引从0开始
#Select(m).select_by_value(&quot;7.45&quot;) # 根据value值选择
Select(m).select_by_visible_text('UPS Ground ==&gt; $8.34')  # 根据标签文本选择

sleep(3)

driver.quit()
</code></pre>
</li>
</ul>
<h2 id="8多窗口处理">8.多窗口处理</h2>
<ul>
<li>
<p>根据窗口的handle值进行切换</p>
</li>
<li>
<p>获取当前窗口：<code>driver.current_window_handle</code></p>
</li>
<li>
<p>切换到指定窗口：<code>driver.switch_to.window()</code></p>
</li>
<li>
<p>获取所有窗口：<code>driver.window_handles</code></p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://news.baidu.com')
driver.implicitly_wait(20)

# 获取当前窗口handle
shouye_handle = driver.current_window_handle
print('新闻首页窗口的handle是：{}'.format(shouye_handle))

# 打开一条新闻
driver.find_element_by_partial_link_text('创新是').click()

sleep(3)

# 切换到新闻首页窗口
driver.switch_to.window(shouye_handle)

#获取所有窗口handle，返回列表
all_handle = driver.window_handles
print('所有窗口的handle是:{}'.format(all_handle))

sleep(2)

driver.quit()
</code></pre>
</li>
</ul>
<h2 id="9弹框处理">9.弹框处理</h2>
<ul>
<li>弹框源码（test目录中alert.html）</li>
<li>点击弹框中的确定：<code>driver.switch_to.alert.accept()</code></li>
<li>点击弹框中的取消：<code>driver.switch_to.alert.dismiss()</code></li>
<li>弹框中输入文本：<code>driver.switch_to.alert.send_keys('xiaoming')</code></li>
<li>获取弹框中的文本：<code>driver.switch_to.alert.text</code></li>
</ul>
<h3 id="91-点击弹框中的确定">9.1 点击弹框中的确定</h3>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
import os

driver = webdriver.Chrome()
file_path = 'file:///' + os.path.abspath('alert.html')
driver.get(file_path)

# 点击第三种弹框
driver.find_element_by_id('b3').click()
sleep(1)
# 点击弹框中的确定
driver.switch_to.alert.accept()
sleep(1)

# 点击第三种弹框
driver.find_element_by_id('b3').click()
sleep(1)
# 点击弹框中的取消
driver.switch_to.alert.dismiss()

# 点击第二种弹框
driver.find_element_by_id('b2').click()
sleep(1)
# 在弹框中输入xiaoming
driver.switch_to.alert.send_keys('xiaoming')
sleep(2)
# 点击确定
driver.switch_to.alert.accept()
sleep(2)    # 输入小明后，有一句提示语
driver.switch_to.alert.accept()

# 点击第三种弹框
driver.find_element_by_id('b3').click()
print(driver.switch_to.alert.text)

sleep(2)

driver.quit()
</code></pre>
<h2 id="10框架切换">10.框架切换</h2>
<ul>
<li>
<p>框架：frame</p>
</li>
<li>
<p>通过frame中的id/name切换：<code>driver.switch_to.frame(frame id/name)</code></p>
</li>
<li>
<p>返回默认框架：<code>driver.switch_to.default_content()</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;窗口切换&lt;/title&gt;
&lt;/head&gt;
&lt;frameset rows=&quot;50%,50%&quot; ,border=&quot;0&quot; scrolling=&quot;no&quot;
    noresize=&quot;noresize&quot;&gt;
    &lt;frame src=&quot;https://www.baidu.com/&quot; name=&quot;top&quot; noresize=&quot;noresize&quot; /&gt;
    &lt;frame src=&quot;https://www.taobao.com/&quot; name=&quot;bottom&quot; /&gt;
&lt;/frameset&gt;
&lt;/frameset&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
driver = webdriver.Chrome()
file_path = 'file:///C:/Users/%E6%9D%8E%E4%B8%80%E6%9D%AD/Desktop/frame.html'
driver.get(file_path)
driver.implicitly_wait(20)

# 切换到最顶层frame
driver.switch_to.frame('top')
# 在百度搜索框中输入selenium
driver.find_element_by_id('kw').send_keys('selenium')

# 返回默认层
driver.switch_to.default_content()

# 切换到中间层frame
driver.switch_to.frame('body')
# 如果frame没有id/name属性，则通过二次定位解决
# f = driver.find_element_by_xpath('/html/frameset/frame[2]')
# driver.switch_to.frame(f)
# 点击新浪首页中的新闻链接
driver.find_element_by_link_text('新闻').click()

sleep(2)

# 返回默认层
driver.switch_to.default_content()

driver.quit()
</code></pre>
</li>
</ul>
<pre><code class="language-python"># QQ登录
from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get(&quot;https://mail.qq.com&quot;)  #/cgi-bin/loginpage
driver.implicitly_wait(30)

# 切换到登录frame
driver.switch_to.frame('login_frame')
# 切换到账号密码登录
driver.find_element_by_id('switcher_plogin').click()
# 输入用户名
driver.find_element_by_id('u').send_keys('630746762')
# 输入密码
driver.find_element_by_id('p').send_keys('wo@NI123')
# 点击登录
driver.find_element_by_id('login_button').click()

sleep(2)
driver.quit()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 基础]]></title>
        <id>https://yihangliak.github.io/post/begin_python</id>
        <link href="https://yihangliak.github.io/post/begin_python">
        </link>
        <updated>2019-06-20T15:35:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一章-python简介">第一章 Python简介</h1>
<h2 id="1python起源">1.Python起源</h2>
<ul>
<li>Python是<code>吉多*范罗苏姆</code>在1989年圣诞节，为了打发无聊而编写的一个解释程序</li>
<li>python的意思：蟒蛇
<ul>
<li>BBC电视剧《飞行的马戏团》</li>
</ul>
</li>
<li>解释型编程语言，无需编译
<ul>
<li>先翻译成中间代码，再解释给机器运行</li>
</ul>
</li>
<li>一般情况下，同样的功能，python的代码量是java的1/5
<ul>
<li>名言：life is short，you need python（人生苦短，我用python）</li>
</ul>
</li>
<li>现有版本
<ul>
<li>python2.X（过去的版本），发布于2001年</li>
<li>python3.X（现在和未来主流版本，3.0发布于2008年）</li>
</ul>
</li>
</ul>
<h2 id="2-python的应用">2. Python的应用</h2>
<ul>
<li><strong>云计算</strong>：云计算最火语言</li>
</ul>
<blockquote>
<p>OpenStack公司，开源云计算平台就是基于python开发的</p>
</blockquote>
<ul>
<li><strong>web开发</strong>
<ul>
<li>代表：YouTube，豆瓣，知乎</li>
<li>典型框架：Django，flask</li>
</ul>
</li>
<li><strong>人工智能</strong></li>
</ul>
<blockquote>
<p>python是机器学习，神经网络，深度学习等方面主流的编程语言</p>
</blockquote>
<ul>
<li><strong>自动化运维</strong></li>
</ul>
<h2 id="3-python的优点">3. Python的优点</h2>
<ul>
<li>易学</li>
<li>免费，开源</li>
<li>可移植性强
<ul>
<li>几乎所有的操作系统都支持：Windows，macOS，Linux等</li>
</ul>
</li>
<li>丰富的模块</li>
</ul>
<h1 id="第二章-安装python">第二章 安装Python</h1>
<h2 id="1-下载python安装包">1. 下载Python安装包</h2>
<ul>
<li>网址：www.python.org</li>
<li>注意：下载前要先确定系统位数</li>
</ul>
<p><img src="https://i.loli.net/2019/03/16/5c8c4ef04bbbd.png" alt="安装python"></p>
<h2 id="2-安装">2. 安装</h2>
<ul>
<li>注意勾选添加python至系统环境变量（path）</li>
</ul>
<p><img src="https://i.loli.net/2018/12/19/5c19ec36a08d8.png" alt="勾选环境变量"></p>
<ul>
<li>修改安装路径（安装至C盘根目录，方便查找）</li>
</ul>
<p><img src="https://i.loli.net/2018/12/19/5c19ec6c5806c.png" alt="修改安装路径"></p>
<p>安装Python截图</p>
<p><img src="https://i.loli.net/2019/03/12/5c871af865770.png" alt=""></p>
<h2 id="3pip-指定国内安装源">3.pip 指定国内安装源</h2>
<p>pip默认使用国外安装源，导致安装其他包时，下载速度过慢或者出错</p>
<p>所以，推荐使用国内安装源</p>
<blockquote>
<p>python官方源：https://pypi.org</p>
<p>清华：https://pypi.tuna.tsinghua.edu.cn/simple</p>
<p>阿里云：http://mirrors.aliyun.com/pypi/simple/</p>
<p>中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</p>
<p>华中理工大学：http://pypi.hustunique.com/</p>
<p>山东理工大学：http://pypi.sdutlinux.org/</p>
<p>豆瓣：http://pypi.douban.com/simple/</p>
</blockquote>
<p>解决办法1（临时）：</p>
<pre><code class="language-shell"># 在下载时临时指定安装源
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名
</code></pre>
<p>解决办法2（永久）：</p>
<pre><code class="language-ini">Windows
1.新建一个pip目录：C：\user\xxx\pip
2.新建一个pip.ini
# 内容如下
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
trusted-host=mirrors.aliyun.com
</code></pre>
<h2 id="4第一个python程序">4.第一个python程序</h2>
<ul>
<li><code>win+r</code>，输入cmd，打开命令行窗口</li>
<li>在命令行窗口中输入python，进入python<strong>交互模式</strong></li>
<li>在交互模式中输入如下代码：</li>
</ul>
<pre><code class="language-python"># 打印“你好，世界！”
print('Hello World!')
</code></pre>
<pre><code>Hello World!
</code></pre>
<p><img src="https://i.loli.net/2018/12/19/5c19f29c1cde9.png" alt="helloworld"></p>
<h2 id="5问题解决python不是内部或外部命令star">5.问题解决：Python不是内部或外部命令:star:</h2>
<ol>
<li>首先检查python安装路径中的文件是否正常（有没有文件缺失）</li>
<li>重新配置环境变量：<code>C:\Python37;C:\Python37\Scripts</code></li>
<li>如果重新配置环境变量后依旧无法使用，卸载后重新安装</li>
</ol>
<h1 id="第三章-输出与输入">第三章 输出与输入</h1>
<h2 id="1输出">1.输出</h2>
<p>使用print函数在控制台输出指定内容</p>
<h3 id="11-输出字符串和数字">1.1 输出字符串和数字</h3>
<pre><code class="language-python"># 输出字符串
print('Helloworld')

# 输出数字
print(123)
</code></pre>
<h3 id="12-输出多个内容">1.2 输出多个内容</h3>
<p>需要同时输出多个内容时，使用逗号隔开</p>
<pre><code class="language-python">print('Helloworld',123)
</code></pre>
<h3 id="13-输出不换行">1.3 输出不换行</h3>
<p>print输出时默认是换行的，如果不想换行需要传入end参数</p>
<pre><code class="language-python">print('Helloworld',end='')
</code></pre>
<h2 id="2输入">2.输入</h2>
<p>python3中使用input函数从键盘获取数据，返回string类型</p>
<blockquote>
<p>注意：在python3中，input将所有输入的数据都保存为字符串类型</p>
</blockquote>
<pre><code class="language-python">username = input('请输入您的用户名：')
</code></pre>
<blockquote>
<p>使用input输入数据，如果需要保持原类型，比如输入数字保存为原数字类型，需要进行转型操作</p>
</blockquote>
<pre><code class="language-python"># 在input前加int（）将输入数据转成整数类型
username = int(input('请输入您的用户名：'))
</code></pre>
<h1 id="第四章-安装ide编辑器">第四章 安装IDE(编辑器)</h1>
<h2 id="1下载pycharm">1.下载Pycharm</h2>
<ul>
<li>Pycharm官网地址：http://www.jetbrains.com/pycharm/</li>
</ul>
<p><img src="https://i.loli.net/2018/12/19/5c19f12ba22b9.png" alt="下载pycharm"></p>
<h2 id="2安装pycharm">2.安装Pycharm</h2>
<p><img src="https://i.loli.net/2018/12/19/5c19f348ad773.png" alt="安装pycharm"></p>
<h2 id="3配置本地解释器">3.配置本地解释器</h2>
<ul>
<li></li>
</ul>
<h2 id="4pycharm设置模板">4.pycharm设置模板</h2>
<p><img src="https://i.loli.net/2019/03/16/5c8c57e25160f.png" alt=""></p>
<h1 id="第五章-注释">第五章 注释</h1>
<h2 id="1-注释的作用">1. 注释的作用</h2>
<ul>
<li>注释一般是用来说明代码的作用</li>
<li>纯给人看的，机器不会执行注释里的内容</li>
</ul>
<h2 id="2-单行注释">2. 单行注释</h2>
<ul>
<li>单行注释，用#号表示</li>
<li>单行注释可以单独写一行，也可以写在需要注释的代码的右侧</li>
</ul>
<pre><code class="language-python"># 这是一个单行注释
# 单行注释用一个#表示
# 可以在单独行写，也可以在某行代码后面写
print(&quot;hello word&quot;)
</code></pre>
<pre><code>hello word
</code></pre>
<h2 id="3-多行注释块注释">3. 多行注释（块注释）</h2>
<ul>
<li>多行注释，用一对三单引号或者双引号表示</li>
<li>多行注释通常用来为python文件、模块、类或者函数添加版权，功能等信息</li>
<li>多行注释可以用单行注释来实现</li>
</ul>
<pre><code class="language-python">'''
这是多行注释
多行注释用三个单引号表示
多行注释中间会保持原格式
多行注释也叫文档注释(一般放在函数里)
'''
</code></pre>
<pre><code>'\n这是多行注释\n多行注释用三个单引号表示\n多行注释中间会保持原格式\n多行注释也叫文档注释(一般放在函数里)\n'
</code></pre>
<h1 id="第六章-基础数据类型">第六章 基础数据类型</h1>
<ul>
<li>查看数据类型用type（）函数，不能传两个数据类型</li>
</ul>
<h2 id="1-整数int">1. 整数（int）</h2>
<p>游戏中使用数字记录分数，销售网站使用数字记录数量等</p>
<ul>
<li>100，0，-100</li>
</ul>
<pre><code class="language-python">a = 100				# 正整数
b = 0				# 0也是整数
c = -100			# 负整数
print(type(a))
print(type(b))
print(type(c))
</code></pre>
<pre><code>&lt;class 'int'&gt;
&lt;class 'int'&gt;
&lt;class 'int'&gt;
</code></pre>
<h2 id="2-浮点数float">2. 浮点数（float）</h2>
<ul>
<li>1.23，-1.0，0.0</li>
<li>注意：python中的除法结果会将整数转换成浮点数</li>
</ul>
<pre><code class="language-python">a = 1.23			# 正浮点数
b = -1.0			# 负浮点数
c = 0.0				# 0.0也是浮点数
print(type(a))
print(type(b))
print(type(c))
</code></pre>
<pre><code>&lt;class 'float'&gt;
&lt;class 'float'&gt;
&lt;class 'float'&gt;
</code></pre>
<blockquote>
<p>注意：使用浮点数计算时，可能会出现小数位不确定的情况，暂时忽略即可，所有语言都有这个问题</p>
</blockquote>
<pre><code class="language-python">print(0.1 + 0.2)

#0.30000000000000004
</code></pre>
<h2 id="3-字符串str">3. 字符串（str）</h2>
<ul>
<li>‘abc’</li>
<li>‘’（空字符也是字符串类型）</li>
</ul>
<pre><code class="language-python">a = 'abc'
b = ''              # 空字符串
c = '我爱中国！'
print(type(a))
print(type(b))
print(type(c))
print(a)
print(b)
print(c)
</code></pre>
<pre><code>&lt;class 'str'&gt;
&lt;class 'str'&gt;
&lt;class 'str'&gt;
abc

我爱中国！
</code></pre>
<h2 id="4-布尔值bool">4. 布尔值（bool）</h2>
<ul>
<li>True（真）</li>
<li>False（假）</li>
</ul>
<blockquote>
<p>注意：布尔值可以转换为数值，True表示1，False表示0，但是不建议对布尔值进行计算</p>
</blockquote>
<pre><code class="language-python">a = 1
b = 2
print(a&lt;b)
print(a&gt;b)
</code></pre>
<pre><code>True
False
</code></pre>
<pre><code># 布尔值的计算
# True为1，Flase为0
a = 1
b = 2
c = a &lt; b    # c为True
d = a &gt; b    # d为False

e = d - c    # e = 0 - -1
print(e)
</code></pre>
<h2 id="5-空值none">5. 空值（None）</h2>
<ul>
<li>表示什么也没有</li>
<li>注意：不同于0和空字符串</li>
<li>用来占位置</li>
</ul>
<pre><code class="language-python">a = None
print(type(a))
</code></pre>
<pre><code>&lt;class 'NoneType'&gt;

</code></pre>
<h1 id="第七章-变量">第七章 变量</h1>
<h2 id="1-变量的定义">1. 变量的定义</h2>
<ul>
<li><mark>变量是一个容器，里面可以存任意类型的数据</mark></li>
</ul>
<blockquote>
<p>去超市买东西，习惯推一个小车，车子里装需要购买的物品，为什么要推车？</p>
<p>因为可以解放双手，为什么要解放双手？可以去<mark>捏一捏方便面</mark></p>
</blockquote>
<pre><code class="language-python">teacher = '潘老师'  # 定义了一个变量，变量名叫teacher，他里面储存了一个字符串潘老师
</code></pre>
<blockquote>
<p>定义了一个变量，目的是干什么？ 使用这个变量</p>
</blockquote>
<pre><code class="language-python">print(teacher + '简直帅毙了！')
</code></pre>
<blockquote>
<p>如果又看见一次teacher=xxx，那么就不是定义变量了</p>
<p>而是变量的<mark>重新赋值</mark></p>
</blockquote>
<ul>
<li>
<p>变量实质是储存在内存中的值，创建变量会在内存中开辟一个空间</p>
</li>
<li>
<p>变量是可以重复使用的一个量（老师=李一杭，老师=江xx）</p>
</li>
<li>
<p>程序用来处理数据，而变量用来储存数据</p>
</li>
</ul>
<h2 id="2-变量的命名规范">2. 变量的命名规范</h2>
<ul>
<li>只能由数字、大小写字母、下划线组成（外国人取中文名很别扭）</li>
<li>不能以数字开头
<ul>
<li>4man，5for  是不可以的</li>
<li>man4，for5  是可以的</li>
</ul>
</li>
<li>区分大小写
<ul>
<li>forMan 与 forman不是一个变量名称</li>
</ul>
</li>
<li>不能使用系统关键字
<ul>
<li>class，from等 不可以</li>
</ul>
</li>
<li>不推荐使用下划线开头，下划线开头具有特殊含义</li>
<li>推荐
<ul>
<li>使用具有固定含义的英文单词缩写：srv=server，number=num</li>
<li>驼峰命名法
<ul>
<li>大驼峰：每个单词第一个字母大写（FirstName，LastName）  用在类名</li>
<li>小驼峰：第一个字母小写，第二个单词开始每个单词首字母大小（firstName，lastName）变量或者函数名</li>
<li>下划线：多个单词用下划线连接，单词全部小写（first_name, last_name）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是系统关键字">什么是系统关键字？</h3>
<ul>
<li>python一些具有特殊功能的标示符，这就是所谓的关键字
<ul>
<li>class, def, for...</li>
</ul>
</li>
</ul>
<h3 id="怎么查看系统自带关键字">怎么查看系统自带关键字</h3>
<ul>
<li>导入keyword包</li>
<li>使用keyword.list查看</li>
</ul>
<pre><code class="language-python"># 查看关键字的方法
import keyword     # 导入关键字模块
print(keyword.kwlist)  # 打印出全部系统关键字
</code></pre>
<pre><code>['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
</code></pre>
<h2 id="3-变量的赋值">3. 变量的赋值</h2>
<h3 id="普通赋值">普通赋值</h3>
<ul>
<li>把赋值运算符右边的值给左边的变量</li>
</ul>
<pre><code class="language-python">a = 100            #把整数100赋值给a
print(a)
</code></pre>
<pre><code>100
</code></pre>
<h3 id="序列解包赋值">序列解包赋值</h3>
<ul>
<li>左边的变量与右边的值一一对应</li>
</ul>
<pre><code class="language-python">a,b,c = 1,2,3
print(a, b, c)
</code></pre>
<pre><code>1 2 3
</code></pre>
<h3 id="链式赋值">链式赋值</h3>
<ul>
<li>一个值给多个变量</li>
</ul>
<pre><code class="language-python"># 三个变量都放入同一个值
a = b = c = 1
print(a)
print(b)
print(c)
</code></pre>
<pre><code>1
1
1
</code></pre>
<ul>
<li><mark>python的赋值语句不是表达式，没有返回值</mark></li>
<li>= 只是分隔符</li>
</ul>
<pre><code class="language-python">x = (y = 1)    
# 由于y=1没有返回值，所以将“没有返回值”赋值给x，是没有任何意义的
# 所以会报错
</code></pre>
<pre><code>  File &quot;&lt;ipython-input-30-cea8f1e49303&gt;&quot;, line 1
    x = (y = 1)
           ^
SyntaxError: invalid syntax
</code></pre>
<h1 id="第八章-运算符">第八章 运算符</h1>
<h2 id="1-算术运算符">1. 算术运算符</h2>
<h3 id="加-减-乘-除">加、减、乘、除</h3>
<p>注意：</p>
<ul>
<li>
<p>除法会将整数转为浮点数</p>
</li>
<li>
<p>除数不能为0，否则会报错</p>
</li>
</ul>
<pre><code class="language-python"># 两个对象相加
a, b = 1, 2
print(a + b)

# 两个对象相减
a, b = 10, 5
print(a - b)
# 使用负号得到负数
c = -5
print(c)

# 两个数相乘，乘号用*表示
a, b = 1, 2
c = a * b
print(c)

# 两个数相除，除号使用/表示
# 注意：除法会将整数转为浮点数
# 注意：除数不能为0，否则会报错
a, b = 10, 5
print(a/b)

</code></pre>
<h3 id="取整除">取整除</h3>
<ul>
<li>两个数相除，返回商的整数部分</li>
</ul>
<pre><code class="language-python">a, b = 10, 5
print(a//b)
</code></pre>
<pre><code>2
</code></pre>
<h3 id="取余">取余</h3>
<ul>
<li>两个数相除，返回余数</li>
</ul>
<blockquote>
<p>注意：取余时，如果除数是负数，那么结果也是一个负数</p>
</blockquote>
<pre><code class="language-python">a, b = 3, 2
print(a%b)
</code></pre>
<pre><code>1
</code></pre>
<h3 id="幂运算">幂运算</h3>
<ul>
<li>用**表示幂运算</li>
</ul>
<pre><code class="language-python">print(2**2)
</code></pre>
<pre><code>4
</code></pre>
<h2 id="2-赋值运算符">2. 赋值运算符</h2>
<ul>
<li>“=”表示赋值运算符</li>
<li>把右边的结果给左边的变量</li>
</ul>
<pre><code class="language-python">a = 2
c = a + 2
print(a)
print(c)
</code></pre>
<pre><code>2
4
</code></pre>
<h3 id="加法赋值运算符">加法赋值运算符</h3>
<ul>
<li>c += a 等效于 c = c + a</li>
</ul>
<pre><code class="language-python">a = 1
a += 1
print(a)
</code></pre>
<pre><code>2
</code></pre>
<h3 id="减法赋值云算符">减法赋值云算符</h3>
<ul>
<li>c -= a 等效于  c = c - a</li>
</ul>
<pre><code class="language-python">a = 3
a -= 1
print(a)
</code></pre>
<pre><code>2
</code></pre>
<h3 id="乘法赋值运算符">乘法赋值运算符</h3>
<ul>
<li><code>c *= a 等效于 c = c * a</code></li>
</ul>
<pre><code class="language-python">c = 2
c *= 2
print(c)
</code></pre>
<pre><code>4
</code></pre>
<h3 id="除法赋值运算符">除法赋值运算符</h3>
<ul>
<li>c /= a 等效于 c = c / a</li>
<li>注意该除法，同样的商会被转换成浮点数</li>
</ul>
<pre><code class="language-python">c = 4
c /= 2
print(c)
</code></pre>
<pre><code>2.0
</code></pre>
<h3 id="取模赋值运算符">取模赋值运算符</h3>
<ul>
<li>c %= a  等效于 c = c % a</li>
</ul>
<pre><code class="language-python">c = 5
c %= 2
print(c)
</code></pre>
<pre><code>1
</code></pre>
<h3 id="幂赋值运算符">幂赋值运算符</h3>
<pre><code>- c** = a 等效于 c = c ** a
</code></pre>
<pre><code class="language-python">c = 2 
print(c ** 2)
</code></pre>
<pre><code>4
</code></pre>
<h2 id="4-逻辑运算符">4. 逻辑运算符</h2>
<ul>
<li>and：与，并且
<ul>
<li>两个都为真，结果为真</li>
<li>有一个为假，结果为假</li>
</ul>
</li>
<li>or：或
<ul>
<li>有一个为真，结果为真</li>
</ul>
</li>
<li>not：非</li>
</ul>
<pre><code class="language-python">a = True
b = False
c = True

d = a and b    # 有一个假，结果为假
print(d)

d = a and c    # 两个都为真，结果为真
print(d)

d = a or b    # 有一个为真，结果为真
print(d)    

d = not a     # 非真即假
print(d)

d = not b     # 非假即真
print(d)
</code></pre>
<pre><code>False
True
True
False
True
</code></pre>
<h2 id="5-成员运算符x">5. 成员运算符（x）</h2>
<ul>
<li>用来检测某个变量是否是另一个变量的成员</li>
<li>in</li>
<li>not in</li>
</ul>
<pre><code class="language-python"># 案例
l = [1, 2, 3]
a = 4

b = a in l    # 返回布尔值
print(b)

b = a not in l  # 返回布尔值
print(b)
</code></pre>
<pre><code>False
True
</code></pre>
<h2 id="6比较运算符">6.比较运算符</h2>
<p>如果比较结果为真，则返回True；</p>
<p>如果比较结果为假，则返回False。</p>
<ul>
<li>大于：<code>&gt;</code></li>
<li>小于：<code>&lt;</code></li>
<li>大于等于：<code>&gt;=</code></li>
<li>小于等于：<code>&lt;=</code></li>
<li>不等于：<code>!=</code></li>
<li>等等于：<code>==</code>（两边值相等返回true，不相等返回false）</li>
</ul>
<h2 id="7-运算符的优先级">7. 运算符的优先级</h2>
<ul>
<li>永远记住，括号具有最高优先级</li>
</ul>
<pre><code class="language-python">a, b, c = 1, 2, 3

d = a + (c - b)      # 把想要优先运算的部分用括号括起来
print(d)
</code></pre>
<pre><code>2
</code></pre>
<h1 id="第九章-字符串">第九章 字符串</h1>
<h2 id="1-字符串的定义">1. 字符串的定义</h2>
<ul>
<li>字符串是python中的一种基础数据结构</li>
<li>通常是由引号包围的序列
<ul>
<li>单引号</li>
<li>双引号</li>
<li>三单引号</li>
<li>三双引号</li>
</ul>
</li>
<li>特点
<ul>
<li>
<p>有序</p>
</li>
<li>
<p>不可变（这里说的不可变是指不能修改引用对象，需要复制一个新的对象去修改）</p>
</li>
<li>
<blockquote>
<p>可以使用id查看内存地址</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python">love = 'i love you'    # 单引号
print(love)

love = &quot;i love you&quot;    #双引号
print(love)

# 三单引号
love = '''             
i
love
you
'''
print(love)

# 三双引号
love = &quot;&quot;&quot;
i
love
you
&quot;&quot;&quot;
print(love)
</code></pre>
<pre><code>i love you
i love you
             
i
love
you
</code></pre>
<p>​<br>
​    i<br>
​    love<br>
​    you</p>
<h2 id="2-格式化">2. 格式化</h2>
<ul>
<li>把数据按照一定的格式打印或者填充</li>
</ul>
<h3 id="21-百分号格式化">2.1 百分号格式化</h3>
<p>利用百分号（%）</p>
<ul>
<li>%s：字符串</li>
<li>%d：整数</li>
<li>%f：浮点数</li>
</ul>
<pre><code class="language-python"># 使用百分号格式化输出
name = '小明'
age = 18
crash = 100.0

print('%s今年%d了，他有%f元现金。' %(name, age, crash))

# %f输出浮点数的时候可以指定精度，%.2f：保留两位
print('%s今年%d了，他有%.2f元现金。' %(name, age, crash))
</code></pre>
<pre><code>小明今年18了，他有100.000000元现金。
小明今年18了，他有100.00元现金。
</code></pre>
<h3 id="22-format格式化">2.2 format格式化</h3>
<pre><code class="language-python"># 使用format函数格式化输出
# 用大括号占位
s = &quot;i love {}&quot;.format(&quot;china&quot;)
print(s)

# 用大括号加编号占位，从0开始编号
y = &quot;i love {0}, i am {1} years old, i love {0} very much!&quot;.format(&quot;china&quot;, 20)
print(y)
</code></pre>
<pre><code>i love china
i love china, i am 20 years old, i love china very much!
</code></pre>
<blockquote>
<p>注意：使用format函数填充可以对填充的变量取别名，这样可以不按照位置关系进行填充</p>
</blockquote>
<pre><code class="language-python">name = '小明'
age = 18
sex = '男生'

print('大家好，我是{p1}，{p1}今年{p2}岁，他是一个{p3}'.format(p1=name, p2=age, p3=sex))
</code></pre>
<pre><code>大家好，我是小明，小明今年18岁，他是一个男生
</code></pre>
<p><mark>数字格式化</mark></p>
<blockquote>
<p>使用format可以对数字进行格式化，案例如下</p>
</blockquote>
<pre><code class="language-python">num = 10.95822
num2= float(format(num, '0.2f'))  # 0.2f表示保留两位小数，注意会四舍五入
print(num2)   # 注意格式化数字以后会输出字符串，所以要记得转型
print(type(num2))
</code></pre>
<pre><code>10.96
&lt;class 'float'&gt;
</code></pre>
<h2 id="3-字符串的输入">3. 字符串的输入</h2>
<ul>
<li>通过input从键盘获取数据，然后保存到指定变量中</li>
<li>注意：在Python3中，input获取的数据，都是以字符串的方式进行保存，即使是数字</li>
</ul>
<pre><code class="language-python">userName = input('请输入用户名：')
print('您输入的用户名为：%s'%userName)

passWord = input('请输入密码：')
print('您输入的密码为：%s'%passWord)
</code></pre>
<pre><code>请输入用户名：zhangsan
您输入的用户名为：zhangsan
请输入密码：123
您输入的密码为：123
</code></pre>
<h2 id="4-转义字符">4. 转义字符</h2>
<p>转义字符：是指使用反斜杠“\”对一些特殊字符进行转义</p>
<p>常见的转义字符如下：</p>
<pre><code class="language-python">\		续行符号
\n		换行符
\0		空
\t		水平制表符
\&quot;		双引号
\'		单引号
\\		一个反斜杠
\f		换页
</code></pre>
<blockquote>
<p>注意：在字符串前加上字母r（或R），那么该字符串就会原样输出，其中的转义字符将不会进行转义</p>
</blockquote>
<pre><code class="language-python"># 打印出 i'm ‘OK’！
print(&quot;I\'m \'ok\'!&quot; )

# 打印文件路径：c:\user
print('c\\:user')

print(r&quot;\t表示制表符&quot;)
print('制表符前\t制表符后')

print(r'\n表示换行')
print(&quot;第一行\n第二行&quot;)

print(r&quot;这句话里的东西都不转义\\&quot;)

print(&quot;打印结束加end&quot;, end='hi')#end为空字符串时，可以起到不换行的作用
</code></pre>
<pre><code>I'm 'ok'!
c\:user
\t表示制表符
制表符前	制表符后
\n表示换行
第一行
第二行
这句话里的东西都不转义\\
打印结束加endhi
</code></pre>
<h2 id="5-字符串的索引和取值">5. 字符串的索引和取值</h2>
<h3 id="索引">索引</h3>
<ul>
<li>&lt;索引&gt;就是编号</li>
<li>索引从0开始，不是从1开始</li>
<li>字符串实际上是字符的数组，所以也支持索引</li>
</ul>
<p><img src="https://i.loli.net/2019/01/03/5c2d7dbd49c43.png" alt="字符串的索引"></p>
<pre><code class="language-python">name = 'HelloWorld'
print(name[0])		# H
print(name[1])		# e
print(name[2])		# l
</code></pre>
<h3 id="取值">取值</h3>
<ul>
<li>
<p>取值是指对操作对象截取其中的一部分操作</p>
</li>
<li>
<p>取值的语法：<strong>[起始：结束：步长]</strong></p>
<ul>
<li>注意：截取的区间为<strong>左闭右开</strong>，即从起始开始到结束前一位，不包括结束</li>
</ul>
</li>
<li>
<p>使用方法：</p>
<ul>
<li>
<p><code>[:]</code>：从开始提取到结尾</p>
</li>
<li>
<p><code>[start:]</code>：从起始下标提取到结尾</p>
</li>
<li>
<p><code>[:end]</code>：从开头提取到结束下标，不包括结束下标</p>
</li>
<li>
<p><code>[start:end]</code>：从起始下标截取到结束下标，不包括结束下标</p>
<pre><code class="language-python">name = 'zhangsan'           # 从开头提取到结尾
print('从开头截取到结尾：{}'.format(name[:]))

name = 'zhangsan'           # 从起始下标提取到结尾
print('从起始下标1截取到结尾：{}'.format(name[1:]))

name = 'zhangsan'           # 从开头提取到结束下标5
print('从开头提取到结束下标5：{}'.format(name[:5]))

name = 'zhangsan'           # 从起始下标截取到结束下标3
print('从起始下标1截取到结束下标3：{}'.format(name[1:3]))

name = 'zhangsan'           # 从开头截取到结尾，步长为2
print('从开头截取到结尾，步长为2：{}'.format(name[::2]))
</code></pre>
<pre><code>从开头截取到结尾：zhangsan
从起始下标1截取到结尾：hangsan
从开头提取到结束下标5：zhang
从起始下标1截取到结束下标3：ha
从开头截取到结尾，步长为2：zaga
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="反向取值">反向取值</h3>
<ul>
<li>语法：[::-1]（从倒数第一个反向取值到正数第一个）</li>
</ul>
<pre><code class="language-python">name = &quot;abcdefg&quot;
print(name[::-1])
</code></pre>
<pre><code>gfedcba
</code></pre>
<h2 id="6-字符串的常见方法">6. 字符串的常见方法</h2>
<ul>
<li>分割字符串
<ul>
<li>str.split()</li>
</ul>
</li>
<li>将字符串转为大写
<ul>
<li>str.upper()</li>
</ul>
</li>
<li>将字符串转为小写
<ul>
<li>str.lower()</li>
</ul>
</li>
<li>将字符串中的某字符替换成其他字符
<ul>
<li>str.replace(原字符，新字符，替换次数)</li>
<li>注意：可以通过次数来指定替换几次，适用于一个字符出现多次的情况</li>
</ul>
</li>
<li>删除字符串中的空格:star:
<ul>
<li>删除两端空格：str.strip()</li>
<li>删除右侧空格：str.rstrip()</li>
<li>删除左侧空格：str.lstrip()</li>
</ul>
</li>
</ul>
<pre><code class="language-python"># 分割字符串
name = &quot;a,b,c,d&quot;
print(name.split(&quot;,&quot;))   # 遇到逗号就分割，返回列表

# 将字符串转为大写
name = &quot;abcd&quot;
print(name.upper())

# 将字符串转为小写
name = &quot;ABCD&quot;
print(name.lower())

# 替换字符
name = &quot;abcd&quot;
print(name.replace(&quot;a&quot;, &quot;A&quot;))  # 参数：被替换字符，替换后字符
</code></pre>
<pre><code>['a', 'b', 'c', 'd']
ABCD
abcd
Abcd
</code></pre>
<h2 id="7-查找字符串star">7. 查找字符串:star:</h2>
<p>使用str.find可以查找字符串中字符串出现的位置</p>
<p>返回字符串的<mark>第一次出现的索引</mark>，找不到则返回-1</p>
<p>格式：str.find(目标字符，开始位置，结束位置)</p>
<pre><code class="language-python">str = 'abbcdefg'
print(str.find('b'))  # 查找a字符出现的位置，返回索引值
print(str.find('b',2))  # 从索引2的位置开始查找a字符，注意返回的索引值还是从0开始的
</code></pre>
<pre><code class="language-python">1
2
</code></pre>
<h1 id="第十章-列表">第十章 列表</h1>
<h2 id="1列表的定义">1.列表的定义</h2>
<ul>
<li>列表是Python中的一种基础数据结构之一</li>
<li>列表用[]包围，元素用逗号隔开</li>
<li>元素可是任意数据类型</li>
<li>特点
<ul>
<li>有序</li>
<li>可变</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然列表元素可以是任意数据类型，但是通常情况只放入一种类型的数据，这样可以提高程序的可读性</p>
</blockquote>
<pre><code class="language-python"># 定义一个列表
a = [1, 2, 3]
print(a)
</code></pre>
<pre><code>[1, 2, 3]
</code></pre>
<blockquote>
<p>list搭配range函数可以快速生成列表</p>
</blockquote>
<pre><code class="language-python"># 快速生成一个偶数列表
l = list(range(2,11,2))
print(l)
</code></pre>
<h2 id="2-列表的循环嵌套取值">2. 列表的循环嵌套取值</h2>
<ul>
<li>将取出的列表作为新的列表继续取值即可</li>
</ul>
<pre><code class="language-python">a = [[&quot;a&quot;, &quot;b&quot;], &quot;c&quot;, [1, 2]]

# 取出数字2
print(a[2][1])
</code></pre>
<pre><code>2
</code></pre>
<h2 id="3-列表的常见方法">3. 列表的常见方法</h2>
<ul>
<li>添加值，默认添加到最后
<ul>
<li>list.append(值)</li>
</ul>
</li>
<li>将值插入到列表指定索引位置
<ul>
<li>list.insert（索引，值）</li>
</ul>
</li>
<li>删除指定索引位置的值，默认删除最后一个
<ul>
<li>list.pop(索引)</li>
</ul>
</li>
<li>删除指定值，如果有个相同值则删除第一个
<ul>
<li>list.remove(值)</li>
</ul>
</li>
<li>修改指定索引的值
<ul>
<li>list[索引]=值</li>
</ul>
</li>
<li>反转列表
<ul>
<li>list.reverse()</li>
</ul>
</li>
<li>列表从小到大排序
<ul>
<li>list.sort()</li>
</ul>
</li>
<li>列表从大到小排序
<ul>
<li>list.sort(reverse=True)</li>
</ul>
</li>
<li>求列表最大值
<ul>
<li>max(list)</li>
</ul>
</li>
<li>求列表最小值
<ul>
<li>min(list)</li>
</ul>
</li>
<li>统计值在列表中出现的次数
<ul>
<li>list.count(值)</li>
</ul>
</li>
<li>计算列表的长度
<ul>
<li>len(list)</li>
</ul>
</li>
</ul>
<pre><code class="language-python"># 添加值
a = [1, 2 ,3]
a.append(4)
print(a)
</code></pre>
<pre><code>[1, 2, 3, 4]
</code></pre>
<pre><code class="language-python">
# 指定位置插入值
# 注意：insert插入值得效率没有append高
a = [1, 2 ,3]
a.insert(0, 0)   # 索引，值
print(a)
</code></pre>
<pre><code>[0, 1, 2, 3]
</code></pre>
<pre><code class="language-python">
# 删除指定索引位置的值，不填索引删除最后一个
a = [1, 2 ,3]
a.pop()
print(a)


a = [1, 2 ,3]
a.pop(0)
print(a)
</code></pre>
<pre><code>[1, 2]
[2, 3]
</code></pre>
<pre><code class="language-python"># 删除指定值
a = [1, 2, 3]
a.remove(3)
print(a)
</code></pre>
<pre><code>[1, 2]
</code></pre>
<pre><code class="language-python"># 修改指定索引位置的值
a = [1, 2, 3, 4]
a[0] = 2
print(a)
</code></pre>
<pre><code>[2, 2, 3, 4]
</code></pre>
<pre><code class="language-python"># 反转列表
a = [1, 2, 3, 4]
a.reverse()
print(a)
</code></pre>
<pre><code>[4, 3, 2, 1]
</code></pre>
<pre><code class="language-python"># 求列表最大值
a = [1, 2, 3, 4]
print(max(a))
</code></pre>
<pre><code>4
</code></pre>
<pre><code class="language-python"># 求列表最小值
a = [1, 2, 3, 4]
print(min(a))
</code></pre>
<pre><code>1
</code></pre>
<pre><code class="language-python"># 统计值在列表中出现的次数
a = [1, 2, 3, 4, 4, 4]
print(a.count(4))
</code></pre>
<pre><code>3
</code></pre>
<pre><code class="language-python"># 计算列表的长度
a = [1, 2, 3, 4]
print(len(a))
</code></pre>
<pre><code>4
</code></pre>
<pre><code class="language-python"># 列表从小到大排序
a = [2,4,1,3]
a.sort()			# [1, 2, 3, 4]

# 列表从大到小排序
a = [2,4,1,3]
a.sort(reverse=True)	# [4, 3, 2, 1]
</code></pre>
<h2 id="4遍历列表">4.遍历列表</h2>
<h3 id="41-使用for循环">4.1 使用for循环</h3>
<pre><code class="language-python">team = ['法国', '比利时', '英格兰']
for i in team:
    print(i)
</code></pre>
<pre><code>法国
比利时
英格兰
</code></pre>
<h3 id="42-使用for和enumerate函数">4.2 使用for和enumerate()函数</h3>
<p>使用for和enumerate()函数可以同时输出列表元素与索引值</p>
<pre><code class="language-python">team = ['法国', '比利时', '英格兰']
for index,item in enumerate(team):
    print(index+1, item)            # 因索引是从0开始，故+1
</code></pre>
<pre><code>1 法国
2 比利时
3 英格兰
</code></pre>
<h2 id="5列表推导式">5.列表推导式</h2>
<p>使用列表推导式，可以快速生成一个列表</p>
<h3 id="51-生成一个指定范围的数值列表">5.1 生成一个指定范围的数值列表</h3>
<p>格式</p>
<pre><code>list = [ 表达式 for var in range]
</code></pre>
<p>举例</p>
<p>生成一个包括十个随机数的列表，随机数范围为1-100</p>
<pre><code class="language-python">import random
l = [random.randint(1,100) for x in range(10)]
print(l)

# [86, 74, 63, 30, 93, 3, 18, 68, 52, 99]
</code></pre>
<h3 id="52-根据列表生成指定列表">5.2 根据列表生成指定列表</h3>
<p>格式</p>
<pre><code>newlist = [表达式 for var in list]
</code></pre>
<p>举例</p>
<p>定义一个原有商品价格列表，在此基础上打五折</p>
<pre><code class="language-python">price = [1200, 399, 100, 10, 99]
sale = [int(x*0.5) for x in price]
print('原价格是：', price)
print('折后价格是：', sale)

# 原价格是： [1200, 399, 100, 10, 99]
# 折后价格是： [600, 199, 50, 5, 49]
</code></pre>
<h1 id="第十一章-元祖">第十一章 元祖</h1>
<h2 id="1元祖的定义">1.元祖的定义</h2>
<ul>
<li>元祖由（）包围，元素以逗号隔开</li>
<li>特点
<ul>
<li>有序</li>
<li>不可变</li>
</ul>
</li>
<li>如果元祖只有一个元素，必须加逗号以示区分</li>
</ul>
<pre><code class="language-python"># 当元祖只有一个元素时
a =(1)       # 不加逗号类型就不是元祖了
print(a)
print(type(a))

b = (1,)     # 只有一个元素时，要加逗号区分
print(b)
print(type(b))
</code></pre>
<pre><code>1
&lt;class 'int'&gt;
(1,)
&lt;class 'tuple'&gt;
</code></pre>
<h2 id="2-元祖的常见方法">2. 元祖的常见方法</h2>
<ul>
<li>将元祖转为列表
<ul>
<li>list()</li>
</ul>
</li>
<li>将列表转为元祖
<ul>
<li>tuple()</li>
</ul>
</li>
<li>求元祖的最大值
<ul>
<li>max(tuple)</li>
</ul>
</li>
<li>求元祖的最小值
<ul>
<li>min(tuple)</li>
</ul>
</li>
<li>求元祖的长度
<ul>
<li>len(tuple)</li>
</ul>
</li>
</ul>
<pre><code class="language-python"># 元祖转为列表
# 出现错误：TypeError: 'list' object is not callable
# 可能是定义了一个list列表，导致与list函数重名，不能调用
# 先打印一下list的值，如果存在，用del list删除即可
#print(list)
#del list
a = (1, 2, 3)
b = list(a)
print(b)
</code></pre>
<pre><code>[1, 2, 3]
</code></pre>
<pre><code class="language-python"># 列表转元祖
a = [1, 2, 3]
b = tuple(a)
print(b)
</code></pre>
<pre><code>(1, 2, 3)
</code></pre>
<pre><code class="language-python"># 求元祖的最大值
a = (1, 2, 3)
print(max(a))
</code></pre>
<pre><code>3
</code></pre>
<pre><code class="language-python"># 求元祖的最小值
a = (1, 2, 3)
print(min(a))
</code></pre>
<pre><code>1
</code></pre>
<pre><code class="language-python"># 求元祖的长度
a = (1, 2, 3)
print(len(a))
</code></pre>
<pre><code>3
</code></pre>
<h1 id="第十二章-字典">第十二章 字典</h1>
<h2 id="1字典的定义">1.字典的定义</h2>
<ul>
<li>字典用{}包围，元素以逗号隔开</li>
<li>字典中的数据必须以键值对的形式存在</li>
<li>键不可重复，值可以重复（若键重复，只会记住该键对应的最后一个值）</li>
<li>特点
<ul>
<li>无序</li>
<li>可变</li>
</ul>
</li>
</ul>
<pre><code class="language-python"># 定义一个字典
student = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18}
print(student)
print(type(student))
</code></pre>
<pre><code>{'name': 'zhangsan', 'age': 18}
&lt;class 'dict'&gt;
</code></pre>
<h2 id="2-字典的常用方法">2. 字典的常用方法</h2>
<h3 id="获取值">获取值</h3>
<pre><code class="language-python"># 根据键获取值
student = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18}
print(student[&quot;name&quot;])
</code></pre>
<pre><code>zhangsan
</code></pre>
<h3 id="修改值">修改值</h3>
<pre><code class="language-python"># 根据键修改值，如果值不存在则添加
student = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18}
student[&quot;age&quot;] = 19
print(student)

student[&quot;sex&quot;] = &quot;boy&quot;
print(student)
</code></pre>
<pre><code>{'name': 'zhangsan', 'age': 19}
{'name': 'zhangsan', 'age': 19, 'sex': 'boy'}
</code></pre>
<h3 id="删除值">删除值</h3>
<pre><code class="language-python"># 根据键删除键值对
student = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18}
student.pop(&quot;age&quot;)
print(student)
</code></pre>
<pre><code>{'name': 'zhangsan'}
</code></pre>
<pre><code class="language-python"># 随机删除一组键值对,以元祖形式返回被随机删除的键值对
stu1 = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;boy&quot;}
stu2 = stu1.popitem()
print(&quot;随机删除的是：&quot;)
print(stu2)
print(&quot;元祖中键值对少了一个：&quot;)
print(stu1)
</code></pre>
<pre><code>随机删除的是：
('sex', 'boy')
元祖中键值对少了一个：
{'name': 'zhangsan', 'age': 18}
</code></pre>
<h3 id="获取键">获取键</h3>
<pre><code class="language-python"># 获取键
stu1 = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;boy&quot;}
stu2 = stu1.keys()
print(stu2)
</code></pre>
<pre><code>dict_keys(['name', 'age', 'sex'])
</code></pre>
<h3 id="获取值-2">获取值</h3>
<pre><code class="language-python"># 获取值
stu1 = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;boy&quot;}
stu2 = stu1.values()
print(stu2)
</code></pre>
<pre><code>dict_values(['zhangsan', 18, 'boy'])
</code></pre>
<h3 id="获取键值对">获取键值对</h3>
<pre><code class="language-python"># 获取键值对
stu1 = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;boy&quot;}
stu2 = stu1.items()
print(stu2)
</code></pre>
<pre><code>dict_items([('name', 'zhangsan'), ('age', 18), ('sex', 'boy')])
</code></pre>
<pre><code class="language-python"># 获取值，如果不存在则返回None
stu1 = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;boy&quot;}
stu2 = stu1.get(&quot;name&quot;)
print(stu2)

stu3 = stu1.get(&quot;hi&quot;)
print(stu3)
</code></pre>
<pre><code>zhangsan
None
</code></pre>
<h3 id="字典合并x">字典合并（x）</h3>
<pre><code class="language-python"># 合并字典
stu1 = {&quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;boy&quot;}
stu2 = {&quot;score&quot;:100}
stu1.update(stu2)
print(stu1)
</code></pre>
<pre><code>{'name': 'zhangsan', 'age': 18, 'sex': 'boy', 'score': 100}
</code></pre>
<h1 id="第十三章-选择语句">第十三章 选择语句</h1>
<ul>
<li>语句格式：
<ul>
<li>if  条件：
<ul>
<li>条件满足要做的事情1</li>
<li>条件满足要做的事情2</li>
<li>...</li>
</ul>
</li>
<li>else：
<ul>
<li>条件不满足时要做的事情1</li>
<li>条件不满足时要做的事情2</li>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-if-else">1. if-else</h2>
<pre><code class="language-python"># 案例
chePiao = 1    # 用1代表有车票，0代表没有车票
if chePiao == 1:    # 比较运算符
    print(&quot;有车票，可以上火车了&quot;)
    print(&quot;终于可以见到ta了，美滋滋~~&quot;)
else:
    print(&quot;没有车票，不能上车&quot;)
    print(&quot;亲爱的，那就下次见了，一票难求啊...&quot;)

</code></pre>
<pre><code>有车票，可以上火车了
终于可以见到ta了，美滋滋~~
</code></pre>
<pre><code class="language-python"># 从键盘获取车票情况，分别打印出有票与无票的情况

chePiao = input(&quot;请输入车票情况（1,有票，0无票）：&quot;)    # 用1代表有车票，0代表没有车票
if chePiao == 1:    # 比较运算符
    print(&quot;有车票，可以上火车了&quot;)
    print(&quot;终于可以见到ta了，美滋滋~~&quot;)
else:
    print(&quot;没有车票，不能上车&quot;)
    print(&quot;亲爱的，那就下次见了，一票难求啊...&quot;)
</code></pre>
<pre><code>请输入车票情况（1,有票，0无票）：0
没有车票，不能上车
亲爱的，那就下次见了，一票难求啊...
</code></pre>
<h2 id="2-elif">2. elif</h2>
<ul>
<li>格式：
<ul>
<li>if xxx1:
<ul>
<li>事情1</li>
</ul>
</li>
<li>elif xxx2:
<ul>
<li>事情2</li>
</ul>
</li>
<li>elif xxx3:
<ul>
<li>事情3</li>
</ul>
</li>
</ul>
</li>
<li>elif必须和if一起使用，否则会出错</li>
</ul>
<pre><code class="language-python"># 判断成绩等级
# 优秀：90 &lt;= 成绩 &lt;= 100
# 良好：80 &lt;= 成绩 &lt; 90
# 中等：70 &lt;= 成绩 &lt; 80
# 一般：60 &lt;= 成绩 &lt; 70
# 不及格：0 &lt;= 成绩 &lt; 60
score = 95
if score&gt;=90 and score&lt;=100:
    print(&quot;本次考试，成绩优秀！&quot;)
elif score&gt;=80 and score&lt;90:
    print(&quot;本次考试，成绩良好！&quot;)
elif score&gt;=70 and score&lt;80:
    print(&quot;本次考试，成绩中等！&quot;)
elif score&gt;=60 and score&lt;70:
    print(&quot;本次考试，成绩一般！&quot;)
elif score&gt;=0 and score&lt;60:
    print(&quot;本次考试，成绩不及格！&quot;)
</code></pre>
<pre><code>本次考试，成绩优秀！
</code></pre>
<p>练习：季节判断</p>
<pre><code class="language-python">month = int(input('Month:'))
if month in [3,4,5]:
  print('春季')
elif month in [6,7,8]:
  print('夏季')
elif month in [9,10,11]:
  print('秋季')
elif month in [12,1,2]:
  print('冬季')
else:
  print('输入不合法')
  

month = int(input(&quot;请输入月份：&quot;))
if month &gt;= 3 and month &lt;= 5:
    print(&quot;你输入的{}月份是春天&quot;.format(month))
elif month &gt;= 6 and month &lt;= 8:
    print(&quot;你输入的{}月份是夏天&quot;.format(month))
elif month &gt;= 9 and month &lt;= 11:
    print(&quot;你输入的{}月份是秋天&quot;.format(month))
elif month ==12 or month == 1 or month == 2 :
    print(&quot;你输入的{}月份是冬天&quot;.format(month))
else:
    print(&quot;月份输入不规范,请重新输入！&quot;)
</code></pre>
<h2 id="3-if嵌套">3. if嵌套</h2>
<ul>
<li>格式
<ul>
<li>
<p>if 条件1:</p>
<ul>
<li>满足条件1 做的事情1</li>
<li>满足条件1 做的事情2</li>
<li>...(省略)...</li>
<li>if 条件2:
<ul>
<li>满足条件2 做的事情1</li>
<li>满足条件2 做的事情2</li>
<li>...(省略)...</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python">chePiao = 1    # 用1代表有车票，0代表没有车票
daolength = 20  # 刀子的长度，单位为cm

if chePiao == 1:
    print(&quot;有车票，可以进站&quot;)
    if daolength &lt; 10:
        print(&quot;通过安检&quot;)
        print(&quot;终于可以见到ta了，美滋滋~&quot;)
    else:
        print(&quot;没有通过安检&quot;)
        print(&quot;刀子的长度超过规定，等待警察处理...&quot;)
else:
    print(&quot;没有车票，不能进站&quot;)
    print(&quot;亲爱的，那就下次再见了，一票难求啊....&quot;)
    
</code></pre>
<pre><code>有车票，可以进站
没有通过安检
刀子的长度超过规定，等待警察处理...
</code></pre>
<h2 id="4-if应用猜拳游戏">4. if应用：猜拳游戏</h2>
<pre><code class="language-python"># 猜拳游戏
import random

player = input(&quot;请输入：剪刀（0） 石头（1） 布（2）：&quot;)

player = int(player)      # 把输入的字符串转为整型

computer = random.randint(0,2)   # 随机生成一个在0-2之间的数

print(&quot;玩家输入：{}, 电脑输入：{}&quot;.format(player, computer))  # 测试

if (player == 0 and computer == 2) or (player == 1 and computer == 0) or (player == 2 and computer == 1):
    print(&quot;获胜，哈哈，你太厉害了！&quot;)
elif player == computer:
    print(&quot;平局哦，要不要再来一局&quot;)
else:
    print(&quot;你输了，不要走，决战到天亮！&quot;)
</code></pre>
<pre><code>请输入：剪刀（0） 石头（1） 布（2）：2
玩家输入：2, 电脑输入：2
平局哦，要不要再来一局
</code></pre>
<h2 id="5if案例">5.if案例</h2>
<h3 id="51-删除列表元素">5.1 删除列表元素</h3>
<pre><code class="language-python">team = ['法国', '比利时', '英格兰']
if team.count('法国')&gt;0:   # count（）方法用于判断指定元素出现的次数，为0时表示不存在该元素
    team.remove('法国')
print(team)
</code></pre>
<pre><code>['比利时', '英格兰']
</code></pre>
<h1 id="第十四章-循环语句">第十四章 循环语句</h1>
<h2 id="1-程序的三大执行">1. 程序的三大执行</h2>
<ul>
<li>1.顺序执行</li>
<li>2.选择执行
<ul>
<li>if else</li>
</ul>
</li>
<li>3.循环执行</li>
</ul>
<p><img src="https://i.loli.net/2018/12/20/5c1b575edfb50.png" alt="程序的三大执行流程"></p>
<h2 id="2-while循环">2. while循环</h2>
<ul>
<li>格式
<ul>
<li>while 条件：
<ul>
<li>满足条件做的事情</li>
</ul>
</li>
</ul>
</li>
<li>先判断再执行</li>
</ul>
<h3 id="打印1-10之间的数字">打印1-10之间的数字</h3>
<p>（bug）</p>
<pre><code class="language-python"># 打印1-10之间的数字

# print(1)
# print(2)
# ...

# num = 1
# print(num)

# num = num + 1             找出需要重复执行的代码
# print(num)                在上面加上while

# num = num +1
# print(num)

i = 1
while i&lt;=10:
    print(i)
    i = i + 1
    
    
# 这样的程序就叫循环执行
</code></pre>
<pre><code>1
2
3
4
5
6
7
8
9
10
</code></pre>
<p><img src="https://i.loli.net/2018/12/20/5c1b57bd94248.png" alt="while循环"></p>
<pre><code class="language-python"># 打印1-20之间的数
i = 1
while i&lt;=20:
    print(i)
    i = i + 1    # 这句如果忘了写，就会一直打印1，陷入了一个死循环
                 # 这句不写，语法没错，但是逻辑错了
</code></pre>
<pre><code>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code></pre>
<h2 id="3-while嵌套">3. while嵌套</h2>
<ul>
<li>格式
<ul>
<li>while 条件：
<ul>
<li>条件满足时做的事情</li>
<li>...</li>
<li>while 条件2：
<ul>
<li>条件2满足时做的事情</li>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python"># 举例
'''
给个任务：执行下面的动作10次
1.站起来
2.转5个圈
3.坐下
站起来坐下一共执行10次
转圈一共转了50个

用while来写：
while 条件：
    1.站起来
    while 执行5次：
        2.转1个圈
    3.坐下
'''
</code></pre>
<pre><code>'\n给个任务：执行下面的动作10次\n1.站起来\n2.转5个圈\n3.坐下\n站起来坐下一共执行10次\n转圈一共转了50个\n\n用while来写：\nwhile 条件：\n    1.站起来\n    while 执行5次：\n        2.转1个圈\n    3.坐下\n'
</code></pre>
<h3 id="打印一个三角形">打印一个三角形</h3>
<pre><code class="language-python">'''
*
**
***
****
*****

分析：
有五行，每行的东西不一样
既要控制行，又要控制列
做不到？
先做一个简单的
先打印一个类似，再去修改，程序不是一次就写好的
先打印出一个矩形

'''
</code></pre>
<pre><code>'\n*\n**\n***\n****\n*****\n\n分析：\n有五行，每行的东西不一样\n既要控制行，又要控制列\n做不到？\n先做一个简单的\n先打印一个类似，再去修改，程序不是一次就写好的\n先打印出一个矩形\n\n'
</code></pre>
<h3 id="打印矩形">打印矩形</h3>
<pre><code class="language-python"># 打印矩形

# i = 1
# while i&lt;=5:
#     print(&quot;*****&quot;)
#     i = i + 1

# i = 1
# while i&lt;=5:
#     j = 1
#     while j&lt;=5:
#         print(&quot;*&quot;)            # print打印默认换行了，怎么做到不换行？
#         j = j + 1
#     i = i + 1

# i = 1
# while i&lt;=5:
#     j = 1
#     while j&lt;=5:
#         print(&quot;*&quot;, end=&quot;&quot;)       # 加上end=‘’，打印不换行，但是*全在一行里了     
#         j = j + 1
#     i = i + 1

i = 1
while i&lt;=5:
    j = 1
    while j&lt;=5:
        print(&quot;*&quot;, end=&quot;&quot;)           
        j = j + 1
    print('')                      # 等到里边的while结束了，也就是打印了一行5个星号后，换行
    i = i + 1
</code></pre>
<pre><code>*****
*****
*****
*****
*****
</code></pre>
<h3 id="打印三角形">打印三角形</h3>
<pre><code class="language-python"># 打印三角形
i = 1
while i&lt;=5:
    j = 1
    while j&lt;=i:             # 第一行一个，第二行两个...正好与i的值一致，并且i的值不受内循环影响
        print(&quot;*&quot;, end=&quot;&quot;)           
        j = j + 1
    print('')                     
    i = i + 1
</code></pre>
<pre><code>*
**
***
****
*****
</code></pre>
<h3 id="打印九九乘法表">打印九九乘法表</h3>
<pre><code class="language-python"># 打印九九乘法表
# i = 1
# while i&lt;=9:
#     j = 1
#     while j&lt;=i:             
#         print(&quot;X*Y=Z &quot;, end=&quot;&quot;)           # 先把格式换上去
#         j = j + 1
#     print('')                     
#     i = i + 1

i = 1
while i&lt;=9:
    j = 1
    while j&lt;=i:             
        print(&quot;{}*{}={}\t&quot;.format(j,i,j*i), end=&quot;&quot;)      #加上一个\t对齐     
        j = j + 1
    print('')                     
    i = i + 1
</code></pre>
<pre><code>1*1=1	   
1*2=2	2*2=4	
1*3=3	2*3=6	3*3=9	
1*4=4	2*4=8	3*4=12	4*4=16	
1*5=5	2*5=10	3*5=15	4*5=20	5*5=25	
1*6=6	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36	
1*7=7	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49	
1*8=8	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64	
1*9=9	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81	
</code></pre>
<h2 id="4-for循环">4. for循环</h2>
<ul>
<li>格式
<ul>
<li>for 变量 in 序列：
<ul>
<li>执行语句</li>
</ul>
</li>
</ul>
</li>
<li>作用：遍历对象</li>
</ul>
<h3 id="遍历字符串">遍历字符串</h3>
<pre><code class="language-python"># 遍历字符串
name = 'zhangsan'

for i in name:
    print(i)
</code></pre>
<pre><code>z
h
a
n
g
s
a
n
</code></pre>
<h3 id="遍历列表">遍历列表</h3>
<pre><code class="language-python">name = ['zhangsan', 'lisi', 'wangwu']

for i in name:
    print(i)
</code></pre>
<pre><code>zhangsan
lisi
wangwu
</code></pre>
<h3 id="遍历字典">遍历字典</h3>
<pre><code class="language-python"># 遍历字典
stu = {'name':'zhangsan', 'age':18, 'sex':'man'}

# 遍历建和值
for key, value in stu.items():
    print(key, ':', value)
    
print('-'*50)

# 遍历键
for key in stu.keys():
    print('key=', key)

print('-'*50)

# 遍历值
for value in stu.values():
    print('value=', value)
</code></pre>
<pre><code>name : zhangsan
age : 18
sex : man
--------------------------------------------------
key= name
key= age
key= sex
--------------------------------------------------
value= zhangsan
value= 18
value= man
</code></pre>
<h3 id="打印1-10之间的数字-2">打印1-10之间的数字</h3>
<p><mark>range函数</mark></p>
<ul>
<li>开始</li>
<li>结束</li>
<li>步长</li>
<li>负数取值！</li>
</ul>
<pre><code class="language-python"># 打印1-10之间的数字
# i = 1
# while i&lt;=10:
#     print(i)
#     i += 1

# 打印1-10之间的偶数
# i = 1
# while i&lt;=10:
#     if i%2 == 0:
#         print(i)
#     i += 1

for i in range(1,11):
    print(i)
</code></pre>
<pre><code>1
2
3
4
5
6
7
8
9
10
</code></pre>
<h3 id="打印矩形-2">打印矩形</h3>
<pre><code class="language-python"># 打印矩形
for i in range(1,9):
    for j in range(1,9):
        print(&quot;*&quot;, end=&quot;&quot;)
    print(&quot;&quot;)
</code></pre>
<pre><code>********
********
********
********
********
********
********
********
</code></pre>
<h3 id="打印三角形-2">打印三角形</h3>
<pre><code class="language-python"># 打印三角形
for i in range(1,9):
    for j in range(1,i+1):
        print(&quot;*&quot;, end=&quot;&quot;)
    print(&quot;&quot;)
for i in range(1,1):
    print(&quot;开始打印rang1-1&quot;)
    print(i)   #根本就没有值
</code></pre>
<pre><code>*
**
***
****
*****
******
*******
********
</code></pre>
<h3 id="打印九九乘法表-2">打印九九乘法表</h3>
<pre><code class="language-python"># 打印九九乘法表
for i in range(1,10):
    for j in range(1,i+1):
        print(&quot;{}*{}={}&quot;.format(j,i,j*i), end=&quot;\t&quot;)
    print(&quot;&quot;)
  

</code></pre>
<pre><code>1*1=1	
1*2=2	2*2=4	
1*3=3	2*3=6	3*3=9	
1*4=4	2*4=8	3*4=12	4*4=16	
1*5=5	2*5=10	3*5=15	4*5=20	5*5=25	
1*6=6	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36	
1*7=7	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49	
1*8=8	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64	
1*9=9	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81	
</code></pre>
<h3 id="for-if-嵌套">for if 嵌套</h3>
<pre><code class="language-python"># for if 嵌套
# 打印列表里的所有姓名
# 如果是wangwu，就提示，他中奖了
name = [&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;]
for i in name:
    print(i)
    if i == &quot;wangwu&quot;:
        print(&quot;恭喜你中奖了！&quot;)
    else:
        print(&quot;不好意思，你没中奖！&quot;)
    
</code></pre>
<pre><code>zhangsan
不好意思，你没中奖！
lisi
不好意思，你没中奖！
wangwu
恭喜你中奖了！
</code></pre>
<p><mark>注意：if while 同样可以嵌套</mark></p>
<h3 id="for循环的实例">for循环的实例</h3>
<h4 id="for循环获取字符串的长度">for循环获取字符串的长度</h4>
<pre><code class="language-python">s = 'name'  # 定义字符串
num = 0     # 定义长度为0
for i in s:
	num += 1 # 每循环一次，num加1
print(num)
</code></pre>
<pre><code>4
</code></pre>
<h4 id="1-10之间能被3整除并且不能被4整除的数的和">1-10之间能被3整除并且不能被4整除的数的和</h4>
<pre><code class="language-python"># 求1-10之间，能被3整除但不能被4整除的数的和
num = 0
for i in range(1,11):
    if i%3==0 and i%4!=0:
        num += i
print(num)  
</code></pre>
<pre><code>18
</code></pre>
<h4 id="1-10之间的偶数和">1-10之间的偶数和</h4>
<pre><code class="language-python"># for与if嵌套写法
sum = 0
for i in range(1,11):
    if i%2==0:
        sum += i
print(sum)
</code></pre>
<pre><code>30
</code></pre>
<pre><code class="language-python"># range设定步长写法
sum = 0
for i in range(2,11,2):
    sum += i
print(sum)
</code></pre>
<pre><code>30
</code></pre>
<h4 id="for冒泡排序x">for冒泡排序（x）</h4>
<pre><code class="language-python"># 定义一个乱序列表
nums = [3, 1, 6, 2, 4, 5]  #长度6
for i in range(1,len(nums)):    # 外循环i控制次数
    for j in range(len(nums)-i): # 内循环j控制列表索引
        if nums[j] &gt; nums[j+1]:
            nums[j], nums[j+1] = nums[j+1], nums[j]
print(nums)
'''
第一次 i=1,进入内循环，循环次数=6-1=5次
        j=0,nums[0]=3 nums[1]=1,交换位置：[1,3,6,2,4,5]
        j=1,nums[1]=3,nums[6]=6,不交换
        j=2,nums[2]=6,nums[3]=2,如果6&gt;2，交换位置：[1,3,2,6,4,5]
        j=3,nums[3]=6,nums[4]=4,交换：[1,3,2,4,6,5]
        j=4,nums[4]=6,nums[5]=5,交换:[1,3,2,4,5,6]
第二次 i=2,进入内循环，循环次数=6-2=4次
        j=0,nums[0]=1 nums[1]=3,如果0&gt;3就交换位置，不交换
        j=1,nums[1]=3,nums[2]=2,交换位置：[1,2,3,4,5,6]
        j=2,nums[2]=3,nums[3]=4,不交换
        j=3,nums[3]=4,nums[4]=5,不交换   
'''

# i=1,j=0, 6&gt;4, [4,6,5,2,3,1]
# i=1,j=1, 6&gt;5, [4,5,6,2,3,1]
# i=1,j=2, 6&gt;2, [4,5,2,6,3,1]
# i=1,j=3, 6&gt;3, [4,5,2,3,6,1]
# i=1,j=4, 6&gt;1, [4,5,2,3,1,6]

# i=2,j=0, 4&gt;5,不交换
# i=2,j=1,5&gt;2,[4,2,5,3,1,6]
# i=2,j=2,5&gt;3,[4,2,3,5,1,6]    
# i=2,j=3,5&gt;1,[4,2,3,1,5,6]   i=2时，内循环的次数变成了range（6-2），即0-3
</code></pre>
<h4 id="健康食谱输出">健康食谱输出</h4>
<ul>
<li>列出3种食材，输出它们可能组成的所有菜名</li>
</ul>
<pre><code class="language-python">food = ['黄瓜', '火腿', '辣椒']
for i in range(len(food)):
    for j in range(len(food)):
        if i!=j:
            print(&quot;{}{}&quot;.format(food[i], food[j]))
</code></pre>
<pre><code>黄瓜火腿
黄瓜辣椒
火腿黄瓜
火腿辣椒
辣椒黄瓜
辣椒火腿
</code></pre>
<h2 id="5break语句">5.break语句</h2>
<p>break语句可以终止当前循环</p>
<blockquote>
<p>break语句一般会结合if语句使用，表示在某种条件下，跳出循环；</p>
<p>如果使用嵌套循环时，break将跳出最内层循环</p>
</blockquote>
<p>格式：</p>
<pre><code class="language-python">if 条件：
	break
</code></pre>
<h2 id="6continue语句">6.continue语句</h2>
<p>终止本次循环提前进入到下一次循环中</p>
<p>数七游戏：</p>
<p>遇到7的倍数或者以7结尾的数字，就停下拍腿</p>
<pre><code class="language-python">num = []    # 定义一个空列表用来储存7的倍数以及尾数为7的数字
for i in range(1,10):  # 从1数到100，不包括100
    if i % 7 ==0:
        num.append(i)
        continue       # 继续下一次循环
    else:
        string = str(i) # 将数字转成字符串
        if string.endswith('7'):  # 再用endswith判断尾数是否为7
            num.append(i)
            continue
print(num)
</code></pre>
<h1 id="第十五章-函数">第十五章 函数</h1>
<h2 id="1-函数的定义">1. 函数的定义</h2>
<ul>
<li>把具有独立功能的代码块组织成一个小模块</li>
</ul>
<pre><code class="language-python"># 打印一首古诗
print('百日依山尽')
print('黄河入海流')
print('欲穷千里目')
print('更上一层楼')
</code></pre>
<pre><code>百日依山尽
黄河入海流
欲穷千里目
更上一层楼
</code></pre>
<h3 id="想一想">想一想</h3>
<ul>
<li>如果要在很多地方打印这首古诗，是否意味着要编写这段代码多次呢？</li>
</ul>
<pre><code class="language-python">def gu_shi():                 # 函数名推荐小写，使用下划线连接
    print('百日依山尽')
    print('黄河入海流')
    print('欲穷千里目')
    print('更上一层楼')

# 通过函数名来调用
# 如果是“张三”或者“李四”，就打印这首古诗，其他人名不打印

name = input('请输入你的名字：')

if name == 'zhangsan' or name == 'lisi':
    GuShi()                                  #通过函数名调用函数
else:
    print('其他人不用背')
</code></pre>
<pre><code>请输入你的名字：
其他人不用背
</code></pre>
<h2 id="2-函数的文档注释">2. 函数的文档注释</h2>
<ul>
<li>函数的文档注释用一对三双引号包围，用来解释说明函数的作用</li>
</ul>
<pre><code class="language-python">def GuShi():
    '''这个函数用来打印一首古诗'''
    print('百日依山尽')
    print('黄河入海流')
    print('欲穷千里目')
    print('更上一层楼')
    
help(GuShi)
</code></pre>
<pre><code>Help on function GuShi in module __main__:

GuShi()
    这个函数用来打印一首古诗
</code></pre>
<h2 id="3-函数的参数">3. 函数的参数</h2>
<ul>
<li>需求：定义一个函数，用来计算两个数之和</li>
</ul>
<h3 id="31-函数不带参数">3.1 函数不带参数</h3>
<ul>
<li>不带参数只能固定计算函数里定义好的值</li>
</ul>
<pre><code class="language-python"># 定义一个函数用来计算两个数之和
def add2num():
    a = 1
    b = 2
    c = a + b
    print(c)

add2num()
</code></pre>
<pre><code>3
</code></pre>
<h3 id="32-函数的形参和实参">3.2 函数的形参和实参</h3>
<ul>
<li>a,b叫形参（形式参数）：定义函数时的参数</li>
<li>1,2叫实参（实际参数）：实际调用时的参数</li>
<li>在调用函数时，用实参（1,2）替换形参（a,b），再去执行函数里面的代码</li>
</ul>
<pre><code class="language-python"># 由于需要计算的值不固定，所以定义函数时携带两个参数
def add2num(a,b):      # a，b  形式参数
    c = a + b
    print(c)
    
add2num(1,2)           # 1,2  实际参数
</code></pre>
<h3 id="33-函数参数的传递">3.3 函数参数的传递</h3>
<h4 id="331-位置传递">3.3.1 位置传递</h4>
<pre><code class="language-python"># 参数按照位置顺序传入
def add2num(a,b):      # a，b  形式参数
    c = a + b
    print(c)
    
add2num(1,2)           # 1,2  实际参数
</code></pre>
<h4 id="332-关键字传递">3.3.2 关键字传递</h4>
<pre><code class="language-python"># 指定形参的值，位置可以不按照形参顺序
def add2num(a,b):      # a，b  形式参数
    c = a + b
    print(c)
    
add2num(b=1,a=2)           # 1,2  实际参数
</code></pre>
<h4 id="333-函数参数的默认值">3.3.3 函数参数的默认值</h4>
<ul>
<li>函数参数在定义时可以给默认值，如果调用函数时没有传入实参，就使用参数的默认值</li>
<li>注意：拥有默认值的参数一般放在最后一个参数的位置，否则会报错</li>
</ul>
<pre><code class="language-python"># 函数参数的默认值
def add2num(b, a=1):      # a，b  形式参数，注意：拥有默认值的参数a，应该放在参数的最后一个位置
    c = a + b
    print(c)
    
add2num(2)           # 1,2  实际参数
</code></pre>
<pre><code>3
</code></pre>
<h4 id="334-混合传参star">3.3.4 混合传参:star:</h4>
<pre><code class="language-python"># 混合形式传参
# 在函数形参中加入*，表示*号之后的形参必须按照关键字传参方式传递
# *号之前的形参不受此约束
def check(name,*,age,sex):
    print('姓名：{n}，年龄：{a}，性别：{s}'.format(n=name,a=age,s=sex))

check('张三',age='18',sex='男')
</code></pre>
<h3 id="34-函数高阶传参star">3.4 函数高阶传参:star:</h3>
<p>1.序列传参</p>
<ul>
<li>函数的参数可以接受一个序列，比如列表，按照列表中元素的顺序传入参数</li>
</ul>
<pre><code class="language-python"># 函数序列传参
a = [2, 4, 2]
def calc(a,b,c):
    return a + b - c
# 将列表a传入函数参数
# 元素与形参按照位置关系对应
print(calc(*a))  # 注意写法：要加一个*

# 4
</code></pre>
<p>2.字典传参</p>
<pre><code class="language-python"># 字典传参
# 将字典作为函数参数传入
# 形参名与key对应
nums = {'a':2, 'b':2, 'c':4}
def calc(a, b, c):
    return a + b - c
print(calc(**nums))  # 注意：要写2个*

# 0
</code></pre>
<h2 id="4-函数的返回值">4. 函数的返回值</h2>
<ul>
<li>现实生活中的场景：
<ul>
<li>我给儿子10块钱，让他给我买包烟。这个例子中，10块钱是我给儿子的，就相当于调用函数时传递到参数，让儿子买烟这个事情最终的目标是，让他把烟给你带回来然后给你对么，，，此时烟就是返回值</li>
</ul>
</li>
<li>定义
<ul>
<li>程序中函数完成一件事后，最终给调用者的结果</li>
</ul>
</li>
</ul>
<h4 id="return">return</h4>
<ul>
<li>想要在函数中把结果返回给调用者，需要用return</li>
</ul>
<pre><code class="language-python"># 用return返回结果给调用者
def add2num(a,b):
    return a + b

c = add2num(1,2)
print(c)
</code></pre>
<pre><code>3
</code></pre>
<h4 id="函数没有return返回none">函数没有return，返回None</h4>
<pre><code class="language-python">def add2num(a,b):
    c = a + b

result = add2num(1,2)
print(result)
</code></pre>
<pre><code>None
</code></pre>
<h4 id="只要执行了return后续代码将不会执行">只要执行了return，后续代码将不会执行</h4>
<pre><code class="language-python">def add2num(a,b):
    c = a + b
    
    return c
    
    c -= 1
    
    

result = add2num(1,2)
print(result)
</code></pre>
<pre><code>3
</code></pre>
<h2 id="5-局部变量与全局变量">5. 局部变量与全局变量</h2>
<ul>
<li>全局变量：作用于全局（整个文件）</li>
<li>局部变量：作用于局部（函数内）</li>
</ul>
<blockquote>
<p>引用全局变量，不需要golbal声明，修改全局变量，需要使用global声明==</p>
<p>局部变量声明成全局变量以后，需要调用一次才能生效</p>
</blockquote>
<h3 id="全局变量">全局变量</h3>
<pre><code class="language-python">a = 100          # 全局变量定义在函数外，作用于整个文件

def printNum():
    print(a)     # 在函数内也可以调用该变量

printNum()

</code></pre>
<pre><code>100
</code></pre>
<h3 id="局部变量">局部变量</h3>
<pre><code class="language-python">def printNum():
    b = 100       # 局部变量定义在函数内部，只作用于函数内
    print(b)
printNum()
print(b)          # 函数外部无法调用局部变量，错误提示为该变量未定义
</code></pre>
<pre><code>100



---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-10-f03634a92c74&gt; in &lt;module&gt;
      3     print(b)
      4 printNum()
----&gt; 5 print(b)          # 函数外部无法调用局部变量，错误提示为该变量未定义


NameError: name 'b' is not defined
</code></pre>
<h3 id="global">global</h3>
<ul>
<li>使用global可以声明变量为全局变量</li>
</ul>
<pre><code class="language-python">def printNum():
    global b      # 使用global声明变量为全局变量
    b = 100       # 局部变量定义在函数内部，只作用于函数内
    print(b)
printNum()
print(b)          # 函数外部无法调用局部变量，错误提示为该变量未定义
</code></pre>
<pre><code>100
100
</code></pre>
<h2 id="6-匿名函数">6. 匿名函数</h2>
<pre><code class="language-python"># 匿名函数
# filter 过滤 后面接布尔值
# lambda 匿名函数
# 根据传入的列表生成一个奇数列表
def use_filter(l):
    rest = filter(lambda n: n % 2 !=0, l)
    return rest

l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
rest = use_filter(l)
print(list(rest))
</code></pre>
<h1 id="第十六章-文件操作">第十六章 文件操作</h1>
<h2 id="1-打开文件">1. 打开文件</h2>
<ul>
<li>opne(文件名，访问模式)</li>
</ul>
<pre><code class="language-python">f = open('test.txt', 'w')
</code></pre>
<h3 id="访问模式说明">访问模式说明</h3>
<ul>
<li>r：只读，要求被读文件必须存在</li>
<li>w：写入，如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件</li>
<li>a：追加，追加内容到文件结尾。如果该文件不存在，创建新文件进行写入</li>
<li>w+：打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件（x）</li>
</ul>
<h2 id="2-关闭文件">2. 关闭文件</h2>
<pre><code class="language-python"># 新建一个文件，文件名为test.tct
f = open('test.txt', 'w')

# 关闭这个文件
f.close()
</code></pre>
<h4 id="判断文件是否关闭">判断文件是否关闭</h4>
<ul>
<li>返回布尔值</li>
</ul>
<pre><code class="language-python">f.closed
</code></pre>
<pre><code>True
</code></pre>
<h3 id="文件的自动打开与关闭">文件的自动打开与关闭</h3>
<ul>
<li>使用with open打开文件，python会自动帮我们关闭文件</li>
</ul>
<pre><code class="language-python">with open('test.txt', 'r') as f:
    print(f.read())

print(f.closed)    # 查看文件是否关闭
</code></pre>
<pre><code>True
</code></pre>
<h2 id="3-文件的读写">3. 文件的读写</h2>
<h3 id="写数据write">写数据（write）</h3>
<ul>
<li>f.write('需要写入的内容')</li>
<li>write模式不能对文件进行读取操作</li>
<li>write模式，文件不存在时则自动新建文件</li>
</ul>
<pre><code class="language-python">f = open('test.txt', 'w')
f.write('hello world\n你好，中国！')
f.close()
</code></pre>
<h3 id="读数据read">读数据（read）</h3>
<ul>
<li>f.read()：读取文件内所有内容</li>
<li>f.read(n)：读取前n个内容</li>
<li>多次使用read则依次向后读取（不是从文件开头从新读取）</li>
</ul>
<pre><code class="language-python">f = open('test.txt', 'r')
content = f.read(5)     # 读取前5个内容
print(content)

# 使用read读取多次，那么后面读取数据是从上次读完后的位置开始的
content = f.read()
print(content)

f.close()

</code></pre>
<p>​</p>
<h3 id="读数据readlines">读数据（readlines）</h3>
<ul>
<li>按行读取文件所有数据</li>
<li>返回列表</li>
<li>搭配for循环使用</li>
</ul>
<pre><code class="language-python">with open('2.txt', 'w+') as f:
    f.write('nihao\nChina')

f = open('2.txt', 'r')

# content = f.readlines()   #  按行读取文件所有内容，返回列表
# print(content)
# print(type(content))      # 查看返回数据类型

for line in f.readlines():
    print(line)

</code></pre>
<pre><code>nihao

China
</code></pre>
<h3 id="读数据readline">读数据（readline）</h3>
<ul>
<li>按行读取，每次只读取一行</li>
<li>返回字符串类型</li>
<li>只有在内存不足时才使用此方法</li>
</ul>
<pre><code class="language-python">with open('1.txt', 'w+') as f:
    f.write('nihao\nChina')

f = open('1.txt', 'r')

content = f.readline()    # 第一次读取第一行
content2 = f.readline()   # 第二次读取第二行

print(content)
print(content2)
print(type(content))      # 返回数据类型为：字符串

</code></pre>
<pre><code>nihao

China
&lt;class 'str'&gt;
</code></pre>
<h3 id="读取中文问题">读取中文问题</h3>
<ul>
<li>如果读写文件中包含中文出现乱码问题</li>
<li>打开文件时加上编码格式，可以避免此问题</li>
</ul>
<pre><code class="language-python"># 读取文件加上编码

f = open('test.txt', 'r', encoding='utf-8')

content = f.readline()

print(content)

</code></pre>
<pre><code>hello world
</code></pre>
<h3 id="按行读取去掉n">按行读取去掉\n</h3>
<p>第一种方法</p>
<pre><code class="language-python">with open('test.txt', 'r', encoding='utf-8') as f:
    t = f.read().splitlines()
    print(t)
    
# ['hello', 'world', '你好', '世界']   返回列表
</code></pre>
<p>第二种方法</p>
<pre><code class="language-python">with open('test.txt', 'r', encoding='utf-8') as f:
    t = f.readlines()
    t2 = ''.join(t).strip('\n')  # 将列表转成字符串，再用strip方法去掉\n
    print(t2)
    
a = []
with open('123.txt', 'r') as f:
    for i in f.readlines():
        i = i.strip('\n')
        a.append(i)
print(a)
</code></pre>
<h3 id="关于使用w模式在文件没有保存之前读取的问题">关于使用w+模式在文件没有保存之前读取的问题</h3>
<p>往文件写入内容时，文件在没有关闭之前都是储存在缓存中，等文件关闭以后才储存至硬盘</p>
<p>在文件没有关闭之前就去读取文件，需要使用seek将指针强制定位至文件开头，才能读取（不建议）</p>
<pre><code class="language-python">with open('123.txt', 'w+') as f:
    f.write('abc1234')
    # f.flush()         # 如果文件还在缓存，需要使用flush移至硬盘 
    #print(f.tell())     # 检查当前指针的位置
    f.seek(0)           # 指针移至文件开头
    print(f.read())

</code></pre>
<pre><code>abc1234
</code></pre>
<p>读写尽量保持分开！</p>
<h2 id="4-应用制作文件的备份">4. 应用：制作文件的备份</h2>
<p>任务描述：</p>
<ul>
<li>输入文件的名字，然后程序自动完成对文件的备份</li>
<li>备份文件名格式为：原文件名[复件].xx</li>
</ul>
<pre><code class="language-python"># 文件备份
# 步骤分析
# 1.获取需要备份的文件名
# 2.提取原文件名的后缀
# 3.组建新的文件名
# 4.循环写入原文件内容
# 5.关闭文件
oldFileName = input('请输入要拷贝的文件名：') # 获取需要拷贝的文件名

oldFile = open(oldFileName, 'r', encoding='utf-8')   # 把需要拷贝的文件用只读模式打开

fileFlagNum = oldFileName.rfind('.')  # 获取.在文件名中最后一次出现的位置（从右向左查询）
if fileFlagNum&gt;0:                     # 判断，必须大于0
    fileFlag = oldFileName[fileFlagNum:]   # .xxx

newFileName = oldFileName[:fileFlagNum] + 'fujian' + fileFlag

newFile = open(newFileName, 'w', encoding='utf-8')

for line in oldFile.readlines():
    newFile.write(line)

oldFile.close()
newFile.close()

</code></pre>
<pre><code>请输入要拷贝的文件名：1.txt
</code></pre>
<h1 id="第十七章-异常">第十七章 异常</h1>
<h2 id="1-捕获异常">1. 捕获异常</h2>
<ul>
<li>当代码出现异常时，会抛出异常并停止执行。如果希望<code>出现异常后还继续执行</code>剩下的代码就必须捕捉异常</li>
<li>格式
<ul>
<li>
<pre><code>try:
  可能出现异常的代码……
except Exception as e:
  捕捉异常后执行的代码（e代表错误原因）
else:
  没有异常则执行else语句
finally:
  无论是否异常都会执行finally语句 '''
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="代码出现异常后会停止运行">代码出现异常后，会停止运行</h4>
<pre><code class="language-python"># 不存在123.txt这个文件，打开报文件不存在错误
print(&quot;这是第一行内容&quot;)
open('123.txt', 'r')
print('这是第二行内容')
</code></pre>
<pre><code>这是第一行内容



---------------------------------------------------------------------------

FileNotFoundError                         Traceback (most recent call last)

&lt;ipython-input-1-5652eb775fe8&gt; in &lt;module&gt;
      1 # 不存在123.txt这个文件，打开报文件不存在错误
      2 print(&quot;这是第一行内容&quot;)
----&gt; 3 open('123.txt', 'r')
      4 print('这是第二行内容')


FileNotFoundError: [Errno 2] No such file or directory: '123.txt'
</code></pre>
<h4 id="把异常抛出后代码会忽略这个问题继续往下执行">把异常抛出后，代码会忽略这个问题，继续往下执行</h4>
<pre><code class="language-python">print(&quot;这是第一行内容&quot;)
try:
    open('123.txt', 'r')
except FileNotFoundError as e:          # 使用try...except 获取FileNotFoundError错误
    print('异常的信息是：{}！'.format(e))
print('这是第二行内容')
</code></pre>
<pre><code>这是第一行内容
异常的信息是：[Errno 2] No such file or directory: '123.txt'！
这是第二行内容
</code></pre>
<h4 id="为什么要捕获异常">为什么要捕获异常？</h4>
<ul>
<li>程序可能会出现异常，如果想要继续执行下去，就把异常捕获，然后继续执行</li>
<li>并且，try是捕获可能出现的异常，如果必定出现异常那还捕获啥，直接把代码修正就好了</li>
</ul>
<h2 id="2-抛出异常">2. 抛出异常</h2>
<ul>
<li>当希望代码在指定情况下出现异常，则需要主动抛出异常</li>
<li>格式：
<ul>
<li>raise Exception(提示信息)</li>
</ul>
</li>
</ul>
<pre><code class="language-python">num = int(input(&quot;请输入一个整数：&quot;))

if num&gt;100:
    raise Exception(&quot;请输入小于100的整数！&quot;)
print(num)
</code></pre>
<pre><code>请输入一个整数：101



---------------------------------------------------------------------------

Exception                                 Traceback (most recent call last)

&lt;ipython-input-39-44fc1c5b161e&gt; in &lt;module&gt;
      2 
      3 if num&gt;100:
----&gt; 4     raise Exception(&quot;请输入小于100的整数！&quot;)
      5 print(num)


Exception: 请输入小于100的整数！
</code></pre>
<h1 id="第十八章-python的模块">第十八章 Python的模块</h1>
<h2 id="1-什么是模块">1. 什么是模块</h2>
<ul>
<li>模块就好比是工具包，要想使用这个工具包中的工具(就好比函数)，就需要导入这个模块</li>
</ul>
<h2 id="2-导入模块的三种方法">2. 导入模块的三种方法</h2>
<ul>
<li>import</li>
<li>from 模块名 import 函数</li>
<li>form 模块名 import *</li>
</ul>
<h3 id="import">import</h3>
<pre><code class="language-python"># 导入os模块
import os

print('当前的文件路径是;')
print(os.mkdir())
</code></pre>
<pre><code>当前的文件路径是;
/home/nbuser/library/__file__
</code></pre>
<h3 id="from-模块名-import-函数">from 模块名 import 函数</h3>
<pre><code class="language-python"># 从时间模块中导入休眠函数

from time import sleep
</code></pre>
<h3 id="from-模块名-import">from 模块名 import *</h3>
<pre><code class="language-python"># 导入时间模块

from time import *
</code></pre>
<h2 id="3-常用模块">3. 常用模块</h2>
<h3 id="31-time时间">3.1 time（时间）</h3>
<pre><code class="language-python">import time

# 获取当前时间：ctime（）
print('当前时间是：{}'.format(time.ctime()))

# 获取当前时间，返回浮点数：time（）
print('当前时间是(浮点数)：{}'.format(time.time()))

# 代码暂停n秒：sleep（n）
sleep(2)

# 格式化输出时间
currentTime = time.strftime('%Y-%m-%d %H:%M:%S')
print(currentTime)
</code></pre>
<pre><code>当前时间是：Tue Dec 18 07:45:27 2018
当前时间是(浮点数)：1545119127.5678759
2018-12-18 07:45:29
</code></pre>
<h3 id="32-os操作系统相关">3.2 OS（操作系统相关）</h3>
<pre><code class="language-python">import os

# 获取当前文件所在目录
print(os.getcwd())

# 获取当前文件所在的路径
print(os.path.abspath(__file__))
print(os.path.realpath(__file__))

# 创建/删除目录
os.mkdir('selenium')
os.rmdir('selenium')

# 删除文件
os.remove('文件名')
</code></pre>
<h3 id="33-random随机数">3.3 random（随机数）</h3>
<pre><code class="language-python">import random

num = random.randint(1, 10)   # 生成一个1-10之间的随机整数
print('生成的随机整数是：', num)

num2 = random.random()          # 随机生成一个0-1之间浮点数
print('生成的随机浮点数是：', num2)

num3 = random.uniform(1,10)         # 随机生成一个1-10之间的浮点数
print(num3)
</code></pre>
<h2 id="4-给模块临时添加环境变量">4. 给模块临时添加环境变量</h2>
<p>在python中导包时的查找顺序为：当前目录，内置标准库，环境变量</p>
<p>临时添加环境变量的方法</p>
<pre><code class="language-python">import sys

# 由于sys.path返回一个列表，所以可以直接通过append方法进行添加
sys.path.append(路径)
</code></pre>
<h1 id="第十九章-面向对象">第十九章 面向对象</h1>
<h2 id="1面向过程与面向对象的关系">1.面向过程与面向对象的关系</h2>
<ul>
<li>
<p>定义</p>
<ul>
<li>面向过程：根据业务逻辑从上到下写代码</li>
<li>面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程</li>
</ul>
</li>
<li>
<p>菜鸟买电脑</p>
<ul>
<li>
<p>第一种方式:</p>
<blockquote>
<p>1)在网上查找资料</p>
<p>2)根据自己预算和需求定电脑的型号 MacBook 15 顶配 1W8</p>
<p>3)去市场找到苹果店各种店无法甄别真假 随便找了一家</p>
<p>4)找到业务员,业务员推荐了另外一款 配置更高价格便宜,也是苹果系统的 1W</p>
<p>5)砍价30分钟 付款9999</p>
<p>6)成交</p>
<p>回去之后发现各种问题</p>
</blockquote>
<p>第二种方式 :</p>
<blockquote>
<p>1)找一个靠谱的电脑高手</p>
<p>2)给钱交易</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>吃啤酒鸭</p>
<ul>
<li>
<p>第一种方式（面向过程）:</p>
<blockquote>
<p>1)养鸭子</p>
<p>2)鸭子长成</p>
<p>3)杀</p>
<p>4)作料</p>
<p>5)烹饪</p>
<p>6)吃</p>
<p>7)卒</p>
</blockquote>
<p>第二种方式（面向对象）:</p>
<blockquote>
<p>1)找个卖啤酒鸭的人</p>
<p>2)给钱 交易</p>
<p>3)吃</p>
<p>4)胖6斤</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="2-类和对象">2. 类和对象</h2>
<ul>
<li>对象需要类才能创造出来</li>
<li>类和对象的区分</li>
</ul>
<pre><code>奔驰汽车 类
奔驰smart 类 
张三的那辆奔驰smart 对象
狗 类
大黄狗 类 
李四家那只大黄狗 对象 
水果 类
苹果 类 
红苹果 类 红富士苹果 类 
我嘴里吃了一半的苹果 对象
</code></pre>
<h3 id="21-类的构成">2.1 类的构成</h3>
<p>类(Class) 由3个部分构成</p>
<ul>
<li>类的名称:类名</li>
<li>类的属性:一组数据</li>
<li>类的方法:允许对象进行操作的方法 (行为)</li>
</ul>
<p>举例：</p>
<p>​	狗类的设计</p>
<ul>
<li>类名:狗(Dog)</li>
<li>属性:品种 、毛色、性别、名字、 腿儿的数量</li>
<li>方法(行为/功能):叫 、跑、咬人、吃、摇尾巴</li>
</ul>
<h3 id="22-定义类">2.2 定义类</h3>
<p>格式：</p>
<pre><code class="language-python">class 类名:
	# 属性
    
    # 方法
</code></pre>
<p>举例：</p>
<pre><code class="language-python">class Cat:               # 类名使用大驼峰
    # 属性
    
    def eat(self):       # 函数在类里面叫方法
        print('猫正在吃东西...')
        
    def drink(self):
        print('猫正在喝水...')
</code></pre>
<h3 id="23-类的实例化">2.3 类的实例化</h3>
<p>类的实例化就是指根据类创建对象，类一旦创建好以后，可以创建多个对象</p>
<p>每个对象都具有类里面定义好的功能</p>
<pre><code class="language-python">class Cat:               # 类名使用大驼峰
    # 属性
    
    def eat(self):       # 函数在类里面叫方法
        print('猫正在吃东西...')
        
    def drink(self):
        print('猫正在喝水...')
        

tom = Cat()			# 创建对象

tom.eat()			# 调用对象中的方法
tom.drink()			# 调用对象中的方法

</code></pre>
<p><img src="https://i.loli.net/2019/01/18/5c41a7355c796.png" alt=""></p>
<h3 id="24-类的初始化">2.4 类的初始化</h3>
<p>类的初始化使用：<code>__init__</code>方法（双下划线）</p>
<p>python会自动调用init方法</p>
<pre><code class="language-python">class Cat():  # 类名使用大驼峰
    # 属性
    def __init__(self,color,weight):      # 类的初始化，python会自动调用init方法
        self.color = color                # 将属性绑定到self，这样其他方法也可以访问该属性
        self.weight = weight
        print('初始化完毕')

    def eat(self, food):  # 函数在类里面叫方法
        print('%s的猫正在吃%s...' %(self.color,food))

    def drink(self, water):
        print('{}的猫正在喝{}...'.format(self.color, water) )


tom = Cat('黄色',10)  # 创建对象（实例化），必须传入初始化里的参数

tom.eat('猫粮')  # 调用对象中的方法
tom.drink('水')  # 调用对象中的方法

# 没有调用init方法，但是init方法也会自动执行
# 方法里面必须加上一个默认参数self，slef代表调用类的实例
</code></pre>
<pre><code>初始化完毕
黄色的猫正在吃猫粮...
黄色的猫正在喝水...
</code></pre>
<h3 id="25-类的继承">2.5 类的继承</h3>
<ul>
<li>若某个类是属于另外一个类的小类，则可以继承这个大类</li>
<li>子类可以增加父类没有的方法，也可以改写父类方法（子类添加属性也是OK的）</li>
</ul>
<pre><code class="language-python">class Dog():
    # 属性
    def __init__(self, color, weight):  # 初始化函数在实例化时一定会自动执行
        self.color = color             # 将属性通过self绑定，整个类里边的方法都可以使用该属性
        self.weight = weight
        self.legs = 4
    # 方法
    def run(self):
        print('%s的狗正在跑~' %self.color)

    def eat(self):
        print('狗正在吃东西~')

    def dog_leg(self):
        print('狗有%d条腿'%self.legs)

# wang_cai = Dog('黄色', 10)   # 实例化（创建对象）
# wang_cai.run()

class LittleDog(Dog):
    def swim(self):
        print('%s的狗正在游泳' %self.color)     # 子类增加父类没有的方法
    def run(self):
        print('%s的狗跑的真快' %self.color)   # 子类对父类方法的改写

xiao_qiang = LittleDog('黑色', 5)   # 实例化
xiao_qiang.run()     # 子类可以使用父类已有的方法
xiao_qiang.swim()
xiao_qiang.legs = 5  # 子类修改父类已有的属性值
xiao_qiang.dog_leg()
</code></pre>
<pre><code>黑色的狗跑的真快
黑色的狗正在游泳
狗有5条腿
</code></pre>
<h1 id="第二十章-练习题">第二十章  练习题</h1>
<p>1.实现用户输入用户名和密码，当用户名为 seven或alex且 密码为123时，显示登陆成功，否则登陆失败，失败时允许重复输入三次</p>
<pre><code class="language-python">num = 1
while True:
    username = input('username:')
    password = int(input('password:'))
    if username=='seven' and password==123:
        print('login sucess')
        break
    else:
        print('login fail')
        num+=1
        if num==4:
            print('超过3次')
            exit()
            
num = 1
while num&lt;4:
    username = input('username:')
    password = int(input('password:'))
    if username=='seven' and password==123:
        print('login sucess')
        break
    else:
        print('login fail')
        num+=1
        if num==4:
            print('超过3次')
</code></pre>
<p>2.计算2-3+4-5.....+100的值</p>
<pre><code class="language-python">sum = 0
for i in range(2,101):
    if i%2==0:
        sum+=i
    else:
        sum-=i
print(sum)
</code></pre>
<p>3.生成一个100以内所有奇数的列表</p>
<pre><code class="language-python">num = []
for i in range(1,101,2):
    num.append(i)
print(num)
</code></pre>
<p>4.请将<code>['中国', '广东', '深圳']</code>用中横线拼接成一个字符串</p>
<pre><code class="language-python">li = ['中国', '广东', '深圳']
str = '-'.join(li)
print(str)
</code></pre>
<p>5.一行代码实现1-100之间的和</p>
<pre><code class="language-python">print(sum(range(1,3)))
</code></pre>
<p>6.列表去重（使用集合）</p>
<pre><code class="language-python">a = [1, 3, 3, 4, 5]
b =set(a)   # 使用集合去重
a = list(b)  # 集合转列表
print(a)
</code></pre>
<p>7.<code>s = &quot;ajldjlajfdljfddd&quot;</code>，去重并从小到大排序输出<code>&quot;adfjl&quot;</code></p>
<pre><code class="language-python">s = &quot;ajldjlajfdljfddd&quot;
s = set(s)        # 使用set去重
s = list(s)       # 转成列表以便排序
s.sort()          # 使用sort排序
s = ''.join(s)    # 拼接成字符串
print(s)
</code></pre>
<pre><code>adfjl
</code></pre>
<p>8.用lambda函数实现两数相乘</p>
<pre><code class="language-python">sum = lambda a,b:a*b  
print(sum(2,2))
</code></pre>
<p><img src="https://i.loli.net/2019/04/19/5cb8a630c5b27.png" alt=""></p>
<pre><code>4
</code></pre>
<p>9.字典根据键从小到大排序dict={&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:18,&quot;city&quot;:&quot;深圳&quot;,&quot;tel&quot;:&quot;1362626627&quot;}</p>
<pre><code class="language-python">dict = {&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:18,&quot;city&quot;:&quot;深圳&quot;,&quot;tel&quot;:&quot;1362626627&quot;}

# dict.items()以元祖形式返回字典的键值对
# i[0]表示键，i[1]表示值
# 通过lambda函数根据键进行排序
list = sorted(dict.items(), key=lambda i:i[0])
print(list)
new_dict = {}
for i in list:
    new_dict[i[0]] = i[1]
print(new_dict)
</code></pre>
<pre><code>[('age', 18), ('city', '深圳'), ('name', 'zs'), ('tel', '1362626627')]
</code></pre>
<p>10.计算一个字符串中每个字母出现的次数，‘<strong>kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h</strong>’</p>
<pre><code class="language-python">from collections import Counter

a = 'kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h'
co = Counter(a)
print(co)
</code></pre>
<pre><code>Counter({'l': 9, ';': 6, 'h': 6, 'f': 5, 'a': 4, 'j': 3, 'd': 3, 's': 2, 'k': 1, 'g': 1, 'b': 1})
</code></pre>
<p>11.字符串a = &quot;not 404 found 张三 99 深圳&quot;，每个词中间是空格，用正则过滤掉英文和数字，最终输出&quot;张三  深圳&quot;</p>
<pre><code class="language-python">import re

a = 'not 404 found 张三 99 深圳'
list = a.split(' ')  # 使用空格分隔字符串，返回列表
print(list)

# 正则匹配
# \d：匹配数字
# +|：连接多个匹配方式
# [a-zA-Z]+：匹配所有单词
res = re.findall('\d+|[a-zA-Z]+', a)
print(res)
for i in res:
    if i in list:
        list.remove(i)
new_str = ''.join(list)
print(new_str)
</code></pre>
<pre><code>['not', '404', 'found', '张三', '99', '深圳']
['not', '404', 'found', '99']
张三深圳
</code></pre>
<p>12.列表推导式求列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<pre><code class="language-python">a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

res = [i for i in a if i%2==1]
print(res)
</code></pre>
<pre><code>[1, 3, 5, 7, 9]
</code></pre>
<p>13.求出1-100之间所有的素数</p>
<pre><code class="language-python">nums = []
# i = 2
for i in range(2,101):
    # j = 2
    for j in range(2,i):
        if i%j==0:
            break
    else:
        nums.append(i)
print(nums)
</code></pre>
<pre><code>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
</code></pre>
<p>14.设计一个程序，统计任意字符串中数字以及字母的个数</p>
<pre><code class="language-python">def countStr(string):
    nums = 0
    letters = 0
    for i in string:
        if i in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
            letters+=1
        elif i in '0123456789':
            nums+=1
    print('字母有%d个，数字有%d个' %(letters, nums))
    return nums, letters

countStr('126676767abd')
</code></pre>
<pre><code>字母有3个，数字有9个
</code></pre>
<p>15.怎么将<code>a = [1,2,3,4,5,6]</code>变成<code>‘123456’</code></p>
<blockquote>
<p>注意：这道题目有个坑，就是列表里面不是字符串是数字，所以不能直接用join</p>
</blockquote>
<pre><code>a = [1,2,3,4,5,6]
s = ''
for i in a:
    s = s + str(i)
print(s)
</code></pre>
<p>16.生成一个包含1-10之间的斐波那契数列列表</p>
<p><img src="https://i.loli.net/2019/05/26/5cea914ea83ed43036.png" alt=""></p>
<h1 id="第二十一章-知识拓展">第二十一章  知识拓展</h1>
<h2 id="1随机生成多个qq邮箱">1.随机生成多个QQ邮箱</h2>
<pre><code class="language-python">import random

for i in range(5):      # 循环次数决定生成个数
    user_email = ''.join(random.sample('123456789',9))+ '@qq.com'
    print(user_email)
# 使用random.sample生成字符列表，第一个参数表示将会出现的字符，第二个参数表示位数
# 使用join方法将列表转为字符串
# 使用字符串拼接合成邮箱格式
</code></pre>
<pre><code>128637459@qq.com
452913678@qq.com
451369827@qq.com
268794531@qq.com
764951832@qq.com
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SVN版本控制系统使用技巧]]></title>
        <id>https://yihangliak.github.io/post/svn01</id>
        <link href="https://yihangliak.github.io/post/svn01">
        </link>
        <updated>2019-06-20T15:22:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="svn简介">SVN简介</h1>
<p><code>Subversion</code>是一个开源的版本控制系统</p>
<ul>
<li>所有数据存放在一个中央资料档案库中</li>
<li>可以记住每一次文件的变动</li>
<li>可以恢复到旧版本档案</li>
<li>可以浏览文件的变动历史</li>
</ul>
]]></content>
    </entry>
</feed>