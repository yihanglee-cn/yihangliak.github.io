<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yihangliak.github.io</id>
    <title>一杭的博客</title>
    <updated>2019-09-10T06:50:34.354Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yihangliak.github.io"/>
    <link rel="self" href="https://yihangliak.github.io/atom.xml"/>
    <subtitle>你好  靓仔   :D</subtitle>
    <logo>https://yihangliak.github.io/images/avatar.png</logo>
    <icon>https://yihangliak.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 一杭的博客</rights>
    <entry>
        <title type="html"><![CDATA[实用工具大搜罗]]></title>
        <id>https://yihangliak.github.io/post/UQ96yPt5M</id>
        <link href="https://yihangliak.github.io/post/UQ96yPt5M">
        </link>
        <updated>2019-09-10T06:30:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="文字编辑">文字编辑</h1>
<ul>
<li>思维脑图
<ul>
<li>幕布：<a href="https://mubu.com/">https://mubu.com</a></li>
<li>xmind
<ul>
<li>xmind ZEN：<a href="http://dl2.xmind.cn/XMind-ZEN-Update-2019-for-Windows-64bit-9.2.0-201904271935.exe">http://dl2.xmind.cn/XMind-ZEN-Update-2019-for-Windows-64bit-9.2.0-201904271935.exe</a></li>
<li>破解补丁：<a href="https://carrot.ctfile.com/dir/11269771-31680249-fdf2c2/">https://carrot.ctfile.com/dir/11269771-31680249-fdf2c2/</a></li>
</ul>
</li>
</ul>
</li>
<li>Markdown编辑器
<ul>
<li>Typora：<a href="https://www.typora.io/">https://www.typora.io/</a></li>
</ul>
</li>
<li>万能编辑器
<ul>
<li>notepad ++</li>
</ul>
</li>
<li>文档，表格，幻灯片
<ul>
<li>WPS（政企专版，无广告）：<a href="http://wpspro.support.wps.cn/gov/heilongjiang/daqing/installation/WPS_Office_2019_%E5%A4%A7%E5%BA%86%E5%B8%82%E5%85%9A%E6%94%BF%E6%9C%BA%E5%85%B3%E4%B8%93%E7%94%A8%E7%89%88.exe">http://wpspro.support.wps.cn/gov/heilongjiang/daqing/installation/WPS_Office_2019_大庆市党政机关专用版.exe</a></li>
</ul>
</li>
</ul>
<h1 id="开发工具">开发工具</h1>
<ul>
<li>图形化Git工具
<ul>
<li>sourcetree：<a href="https://www.sourcetreeapp.com/">https://www.sourcetreeapp.com/</a></li>
</ul>
</li>
<li>python编辑器
<ul>
<li>pycharm：<a href="http://www.jetbrains.com/pycharm/">http://www.jetbrains.com/pycharm/</a></li>
</ul>
</li>
<li>MySQL连接软件
<ul>
<li>Navicat for mysql 绿色版：<a href="https://www.cr173.com/soft/38153.html">https://www.cr173.com/soft/38153.html</a></li>
</ul>
</li>
<li>Java8
<ul>
<li>JDK下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li>
</ul>
</li>
<li></li>
</ul>
<h1 id="生活类">生活类</h1>
<ul>
<li>护眼
<ul>
<li>护眼宝：<a href="http://www.huyanapp.com/portal.php">http://www.huyanapp.com/portal.php</a></li>
</ul>
</li>
</ul>
<h1 id="图片处理类">图片处理类</h1>
<ul>
<li>截图工具
<ul>
<li>Snipaste：<a href="https://www.snipaste.com/">https://www.snipaste.com/</a></li>
</ul>
</li>
<li>免费图床
<ul>
<li>smpic：<a href="https://github.com/kookob/smpic">https://github.com/kookob/smpic</a></li>
<li>聚合图床：<a href="https://www.superbed.cn/">https://www.superbed.cn/</a></li>
</ul>
</li>
<li>Gif录制
<ul>
<li>GifCam：<a href="https://gifcam.en.softonic.com/">https://gifcam.en.softonic.com/</a></li>
</ul>
</li>
</ul>
<h1 id="系统美化类">系统美化类</h1>
<ul>
<li>任务栏全透明
<ul>
<li>TranslucentTB：<a href="https://translucenttb.en.softonic.com/">https://translucenttb.en.softonic.com/</a></li>
</ul>
</li>
<li>Windows字体优化
<ul>
<li>Mactype：<a href="https://www.mactype.net/">https://www.mactype.net/</a></li>
</ul>
</li>
</ul>
<h1 id="效率类">效率类</h1>
<ul>
<li>待办事项管理
<ul>
<li>MicrosoftToDo：<a href="https://todo.microsoft.com/">https://todo.microsoft.com/</a></li>
</ul>
</li>
<li>本地文件搜索工具（一秒找到文件）
<ul>
<li>everything：<a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></li>
</ul>
</li>
<li>百度云不限速下载
<ul>
<li>speedpan：<a href="https://www.speedpan.com/">https://www.speedpan.com/</a></li>
</ul>
</li>
</ul>
<h1 id="手机助手类">手机助手类</h1>
<ul>
<li>iPhone助手
<ul>
<li>爱思助手</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dcoker 安装MySQL]]></title>
        <id>https://yihangliak.github.io/post/SuD1zwuyw</id>
        <link href="https://yihangliak.github.io/post/SuD1zwuyw">
        </link>
        <updated>2019-08-30T08:40:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="dcoker-安装mysql">Dcoker 安装MySQL</h1>
<h2 id="前言">前言</h2>
<blockquote>
<p>什么是Docker？</p>
</blockquote>
<p>Docker是一个开源的应用容器引擎，可以将应用程序打包成镜像，然后发布到任何的Linux机器上，也可以实现虚拟化</p>
<p>简单来说，Docker就好比是虚拟机，虚拟机可以模拟出电脑硬件，并且可以很方便的克隆，但是虚拟机的缺点也非常明显，它会占用宿主机非常多的硬件资源，而且启动速度也非常慢。而Linux在此基础之上发展出了一种新的容器技术，容器与宿主机共用硬件资源，启动速度也非常快，这个容器就是Docker。</p>
<h2 id="1-安装docker">1. 安装Docker</h2>
<p>Docker的安装十分简单，在Linux系统中，使用<code>yum</code>安装即可（需联网）</p>
<pre><code>yum -r install docker
# -r表示后续所有的需要确认的步骤都默认选择“是”
</code></pre>
<h2 id="2启动docker">2.启动Docker</h2>
<pre><code>service docker start
</code></pre>
<h2 id="3镜像-容器-仓库">3.镜像 容器 仓库</h2>
<p>Docker中有仓库，镜像，容器这个三个比较重要的概念。</p>
<ul>
<li>仓库类似代码仓库，集中存放镜像的场所</li>
<li>镜像类似虚拟机的镜像</li>
<li>容器则是从镜像创建的一个运行实例</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/H508f8c2700f043c79194c1ef521c17fao.jpg" alt=""></p>
<h2 id="4拉取镜像">4.拉取镜像</h2>
<p>拉取MySQL镜像，版本选择5.7</p>
<pre><code>docker pull mysql:5.7
</code></pre>
<h2 id="5查看镜像">5.查看镜像</h2>
<p>验证刚刚拉取的镜像是否成功</p>
<pre><code>docker images
</code></pre>
<p><img src="https://ae01.alicdn.com/kf/Hb52cbf8cac344605b2c688b9bff42b73t.jpg" alt=""></p>
<h2 id="6创建mysql目录">6.创建MySQL目录</h2>
<p>创建MySQL的储存目录，用来存放数据库数据</p>
<p><code>mkdir -p</code>可以递归创建目录</p>
<pre><code>mkdir -p /usr/local/mysql/conf /usr/local/mysql/data /usr/local/mysql/logs
</code></pre>
<h2 id="7运行容器">7.运行容器</h2>
<pre><code class="language-shell">docker run -p 3309:3306 --name firstmysql -v /usr/local/mysql/conf:/etc/mysql/conf.d -v /usr/local/mysql/logs:/logs -v /usr/local/mysql/data:/var/lib/mysql -e mysql_root_password=123456 -d mysql:5.7
</code></pre>
<p>命令说明：</p>
<ul>
<li><code>--name</code>：容器命名为firstmysql</li>
<li><code>-p 3309:3306</code>：将容器的3309端口映射到宿主机的3306</li>
<li><code>-v</code>：将容器的某个目录挂载到主机的目录</li>
<li><code>-e mysql_root_password=123456</code>：初始化数据库root用户的密码为123456</li>
<li><code>-d</code>：挂后台运行</li>
</ul>
<h2 id="8查看容器状态">8.查看容器状态</h2>
<p>查看容器状态命令：</p>
<pre><code>docker ps -a
</code></pre>
<p><img src="https://ae01.alicdn.com/kf/H30935c3f43784024a3b9d640e6a4baf0w.jpg" alt=""></p>
<h2 id="9进入容器">9.进入容器</h2>
<pre><code>docker exec -i -t firstmysql bash
</code></pre>
<p><img src="https://ae01.alicdn.com/kf/Ha34afe45477240aa8e74e6a1d5eec0fdu.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LuckyFrame自动化测试平台部署指南]]></title>
        <id>https://yihangliak.github.io/post/luckyframe</id>
        <link href="https://yihangliak.github.io/post/luckyframe">
        </link>
        <updated>2019-08-28T02:09:31.000Z</updated>
        <summary type="html"><![CDATA[<p>LuckyFrame测试平台是一款免费开源的测试平台，最大的特点是全纬度覆盖了接口自动化、WEB UI自动化、APP自动化，并且支持分布式测试，测试关键字驱动也很大程度上解决了测试同学代码基础弱的问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>LuckyFrame测试平台是一款免费开源的测试平台，最大的特点是全纬度覆盖了接口自动化、WEB UI自动化、APP自动化，并且支持分布式测试，测试关键字驱动也很大程度上解决了测试同学代码基础弱的问题。</p>
<!-- more -->
<h1 id="关于luckyframe">关于LuckyFrame</h1>
<p>​	<code>LuckyFrame</code>测试平台是一款免费开源的测试平台，最大的特点是全纬度覆盖了<code>接口自动化</code>、<code>WEB UI自动化</code>、<code>APP自动化</code>，并且支持<code>分布式测试</code>，<code>测试关键字驱动</code>也很大程度上解决了测试同学代码基础弱的问题。同时也集成了<code>质量管理</code>相关的一些功能，解决QA的日常工作中，项目过程数据的收集问题，并能展示一些简单质量报表。</p>
<h1 id="windows平台部署">Windows平台部署</h1>
<h2 id="1-安装jdk">1. 安装JDK</h2>
<ul>
<li>部署LuckyFrame之前，需要先安装jdk，且版本要求在<code>1.8</code>以上</li>
<li>JDK去<code>oracle</code>官网下载即可</li>
<li>打开环境变量配置界面，在用户变量中新增<code>JAVA_HOME=jdk安装路径</code>，再将<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</code>添加至系统变量<code>path</code>中即可</li>
<li>在命令行中输入<code>java -version</code>验证</li>
</ul>
<h2 id="2-安装mysql">2. 安装MySQL</h2>
<p>下载xampp集成环境，免去单独配置安装MySQL的麻烦</p>
<ul>
<li>将xampp解压到某磁盘根目录</li>
<li>打开xampp-control程序，启动MySQL</li>
<li>进入xampp中的<code>mysql\bin</code>目录，在当前路径下打开命令行</li>
<li>使用<code>mysql -uroot -p</code>登录（xampp集成的MySQL无密码）</li>
<li>切换到MySQL数据库：<code>use mysql</code></li>
<li>修改MySQL密码：<code>update user set password=password('123456') where user='root'</code></li>
<li>刷新权限：<code>flush privileges</code></li>
</ul>
<h2 id="3-下载luckyframe">3. 下载LuckyFrame</h2>
<p>访问Luckyframe官网，直接下载编译包，下载地址如下：</p>
<pre><code>链接：  https://pan.baidu.com/s/1SNUhzoKFgH2TRQN2Rx711A 密码：u845
</code></pre>
<blockquote>
<p>注意：下载3.0bata版本，同时还要下载数据库初始化sql文件</p>
</blockquote>
<h2 id="4修改编译包数据库配置">4.修改编译包数据库配置</h2>
<ul>
<li>使用压缩工具打开下载好的编译包</li>
<li>找到编译包目录中<code>BOOT-INF\classes\application-druid.yml</code>文件</li>
<li>用notepad打开，将其中的<code>主数据库源</code>配置项中的密码改成本机MySQL的密码</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/Heabb9bbbc3f94b159ac29c938f9602741.png" alt=""></p>
<h2 id="5导入sql文件">5.导入SQL文件</h2>
<p>在启动LuckyFrame之前，需要先在MySQL数据库中导入<code>初始化sql</code>文件</p>
<ul>
<li>登录MySQL，新建<code>luckyframe</code>数据库：<code>create database luckyframe charset=utf8;</code></li>
<li>回到命令行，使用<code>mysql -h localhost -uroot -p luckyframe &lt; V3.sql --default-character-set=utf8</code>将初始化SQL文件导入进数据库，注意要在sql文件所在目录执行该命令</li>
</ul>
<h2 id="6启动luckyframe">6.启动LuckyFrame</h2>
<ul>
<li>
<p>进入LuckyFrame服务端jar包存放目录，在此目录打开命令行</p>
</li>
<li>
<p>命令行输入：<code>java -jar LuckyFrameWeb.jar</code>启动服务即可</p>
</li>
<li>
<p>启动成功后，会看到如下提示</p>
</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/H3bb471a358a64da28a46a31a45dd130eN.png" alt=""></p>
<h2 id="7访问">7.访问</h2>
<ul>
<li>在浏览器中输入<code>本机ip：80</code>即可访问LuckyFrame，默认为80端口，可以省略不写</li>
<li>如要修改端口号，需要在编译包中找到<code>BOOT-INF\classes\application.yml</code>文件，修改默认端口配置</li>
</ul>
<p>访问效果图如下：</p>
<p><img src="https://ae01.alicdn.com/kf/H50d41bdd78bd40889b1bfdc4a47e89cdr.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jemeter性能测试完整入门]]></title>
        <id>https://yihangliak.github.io/post/begin_jemeter</id>
        <link href="https://yihangliak.github.io/post/begin_jemeter">
        </link>
        <updated>2019-07-23T01:18:12.000Z</updated>
        <summary type="html"><![CDATA[<p>性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p>
]]></summary>
        <content type="html"><![CDATA[<p>性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p>
<!-- more -->
<h1 id="第一章-性能基础知识">第一章 性能基础知识</h1>
<h2 id="1-性能测试的概念">1. 性能测试的概念</h2>
<p>通过性能测试工具模拟多种正常，峰值，以及异常负载条件来对系统的各项性能指标进行测试</p>
<h2 id="2性能测试的目的">2.性能测试的目的</h2>
<ul>
<li>评估系统能力</li>
<li>测试系统可靠性</li>
<li>识别系统的弱点（内存泄漏）</li>
<li>性能调优（满足用户需求，优化瓶颈，提高整体性能）</li>
</ul>
<blockquote>
<p>性能测试时间点，功能测试之后</p>
</blockquote>
<h2 id="3性能测试归属">3.性能测试归属</h2>
<p>测试阶段划分：系统测试</p>
<p>性能测试属于黑盒测试</p>
<p>属于6大质量特性中的：效率特性</p>
<h1 id="第二章-性能测试的分类">第二章 性能测试的分类</h1>
<h2 id="1-负载测试">1 负载测试</h2>
<ul>
<li>通过逐步给服务器增加压力，直到某项数据不达标，测试软件的瓶颈</li>
<li>评测和评估对象在不同工作量条件下的性能行为</li>
<li>负载的目标是确保系统测试超出预期工作量的情况下仍然可以继续运行</li>
</ul>
<h2 id="2-压力测试">2 压力测试</h2>
<ul>
<li>强度测试，通过高负载的手段来使服务器资源处于极限状态，直到某项数据失效，测试系统的极限</li>
<li>通过高负载的手段，可以更快的发现系统内存泄漏以及稳定性等问题</li>
</ul>
<h2 id="3-失效恢复性测试">3 失效恢复性测试</h2>
<ul>
<li>出现问题后能否根据预先制定的策略恢复，且恢复后能正常工作</li>
</ul>
<h2 id="4-并发测试">4 并发测试</h2>
<ul>
<li>测试多用户按照预定的场景请求某个业务或者功能时，是否会出现问题</li>
<li>几乎所有的性能测试都会涉及到并发测试，并发测试的主要目的是找出并发问题（资源争用）</li>
</ul>
<h2 id="5-稳定性测试">5 稳定性测试</h2>
<ul>
<li>一般使用目标负载的1.5-2倍的负载量或者CPU占用达到70%，测试系统长时间运行（7x24），观察系统稳定性</li>
</ul>
<h2 id="6-配置测试">6 配置测试</h2>
<ul>
<li>通过调整系统软件、硬件环境，了解在不同情况下系统性能指标情况，从而找到系统最优配置</li>
</ul>
<blockquote>
<p>新产品上线以前，先做一个配置测试，找到最优配置，然后进行负载，压力，稳定，失效恢复性等测试</p>
<p>产品上线以后主要做压力测试</p>
<p>当然，具体做什么类型的性能测试，需要根据项目背景去灵活选择</p>
</blockquote>
<h1 id="第三章-性能术语">第三章 性能术语</h1>
<h2 id="1-事务">1 事务</h2>
<p>一个任务从开始到结束的过程</p>
<blockquote>
<p>事务具有原子性</p>
<p>原子性：整个程序操作过程中的所有操作，要么全部完成，要么全部不完成</p>
</blockquote>
<h2 id="2-响应时间">2 响应时间</h2>
<p>系统对请求作出响应的时间（一个事务处理完成的时间）</p>
<blockquote>
<p>响应时间=网络传输时间+web服务器处理时间+DB服务器处理时间+浪费时间</p>
<p>258原则：</p>
<p>&lt;2秒快<br>
大于2小于5秒可以<br>
大于5小于8秒勉强接受<br>
大于8秒不耐烦了，或者认为系统已经失去响应，而选择离开这个Web站点，或者发起第二次请</p>
</blockquote>
<h2 id="3-吞吐量">3 吞吐量</h2>
<p>每秒服务器处理的请求或者事务数</p>
<p>吞吐量衡量单位：</p>
<ul>
<li>每秒请求数</li>
<li>每秒事务数（TPS）</li>
<li>每秒页面数</li>
<li>每秒查询数（QPS）</li>
</ul>
<h2 id="4-并发">4 并发</h2>
<ul>
<li>绝对并发：不同用户，在同一时刻，做同一个操作</li>
<li>相对并发：不用用户，在同一时刻，做不同操作</li>
</ul>
<h2 id="5-并发数">5 并发数</h2>
<p>同一时间操作的用户个数</p>
<h2 id="6-场景">6 场景</h2>
<p>模拟用户的真实操作过程</p>
<p>分类：</p>
<ul>
<li>单一场景：单个操作</li>
<li>混合场景：多个组合操作</li>
</ul>
<h2 id="7-思考时间">7 思考时间</h2>
<p>用户每个操作之间的间隔时间，增加间隔时间可以更真实地模拟用户使用的场景</p>
<h2 id="8-性能瓶颈">8 性能瓶颈</h2>
<p>软件的性能缺陷</p>
<p>这个缺陷主要分布在：</p>
<ul>
<li>硬件：如cpu等配置过低</li>
<li>应用服务器：如web服务器，数据库系统等</li>
<li>程序：程序设计的问题</li>
<li>操作系统：如Windows虚拟内存交换效果不理想等</li>
<li>网络设备：防火墙，交换机等</li>
</ul>
<h1 id="第四章-性能测试工具">第四章 性能测试工具</h1>
<h2 id="1-工具分类">1 工具分类</h2>
<p><strong>jmeter</strong></p>
<ul>
<li>免费，开源</li>
<li>支持二次开发</li>
<li>支持分布式部署</li>
<li>支持命令行模式</li>
</ul>
<p><strong>LoadRunner</strong></p>
<ul>
<li>商业，收费</li>
</ul>
<p><strong>Locust</strong></p>
<ul>
<li>python开源性能测试工具</li>
</ul>
<p><strong>Apache ab</strong></p>
<ul>
<li>Apache的web性能测试工具</li>
</ul>
<h1 id="第五章-jmeter原理与安装">第五章  Jmeter原理与安装</h1>
<h2 id="1-工作原理">1 工作原理</h2>
<p>使用取样器向服务器发送请求，从服务器获取响应结果，然后通过线程组模拟服务器压力</p>
<h2 id="2-安装">2 安装</h2>
<p>安装JDK并配置环境变量</p>
<p>官网下载jmeter压缩包，并解压</p>
<p>双击bin目录下的jmeter.bat启动即可</p>
<h2 id="3-常用组件">3 常用组件</h2>
<p>Test Plan：测试计划（场景）</p>
<ul>
<li>Thread Group：线程组，模拟并发数
<ul>
<li>http request ：取样器，模拟用户请求
<ul>
<li>view result tree：查看结果树，监听取样器的结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/05/23/5ce651c23611220681.png" alt=""></p>
<p>在取样器中添加响应断言</p>
<p><img src="https://i.loli.net/2019/05/23/5ce654857964383456.png" alt=""></p>
<p>断言界面详解</p>
<p><img src="https://i.loli.net/2019/05/23/5ce655cf44fc126049.png" alt=""></p>
<p>添加聚合报告</p>
<p><img src="https://i.loli.net/2019/05/23/5ce656572cffc62167.png" alt=""></p>
<p>聚合报告详情</p>
<p><img src="https://i.loli.net/2019/05/23/5ce658c11d59d64211.png" alt=""></p>
<h2 id="4-第一个脚本">4 第一个脚本</h2>
<p>1.新建测试计划</p>
<p>2.创建线程组</p>
<p>3.添加http取样器</p>
<p>4.添加监听器-view result tree</p>
<p>5.添加断言-response assertion</p>
<p>6.添加聚合报告</p>
<p>ecshop登录脚本</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66637dacc955298.png" alt=""></p>
<h1 id="第六章-jmeter常用组件">第六章 jmeter常用组件</h1>
<h2 id="1-参数化">1 参数化</h2>
<p>1.设置用户自定义变量</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66b3899da523409.png" alt=""></p>
<p>调用方式与RF一致，${变量名}</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66f8a9d53b90774.png" alt=""></p>
<p>添加参数化文件读取组件</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66f2c1f19c73246.png" alt=""></p>
<p><img src="https://i.loli.net/2019/05/23/5ce66fa76129952059.png" alt=""></p>
<h2 id="2-cookie关联">2 cookie关联</h2>
<p>把上一个取样器的结果关联到一下个取样器</p>
<p>http cookie manager 可以把cookie自动关联到下一个取样器的请求中</p>
<p>在同一个线程组中添加一个 HTTP cookie manager</p>
<p><img src="https://i.loli.net/2019/05/24/5ce75a94d259889153.png" alt=""></p>
<p>添加完成以后无需配置，即可将第一个取样器中的cookie自动同步至所有线程组</p>
<h2 id="3-上传文件">3  上传文件</h2>
<p>以ecshop留言上传文件为例</p>
<p>首先添加一个发表留言并且要上传文件的取样器，并配置好取样器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce75d54d671b93977.png" alt=""></p>
<p>配置文件上传参数</p>
<p><img src="https://i.loli.net/2019/05/24/5ce75e271af0025911.png" alt=""></p>
<p>运行成功示意图</p>
<h2 id="4-正则提取器">4  正则提取器</h2>
<p>提取取样器结果中的任何内容</p>
<p>通过表达式从一堆数据中提取符合表达式规则的数据</p>
<p>语法：</p>
<pre><code>[0-9]  : 表示任意一个数字，等价于/d
[a-z]  : 表示任意一个小写字母
[A-Z]  : 表示任意一个大写字母
\w     : 表示任意一个字符，包含大小写字母，中文，数字以及一个_
\s     : 表示一个空格
{}     : 表示匹配前面表达式的连续n个
{m,n}  : 表示匹配前面表达式的连续m-n个
+      : 表示匹配前面表达式的一个或多个
\      : 去转义
.      : 表示出了换行符之外的任意一个字符
$      : 结尾
^      : 开头
？     ： 非贪婪匹配，匹配到一个结果后结束匹配
()     : 需要提取的内容用小括号包围

</code></pre>
<p>添加正则提取器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce79fbf48c9a19994.png" alt=""></p>
<p>配置正则提取器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7a0dc8de5817775.png" alt=""></p>
<p>在一下个查询订单详情的取样器中使用上述提取出的变量</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7a1a2cae6f21453.png" alt=""></p>
<h2 id="5-添加debug组件">5  添加debug组件</h2>
<p>该组件可以查看所有使用过的变量</p>
<p>添加debug组件</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7aa82246b181060.png" alt=""></p>
<p>为该组件添加一个结果树，即可查看使用过的变量</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1558686516491.png" alt=""></p>
<h2 id="6-逻辑控制器">6  逻辑控制器</h2>
<p>逻辑控制器，可以控制取样器的执行顺序</p>
<h3 id="61-for">6.1 for</h3>
<p>添加for循环控制器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ae70d9dda97533.png" alt=""></p>
<p>将查询订单详情挪至for控制器里面</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ae13e19b824772.png" alt=""></p>
<p>配置for控制器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ba0abf23475823.png" alt=""></p>
<p>修改正则提取中的配置</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7af62df31663732.png" alt=""></p>
<p>在查询订单中使用遍历出来得变量即可</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ba3b3d35a16894.png" alt=""></p>
<h3 id="62-if">6.2 if</h3>
<p>添加if控制器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7bb8e3673832089.png" alt=""></p>
<p>确定判断逻辑</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1558691180942.png" alt=""></p>
<p>在第一步登录取样器中提取登录结果</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7bdb68b02631353.png" alt=""></p>
<p>然后分别配置登录成功与登录失败需要执行的步骤</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7be22baf8b41429.png" alt=""></p>
<p><img src="https://i.loli.net/2019/05/24/5ce7be509b33387820.png" alt=""></p>
<h2 id="7-开关控制器">7 开关控制器</h2>
<p>方式一：通过0和1决定执行哪个，0执行第一个，1执行第二个</p>
<p>方式二：通过取样器名字决定执行哪个，名字必须与取样器完成一致才会执行</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7c63a893d843848.png" alt=""></p>
<h2 id="8-循环控制器">8  循环控制器</h2>
<p>对单个取样器进行循环操作</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7c6e140e4d40844.png" alt=""></p>
<h1 id="第七章-并发数">第七章  并发数</h1>
<h2 id="1-平均并发数">1 平均并发数</h2>
<p>计算平均并发数</p>
<pre><code>平均并发数 = 每日活跃用户数*用户使用时间/访问时间段
</code></pre>
<p>一个系统，每天2000个用户访问，访问时间集中在上午9-12点，平均每个用户访问10分钟，计算并发数</p>
<pre><code>(2000*10)/(60*3)=111(大约)
# 2000为用户数量
# 10为用户使用时间
# 60*3是为了前后单位统一，访问时间段为3个小时
</code></pre>
<h2 id="2-峰值用户数">2 峰值用户数</h2>
<pre><code>峰值用户数 = 平均并发数 + 3*sqrt（平均并发数）
</code></pre>
<h1 id="第八章-搭建资源监控环境">第八章  搭建资源监控环境</h1>
<h2 id="1服务端">1.服务端</h2>
<ul>
<li>在服务器端安装java，并且配置环境变量</li>
</ul>
<pre><code>创建java存放目录：/usr/local/java
Linux配置环境变量
cd ~   # 进入root目录
vi .bash_profile


yum -y install java-1.8.0-openjdk*
</code></pre>
<ul>
<li>上传ServerAgent.zip到/opt目录，然后解压</li>
<li>进入ServerAgent目录，启动该代理</li>
</ul>
<pre><code>./startAgent.sh     # 启动监控代理
./startAgent.sh &amp;   # 以进程方式启动监控代理
</code></pre>
<h2 id="2-jmeter端">2. jmeter端</h2>
<ul>
<li>jmeter安装插件管理器</li>
</ul>
<pre><code>将jmeter-plugins-manager-1.3.jar放至jmeter安装目录下的lib\ext中
重启jmeter
</code></pre>
<ul>
<li>在option菜单中启动插件管理器</li>
<li>在打开的插件管理器安装</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebad6c81ac693657.png" alt=""></p>
<ul>
<li>在jmeter脚本线程组中添加jpgc监听器</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebadd487f8598359.png" alt=""></p>
<ul>
<li>配置该监听器</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebae25df76815710.png" alt=""></p>
<ul>
<li>不要忘了设置线程组，配置几个线程，运行时间等</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebaf5d655f499007.png" alt=""></p>
<h1 id="第九章-性能测试流程">第九章  性能测试流程</h1>
<ul>
<li>需求分析(学习业务，分析规格文档)</li>
<li>场景设计(测试场景、测试类型、并发数、步长、思考时间)</li>
<li>编写计划</li>
<li>环境搭建、数据准备、脚本开发</li>
<li>性能测试(性能数据收集)</li>
<li>性能分析、性能调优</li>
<li>性能测试报告</li>
<li>结束</li>
</ul>
<h1 id="第十章-centos搭建ecshop">第十章  centos搭建ecshop</h1>
<p>1.上传xampp压缩包并解压</p>
<pre><code>tar -xzvf xampp-linux-1.7.7.tar.gz
</code></pre>
<p>2.进入lampp目录</p>
<p>3.输入命令启动xampp</p>
<pre><code class="language-shell">./lampp start

# 如果提示xampp只能在32位系统运行
# 使用yum命令安装32位包
yum install -y glibc*i686
</code></pre>
<p>3.启动成功后，验证是否启动成功</p>
<pre><code>netstat -anp|grep 80   # 查看httpd端口是否启动，httpd就是Apache的进程
netstat -anp|grep 3306 # 查看mysql的端口是否存在
</code></pre>
<p><img src="https://i.loli.net/2019/05/27/5cec07cf0cd3824063.png" alt=""></p>
<p>4.上传ecshop项目包到htdocs目录</p>
<p>5.解压安装即可</p>
<h1 id="第十一章-练习">第十一章  练习</h1>
<h2 id="1-ecshop登录实现参数化">1. ecshop登录实现参数化</h2>
<h3 id="11-创建登录脚本">1.1 创建登录脚本</h3>
<p>创建测试计划</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81d0f7d9b041641.png" alt=""></p>
<p>添加线程组</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81d3fdfca938484.png" alt=""></p>
<p>添加取样器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81d6076a3d26826.png" alt=""></p>
<p>配置取样器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81f7d0f95e89886.png" alt=""></p>
<p>添加观察结果树</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81f9cb20ea79058.png" alt=""></p>
<p>验证是否登录成功</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81fe80066343193.png" alt=""></p>
<h3 id="12-添加参数化组件">1.2 添加参数化组件</h3>
<p>添加参数读取组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82020025e261962.png" alt=""></p>
<p>创建参数化文件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce820debcf3155100.png" alt=""></p>
<p>配置参数化组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce821bec8c8c90652.png" alt=""></p>
<p>重新用参数化形式配置取样器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce823c7235d651409.png" alt=""></p>
<h3 id="13-添加循环控制器">1.3 添加循环控制器</h3>
<p>添加一个循环控制器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce8229f4b87e20141.png" alt=""></p>
<p>配置循环控制器，循环执行次数为3次，与参数化源文件数量对应</p>
<p><img src="https://i.loli.net/2019/05/25/5ce822c29a73c34944.png" alt=""></p>
<h3 id="14-验证结果">1.4 验证结果</h3>
<p>执行，验证是否三个账号都登录成功</p>
<p>添加断言</p>
<p><img src="https://i.loli.net/2019/05/25/5ce825276b49549803.png" alt=""></p>
<p>手工验证</p>
<p><img src="https://i.loli.net/2019/05/25/5ce824161278f49947.png" alt=""></p>
<h2 id="2-ecshop浏览器商品">2. ecshop浏览器商品</h2>
<h3 id="21-准备工作">2.1 准备工作</h3>
<p>以登录脚本为基础</p>
<ul>
<li>去掉参数化配置</li>
<li>去掉循环控制器</li>
<li>保证登录成功</li>
</ul>
<h3 id="22-关联cookie">2.2 关联cookie</h3>
<p>添加cookie关联</p>
<p><img src="https://i.loli.net/2019/05/25/5ce8282a21f5839026.png" alt=""></p>
<h3 id="23-配置用户自定义变量">2.3 配置用户自定义变量</h3>
<p>配置用户自定义变量可以在创建多个取样器时，方便取样器的配置统一性</p>
<p>添加用户自定义变量组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce829196fa8387851.png" alt=""></p>
<p>配置用户自定义变量组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82962c2e9b75133.png" alt=""></p>
<p>修改登录取样器，调用用户自定义变量</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82999679b343666.png" alt=""></p>
<p>修改浏览商品取样器配置</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82a15dd3b776964.png" alt=""></p>
<h3 id="24-观察结果与断言">2.4 观察结果与断言</h3>
<p>为浏览器商品分别添加结果树，断言，以及整个线程组的聚合报告</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82af98792689035.png" alt=""></p>
<h3 id="25-验证结果">2.5 验证结果</h3>
<p>执行脚本，查看聚合报告中的结果是否正确</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82b68eefdf11673.png" alt=""></p>
<h1 id="第十二章-图形化报告">第十二章 图形化报告</h1>
<p>以命令行的模式运行jmeter脚本,生成图形化的报告</p>
<pre><code>jmeter -n -t C:\Users\Administrator\Desktop\lejifen.jmx -l result.jtl -e -o E:\apache-jmeter-5.1.1\bin\WebReport
</code></pre>
<ul>
<li>n：非GUI模式执行JMeter；</li>
<li>t： 脚本文件(.jmx文件)的路径；</li>
<li>l： 指定生成测试结果的保存文件(.jtl格式)，此文件必须不存在；</li>
<li>e：测试结束后，生成测试报告；</li>
<li>o：用于存放测试报告的路径；</li>
</ul>
<blockquote>
<p>注意：如果要重新生成一份测试报告，都需要将Jmeter的bin目录下的jtl文件以及webreport文件夹进行删除。<br>
可以在Jmeter的bin目录下手动直接删除，也可以通过命令删除。</p>
</blockquote>
<pre><code>del /s /Q D:\Jmeter\apache-jmeter-3.2\bin\result.jtl //删除jtl文件
rd /s /Q D:\Jmeter\apache-jmeter-3.2\bin\WebReport //删除webreport文件夹
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2019 年中总结]]></title>
        <id>https://yihangliak.github.io/post/2019_mid_year</id>
        <link href="https://yihangliak.github.io/post/2019_mid_year">
        </link>
        <updated>2019-07-22T08:22:12.000Z</updated>
        <summary type="html"><![CDATA[<p>月亮总不会被太阳抛弃  所以等你的日子不值一提</p>
]]></summary>
        <content type="html"><![CDATA[<p>月亮总不会被太阳抛弃  所以等你的日子不值一提</p>
<!-- more -->
<p>不知不觉，19年已经过去大半啦<br>
马上就要再一次经历<code>happy birthday</code>的洗礼<br>
回顾这大半年  除了工作 好像没干啥事儿<br>
<strong>视力不断<code>↓</code></strong><br>
走在路上   四五米开外的东西  已是时见一斑<br>
<strong>体重不断<code>↑</code></strong><br>
办了张健身卡 从刚开始拿到卡的打鸡血模式 现在演变成了 耶 又下雨了 可以不用去跑步了的状态<br>
6月份  公司组织去桂林旅游<br>
WTF  大学毕业旅行就是去的桂林   时隔多年 竟想不到以这种方式故地重游<br>
想我一湖南人  张家界都没有去过 竟然去了桂林两次  还是旅游<br>
心态崩了<br>
最近迷上焦迈奇的歌   有一首里面写到<br>
<code>月亮总不会被太阳抛弃 所以等你的日子不值一提</code><br>
唱的真好  干的漂亮<br>
原来有时候  一个人干着不为人知的事情  very洒脱<br>
写这篇总结断断续续<br>
从早上写到晚上<br>
绞尽脑汁   东拼西凑<br>
可是到现在还是混乱得 宛如一片残垣<br>
得<br>
还是来根<code>寂寞</code>再说<br>
记忆是个好东西  可惜我没有<br>
以摆动的二郎腿结束这篇<code>zongjie</code><br>
愿顺利度过余下半年 白发少几根  体重减几斤  工资涨几分</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python Requests]]></title>
        <id>https://yihangliak.github.io/post/python-requests</id>
        <link href="https://yihangliak.github.io/post/python-requests">
        </link>
        <updated>2019-07-20T01:53:31.000Z</updated>
        <summary type="html"><![CDATA[<p>Requests 唯一的一个非转基因的 Python HTTP 库，人类可以安全享用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Requests 唯一的一个非转基因的 Python HTTP 库，人类可以安全享用。</p>
<!-- more -->
<h1 id="requests">Requests</h1>
<h1 id="1-安装requests">1. 安装requests</h1>
<p>命令行使用pip安装：<code>pip install requests</code></p>
<h1 id="2-get请求">2. get请求</h1>
<h2 id="21-get请求">2.1 get请求</h2>
<p>该方法用于向目标网址发送请求，接收响应</p>
<p><code>get</code>方法中的参数说明：</p>
<ul>
<li>url：必填，指定请求的目标网址</li>
<li>params：字典类型，指定请求参数</li>
</ul>
<p>该方法返回一个response对象，常用的方法和属性如下：</p>
<pre><code class="language-python">import requests

r = requests.get('https://api.github.com/events')  # 使用get请求访问github
print(r.status_code)                      # 打印响应状态码
print(r.text)                             # 返回str类型的响应
print(r.url)                              # 返回请求网站的url
print(r.encoding)                         # 返回响应时间的编码方式
print(r.cookies)                          # 返回响应的cookies信息
print(r.headers)                          # 返回响应头部
print(r.content)                          # 返回bytes类型的响应体
print(r.json())                           # 返回字典类型的响应体
</code></pre>
<h2 id="22-传递url参数">2.2 传递URL参数</h2>
<blockquote>
<p>注意：<code>httpbin.org</code>是一个开源的，用于测试网页请求的网站</p>
</blockquote>
<p>在get请求中，使用<code>params</code>关键字参数，可将字典类型的自定义参数传入到URL中进行拼接</p>
<pre><code class="language-python">import requests

url = 'http://httpbin.org/get'   # 定义请求目标网址
params = {                       # 定义自定义请求参数
    'key1':'value1',
    'key2':'value2'
}
r = requests.get(url, params=params)  # get请求中传入自定义参数
print(r.status_code)               # 打印状态码
print(r.url)                       # 打印传入参数后的URL
print(r.json())                    # 返回dict响应
</code></pre>
<pre><code># 状态码
200
# 传入参数后的url
http://httpbin.org/get?key1=value1&amp;key2=value2    
# 返回的dict类型数据中可以看到自定义参数
{'args': {'key1': 'value1', 'key2': 'value2'}, 'headers': {'Accept': '*/*', 'Accept-Encodinh': 'gzip, deflate', 'Connectioo': 'keep-alive', 'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.18.4'}, 'origin': '119.123.77.203, 119.123.77.203', 'url': 'https://httpbin.org/get?key1=value1&amp;key2=value2'}

</code></pre>
<h2 id="23-实例">2.3 实例</h2>
<p>以百度搜索为例</p>
<pre><code class="language-python">import requests

url = 'http://www.baidu.com/s'
params = {'wd':'python'}
r = requests.get(url, params=params)  # get方法中传入params参数，可以讲自定义参数拼接到URL中
print(r.url)                          # 打印拼接过后的URL
print(r.text)                         # 打印响应文本内容
</code></pre>
<pre><code>http://www.baidu.com/s?wd=python
</code></pre>
<h1 id="3-post请求">3. post请求</h1>
<p>在web课程中我们已经知晓了，客户端发送一些敏感的信息时，我们需要通过post请求方式，这种传输方式比get请求安全，而且是通过加密的方式传输比较安全，下面我们就介绍一下怎样通过requests库进行发送post请求</p>
<h2 id="31-data">3.1 data</h2>
<p>如果想要发送一些编码为表单形式的数据，只需要传递一个字典给<code>data</code>关键字参数，你的字典数据在发出请求时自动编码为表单形式</p>
<pre><code class="language-python">import requests

# 给data传入字典数据
r = requests.post('http://httpbin.org/post', data={'key1':'value1', 'key2':'value2'})
print(r.text)
</code></pre>
<pre><code>{
  &quot;args&quot;: {}, 
  &quot;data&quot;: &quot;&quot;, 
  &quot;files&quot;: {}, 
  &quot;form&quot;: {               # data传入到这里，以表单形式
    &quot;key1&quot;: &quot;value1&quot;, 
    &quot;key2&quot;: &quot;value2&quot;
  }, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Content-Length&quot;: &quot;23&quot;, 
    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot;
  }, 
  &quot;json&quot;: null, 
  &quot;origin&quot;: &quot;119.123.77.203, 119.123.77.203&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/post&quot;
}
</code></pre>
<h2 id="32-json">3.2 json</h2>
<p>post方法还可以以<code>json</code>关键字参数传入json数据，传入json数据时，<code>header</code>中的<code>Content-Type</code>默认为<code>application/json</code></p>
<p>将字典数据转化为<code>json</code>数据，需要导入<code>json</code>模块，并用<code>dumps</code>进行转换</p>
<pre><code class="language-python">import requests

data = {'key1':'value1', 'key2':'value2'}   # 定义字典数据

# 将字典转化为json并传入请求中
r = requests.post('http://httpbin.org/post', json=json.dumps(data))  
print(r.text)
</code></pre>
<pre><code>{
  &quot;args&quot;: {}, 
  &quot;data&quot;: &quot;\&quot;{\\\&quot;key1\\\&quot;: \\\&quot;value1\\\&quot;, \\\&quot;key2\\\&quot;: \\\&quot;value2\\\&quot;}\&quot;&quot;,   # json传到这里
  &quot;files&quot;: {}, 
  &quot;form&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Content-Length&quot;: &quot;46&quot;, 
    &quot;Content-Type&quot;: &quot;application/json&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot;
  }, 
  &quot;json&quot;: &quot;{\&quot;key1\&quot;: \&quot;value1\&quot;, \&quot;key2\&quot;: \&quot;value2\&quot;}&quot;, 
  &quot;origin&quot;: &quot;119.123.77.203, 119.123.77.203&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/post&quot;
}

</code></pre>
<h2 id="33-实例">3.3 实例</h2>
<blockquote>
<p>在真实场景中，如何能够确定<code>post</code>请求中应该传入<code>data</code>还是<code>json</code>呢？</p>
</blockquote>
<p>确定<code>post</code>请求中，应该传入<code>data</code>还是<code>json</code>，可以通过抓包工具抓取请求数据，查看请求<code>header</code>中<code>Content-Type</code>的值：</p>
<ul>
<li><code>Content-Type：application/from</code>：传入data</li>
<li><code>Content-Type：application/json</code>：传入json</li>
</ul>
<p>ecshop登录实例：</p>
<p>首先，通过<code>fiddler</code>抓包，查看ecshop登录请求头中的<code>Content-Type</code>，可以看到请求中的数据是以<code>from</code>的形式发送到服务器的，如图：</p>
<p><img src="https://i.loli.net/2019/07/22/5d352bcc4179d47999.png" alt=""></p>
<p>所以，在使用<code>requests</code>发送<code>post</code>请求时，用户名与密码都会以<code>data</code>关键字参数传入</p>
<pre><code class="language-python">import requests
import re

url = 'http://localhost:82/ecshop/user.php'
datas = {'username':'liyihang', 'password':'tashi123', 'act':'act_login'}
r = requests.post(url, data=datas)
print(r.text)

# 加入判断进行断言
if &quot;欢迎您回来！&quot; in result:
    print('登录成功')
else:
	print('登录失败')
</code></pre>
<h1 id="4-保持会话">4. 保持会话</h1>
<p>一般在项目中，很多操作都是需要先登录再进行，所以需要先发送登录请求，登录成功后，保持登录状态，再进行后续操作，在requests中保持会话，我们可以用<code>session</code>来保持登录状态</p>
<blockquote>
<p><strong>为什么session可以实现保持会话呢？</strong></p>
<p>因为底层使用的是urllib3.connectionpool 一看到连接池就会联想到数据库的连接池，对就是池化的概念。且链接是采用的HTTP 长链接，再底层是用HTTP1.1 Connection: keep-alive来实现的</p>
</blockquote>
<pre><code class="language-python">import requests

# 保持登录，然后充值100
s = requests.session()  # 建立一个session

# 定义登录与充值需要的数据
url = 'http://localhost:82/ecshop/user.php'
datas1 = {'username':'liyihang', 'password':'tashi123', 'act':'act_login'}
datas2 = {'amount':'100', 'user_note':'jiekou', 'payment_id':'2', 'act':'act_account'}

# 使用建立的session对象发送登录请求
# 登录成功后会返回的cookie会被保存在该session中
r = s.post(url, data=datas1)
# print(r.cookies)
# 发送充值请求
r2 = s.post(url, data=datas2 )
print(r2.text)

# 这里可以加一个简单判断用来断言结果是否正确
</code></pre>
<h1 id="5自定义请求头">5.自定义请求头</h1>
<h2 id="51-获取请求头">5.1 获取请求头</h2>
<blockquote>
<p><code>httpbin.org/headers</code>会返回发送请求的请求头</p>
</blockquote>
<p>请求头内容可以用<code>r.headers</code>获取</p>
<pre><code class="language-python">import requests

r = requests.get('http://httpbin.org/headers')
print(r.headers)
print(r.text)

</code></pre>
<p>结果如下，可以看到<code>user-agent</code>为requests</p>
<pre><code>{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate&quot;, 
    &quot;Connectioo&quot;: &quot;keep-alive&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot;   
  }
}
</code></pre>
<h2 id="52-自定义请求头">5.2 自定义请求头</h2>
<p>很多网站为了保证安全会设置<code>反爬虫机制</code>，也就是说对于<code>非浏览器</code>的访问拒绝响应，在这种情况下，就需要修改请求中的<code>headers</code>信息<code>伪装</code>成浏览器访问</p>
<p><strong>使用浏览器访问httpbin 获取headers</strong></p>
<p>打开浏览器，在地址栏中输入：<code>http://httpbin.org/headers</code></p>
<p>该URL会返回发送请求的请求头，所以会将浏览器发送的请求头部返回，如下：</p>
<pre><code>{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, 
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate&quot;, 
    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, 
    &quot;Connectioo&quot;: &quot;keep-alive&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, 
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
  }
}
</code></pre>
<p><strong><code>headers</code>中各参数的作用如下：</strong></p>
<ul>
<li>accept：指定客户单接受的内容类型，<code>/</code>表示任意类型，其余按照字义</li>
<li><s>accept-encoding：指定客户端接受的编码类型</s></li>
<li><s>accept-language：指定客户端接受的语言类型，<code>q=0.9</code>表示喜欢程度，不写则是1，数值越高越喜欢</s></li>
<li>connection：指定长链接处理方式，<code>keep-alive</code>表示希望保持传输链接，http本身是无状态的</li>
<li>host：服务器主机名</li>
<li>user-agent：用户代理，服务器从此处知道客户端的系统类型以及版本等信息</li>
</ul>
<p><strong>将获取到的headers 传给<code>get</code></strong></p>
<pre><code class="language-python">import requests

url = 'http://httpbin.org/headers'
header = {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;,
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate&quot;,
    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;,
    &quot;Connectioo&quot;: &quot;keep-alive&quot;,
    &quot;Host&quot;: &quot;httpbin.org&quot;,
    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
  }
# url = 'http://www.baidu.com'
r = requests.get(url, headers=header)  # 将自定义headers信息通过headers关键字参数传入
# print(r.headers)
print(r.text)
</code></pre>
<p>自定义headers后，返回的结果如下：</p>
<pre><code>{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, 
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate,gzip, deflate&quot;, 
    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, 
    &quot;Connectioo&quot;: &quot;keep-alive,keep-alive&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, 
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
  }
}

</code></pre>
<h2 id="53-实例">5.3 实例</h2>
<p>以<code>知乎发现</code>页面为例，在没有通过自定义请求头<code>伪装</code>成真实浏览器时，是获取不到该页面中的信息的，只有在将请求头伪装成与真实浏览器一样以后，才可以获取到该页面的信息</p>
<p>首先，用<code>fiddler</code>抓取知乎-发现页面请求信息，在headers中找到<code>user-agent</code>信息，并将其复制</p>
<p><img src="https://mypic-1256006100.cos.ap-chengdu.myqcloud.com/markdown_pic/Snipaste_2019-07-24_10-24-41.png" alt=""></p>
<p>然后在代码中自定义header</p>
<pre><code class="language-python">import requests

# 未定义请求头之前
# r = requests.get('https://www.zhihu.com/explore')
# print(r.text)   # 不能正常访问页面信息

header = {
    &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 &quot;
                 &quot;(KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
}

# 通过headers关键字参数将自定义header传入
r = requests.get('https://www.zhihu.com/explore', headers=header)
print(r.text)    # 正常访问知乎发现页面

</code></pre>
<h1 id="6发送https请求">6.发送HTTPS请求</h1>
<h2 id="61-sslerror">6.1 SSLError</h2>
<p>requests在发送<code>HTTPS</code>请求时，有时会报证书错误，</p>
<p>别在开启<code>Fiddler</code>抓包工具时，发送访问百度首页时会报证书错误</p>
<p>代码与错误如下：</p>
<pre><code class="language-python">import requests

r = requests.get(&quot;https://www.baidu.com&quot;)
print(r.status_code)
</code></pre>
<p>执行上述代码会报证书错误：<code>requests.exceptions.SSLError: HTTPSConnectionPool</code></p>
<h2 id="62-关闭证书验证">6.2 关闭证书验证</h2>
<blockquote>
<p>解决办法为：关闭证书验证</p>
</blockquote>
<p>Requests的请求默认<code>verify=True</code>，如果你将<code>verify</code>设置为<code>False</code>，Requests 也能忽略对 SSL 证书的验<br>
证</p>
<pre><code class="language-python">import requests

r = requests.get(&quot;https://www.baidu.com&quot;, verify=False)  # 关闭证书验证
print(r.status_code)
</code></pre>
<h2 id="63-忽略警告信息">6.3 忽略警告信息</h2>
<pre><code class="language-python">import urllib3

# 关闭警告
urllib3.disable_warnings()
r = requests.get(&quot;https://www.baidu.com&quot;, verify=False)  # 关闭证书验证
print(r.status_code)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Postman使用技巧]]></title>
        <id>https://yihangliak.github.io/post/postman-shi-yong-ji-qiao</id>
        <link href="https://yihangliak.github.io/post/postman-shi-yong-ji-qiao">
        </link>
        <updated>2019-07-19T03:40:49.000Z</updated>
        <summary type="html"><![CDATA[<p>Postman是一个接口测试工具，在做接口测试的时候，Postman相当于一个客户端，它可以模拟用户发起的各类HTTP请求，将请求数据发送至服务端，获取对应的响应结果，从而验证响应中的结果数据是否和预期值相匹配；并确保开发人员能够及时处理接口中的bug，进而保证产品上线之后的稳定性和安全性。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Postman是一个接口测试工具，在做接口测试的时候，Postman相当于一个客户端，它可以模拟用户发起的各类HTTP请求，将请求数据发送至服务端，获取对应的响应结果，从而验证响应中的结果数据是否和预期值相匹配；并确保开发人员能够及时处理接口中的bug，进而保证产品上线之后的稳定性和安全性。</p>
<!-- more -->
<h1 id="postman使用教程">Postman使用教程</h1>
<h1 id="1介绍">1.介绍</h1>
<p>postman是一个接口测试工具，在做接口测试的时候，postman相当于一个客户端，他可以模拟用户发起各类的<code>HTTP请求</code>，将<code>请求</code>你数据发送至<code>服务端</code>，获取对应的响应结果，从而验证响应中的结果是否与预期值匹配；并确保开发人员能够及时处理接口中的bug，进而保证产品上线后的<code>稳定性</code>与<code>安全性</code></p>
<h1 id="2优势">2.优势</h1>
<ul>
<li>简单易用的图形用户界面</li>
<li>可以保存API请求历史记录</li>
<li>可用集合Runner来自动化测试</li>
<li>灵活的API监控</li>
</ul>
<h1 id="3安装">3.安装</h1>
<p>官网下载地址：<a href="https://www.getpostman.com/downloads/">https://www.getpostman.com/downloads/</a></p>
<p>下载安装包安装即可，注意系统位数</p>
<h1 id="4工具界面简介">4.工具界面简介</h1>
<p><img src="https://i.loli.net/2019/07/19/5d3122915979f43319.png" alt=""></p>
<h1 id="5发送请求">5.发送请求</h1>
<h2 id="51-创建请求选项卡">5.1 创建请求选项卡</h2>
<p>点击请求构建器中的<code>+</code>号，创建一个新的选项卡</p>
<p><img src="https://i.loli.net/2019/07/19/5d3123fcbb04589086.png" alt=""></p>
<h2 id="52-填写请求地址">5.2 填写请求地址</h2>
<p>以百度首页为例，在请求地址栏中填写请求地址：<code>https://www.baidu.com/s?wd=python</code></p>
<p>请求方式选择<code>get</code></p>
<p><img src="https://i.loli.net/2019/07/23/5d365e4b03f0020602.png" alt=""></p>
<p>在响应内容中：</p>
<ul>
<li>
<p><code>pretty</code>显示为格式化后的json</p>
</li>
<li>
<p><code>raw</code>是未经处理的数据</p>
</li>
<li>
<p><code>preview</code>可以预览HTML页面</p>
</li>
<li>
<p><code>status</code>为状态码</p>
</li>
</ul>
<h1 id="6使用用例集">6.使用用例集</h1>
<p>postman中可以通过新建<code>Collections</code>的方式来保存测试请求</p>
<h2 id="61-新建用例集">6.1 新建用例集</h2>
<p><img src="https://i.loli.net/2019/07/19/5d313511d1a8180663.png" alt=""></p>
<h2 id="62-添加请求到用例集">6.2 添加请求到用例集</h2>
<p>点击发送请求后的<code>save</code>按钮，保存请求到用例集</p>
<p><img src="https://i.loli.net/2019/07/19/5d3135a1c1aff47874.png" alt=""></p>
<h1 id="7断言">7.断言</h1>
<p>postman中可以为每个请求设置<code>断言</code>，用来判断接口功能是否正常</p>
<h2 id="71-添加断言">7.1 添加断言</h2>
<p>在请求界面中，点击<code>test</code>选项卡，然后在断言输入框中写入断言即可，注意要按<code>ctrl +s</code>保存</p>
<p><img src="https://i.loli.net/2019/07/19/5d31395bc5a2485354.png" alt=""></p>
<h2 id="72-查看断言结果">7.2 查看断言结果</h2>
<p>在响应界面中，点击<code>Test Results</code>可以查看到断言的结果</p>
<p><img src="https://i.loli.net/2019/07/19/5d3139b3199e187114.png" alt=""></p>
<h2 id="73-常用的断言方法">7.3 常用的断言方法</h2>
<pre><code class="language-js">pm.test(&quot;Status code is 200&quot;, function () {
    pm.response.to.have.status(200);
}); //断言状态码是200可以

pm.test(&quot;Body matches string “yunda”&quot;, function () {
    pm.expect(pm.response.text()).to.include(&quot;yunda&quot;);
}); //检查响应主体中是否包含指定字符串

pm.test(&quot;Response time is less than 200ms&quot;, function () {
    pm.expect(pm.response.responseTime).to.be.below(200);
}); //检查响应时间是否小于200ms
</code></pre>
<h1 id="8批量运行用例集">8.批量运行用例集</h1>
<p>用例集创建好并且每个请求都写好断言以后，则可以批量执行用例集，并生成相应的报告</p>
<p>首先点击用例集列表中的箭头，调出批量执行界面，点击<code>run</code></p>
<p><img src="https://i.loli.net/2019/07/19/5d3161067b60254081.png" alt=""></p>
<p>配置执行参数</p>
<p><img src="https://i.loli.net/2019/07/19/5d3161e332ee623513.png" alt=""></p>
<p>执行结果页面</p>
<p><img src="https://i.loli.net/2019/07/19/5d31622bc6e0673691.png" alt=""></p>
<h1 id="9设置环境变量">9.设置环境变量</h1>
<h2 id="91-添加环境变量">9.1 添加环境变量</h2>
<p>在postman中，设置环境变量可以快速变换接口地址</p>
<p>比如分别设置<code>生产环境</code>与<code>测试环境</code>环境变量，之后需要改变接口地址只需切换不同的环境即可</p>
<p><img src="https://i.loli.net/2019/07/19/5d3166b3ec8f688394.png" alt=""></p>
<h2 id="93-切换环境">9.3 切换环境</h2>
<p>在接口请求界面右上角可以切换该接口的环境，</p>
<p>在接口地址使用变量为双花括号包围变量名，如：</p>
<p><code>{{url}}autonumber/autoComNum?resultv2=1&amp;text=3102615141528</code></p>
<p><img src="https://i.loli.net/2019/07/19/5d31681ac9dbb19061.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL  整理]]></title>
        <id>https://yihangliak.github.io/post/mysql-lian-xi</id>
        <link href="https://yihangliak.github.io/post/mysql-lian-xi">
        </link>
        <updated>2019-06-24T02:11:00.000Z</updated>
        <summary type="html"><![CDATA[<p>MySQL -- 最流行的关系型数据库管理系统</p>
]]></summary>
        <content type="html"><![CDATA[<p>MySQL -- 最流行的关系型数据库管理系统</p>
<!-- more -->
<h1 id="准备数据">准备数据</h1>
<p><strong>创建学生表</strong></p>
<pre><code>CREATE TABLE `student`(
	`s_id` VARCHAR(20),
	`s_name` VARCHAR(20) NOT NULL DEFAULT '',
	`s_birth` VARCHAR(20) NOT NULL DEFAULT '',
	`s_sex` VARCHAR(10) NOT NULL DEFAULT '',
	PRIMARY KEY(`s_id`)
);
</code></pre>
<p><strong>创建课程表</strong></p>
<pre><code>CREATE TABLE `course`(
	`c_id` VARCHAR(20),
    `c_name` VARCHAR(20) NOT NULL DEFAULT '',
    `t_id` VARCHAR(20) NOT NULL,
    PRIMARY KEY(`c_id`)
);
</code></pre>
<p><strong>创建教师表</strong></p>
<pre><code>CREATE TABLE `teacher`(
	`t_id` VARCHAR(20),
    `t_name` VARCHAR(20) NOT NULL DEFAULT '',
    PRIMARY KEY(`t_id`)
);
</code></pre>
<p><strong>创建成绩表</strong></p>
<pre><code>CREATE TABLE `score`(
	`s_id` VARCHAR(20),
    `c_id` VARCHAR(20),
    `s_score` INT(3),
    PRIMARY KEY(`s_id`, `c_id`)
);
</code></pre>
<p><strong>在学生表中插入数据</strong></p>
<pre><code>insert into student values('01', '赵雷', '1990-01-01', '男');
insert into student values('02' , '钱电' , '1990-12-21' , '男');
insert into student values('03' , '孙风' , '1990-05-20' , '男');
insert into student values('04' , '李云' , '1990-08-06' , '男');
insert into student values('05' , '周梅' , '1991-12-01' , '女');
insert into student values('06' , '吴兰' , '1992-03-01' , '女');
insert into student values('07' , '郑竹' , '1989-07-01' , '女');
insert into student values('08' , '王菊' , '1990-01-20' , '女');

</code></pre>
<p><strong>在课程表中插入数据</strong></p>
<pre><code>insert into course values('01' , '语文' , '02');
insert into course values('02' , '数学' , '01');
insert into course values('03' , '英语' , '03');
</code></pre>
<p><strong>在教师表中插入数据</strong></p>
<pre><code>insert into teacher values('01' , '张三');
insert into teacher values('02' , '李四');
insert into teacher values('03' , '王五');
</code></pre>
<p><strong>在成绩表中插入数据</strong></p>
<pre><code>insert into score values('01' , '01' , 80);
insert into score values('01' , '02' , 90);
insert into score values('01' , '03' , 99);
insert into score values('02' , '01' , 70);
insert into score values('02' , '02' , 60);
insert into score values('02' , '03' , 80);
insert into score values('03' , '01' , 80);
insert into score values('03' , '02' , 80);
insert into score values('03' , '03' , 80);
insert into score values('04' , '01' , 50);
insert into score values('04' , '02' , 30);
insert into score values('04' , '03' , 20);
insert into score values('05' , '01' , 76);
insert into score values('05' , '02' , 87);
insert into score values('06' , '01' , 31);
insert into score values('06' , '03' , 34);
insert into score values('07' , '02' , 89);
insert into score values('07' , '03' , 98);
</code></pre>
<p><strong>最终数据结构</strong></p>
<p><img src="https://i.loli.net/2019/06/24/5d1047a00429076901.png" alt=""></p>
<h1 id="练习">练习</h1>
<ol>
<li>查询<code>01</code>课程比<code>02</code>课程成绩高的学生的信息及课程分数</li>
</ol>
<pre><code>select a.* ,b.s_score as 01_score,c.s_score as 02_score from student a join
score b on a.s_id=b.s_id and b.c_id='01'left join score c on a.s_id=c.s_id 
and c.c_id='02' or c.c_id = NULL where b.s_score&gt;c.s_score;
</code></pre>
<ol start="2">
<li>查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</li>
</ol>
<pre><code>select b.s_id,b.s_name,ROUND(AVG(a.s_score),2) as avg_score from student b
join score a on b.s_id=a.s_id GROUP BY b.s_id HAVING avg_score&gt;=60;
</code></pre>
<ol start="3">
<li>查询平均成绩小于60的同学的学生编号和学生姓名和平均成绩</li>
</ol>
<pre><code>SELECT b.s_id,b.s_name,AVG(a.s_score) as avg_score FROM student
b join score a ON b.s_id=a.s_id GROUP BY b.s_id HAVING avg_score&lt;=60;
</code></pre>
<ol start="4">
<li>查询所有同学的编号，姓名，选课总数，所有课程总成绩</li>
</ol>
<pre><code>SELECT a.s_id,a.s_name,COUNT(b.c_id) as sum_course,SUM(b.s_score) as
sum_score FROM student a JOIN score b ON a.s_id=b.s_id GROUP BY a.s_id;
</code></pre>
<ol start="5">
<li>查询姓<code>李</code>的老师的数量</li>
</ol>
<pre><code>SELECT COUNT(t_id) FROM teacher t WHERE t_name LIKE '李%'; 
</code></pre>
<ol start="6">
<li>查询学过<code>张三</code>老师课程的所有同学的信息</li>
</ol>
<pre><code>SELECT a.* FROM student a JOIN score b ON a.s_id=b.s_idWHERE b.c_id
IN(SELECT c_id FROM course WHERE t_id=(SELECT t_id FROM teacher WHERE
t_name='张三'));
</code></pre>
<ol start="7">
<li>查询没有学过<code>张三</code>老师课程的所有同学的信息</li>
</ol>
<pre><code>SELECT * FROM student c WHERE c.s_id NOT IN( SELECT a.s_id from student a 
JOIN score b on a.s_id=b.s_id WHERE b.c_id IN( SELECT a.c_id FROM course a
JOIN teacher b ON a.t_id=b.t_id WHERE t_name='张三' ) )
</code></pre>
<ol start="8">
<li>查询每个学生姓名的人数</li>
</ol>
<pre><code>SELECT s_name,COUNT(*) FROM student GROUP BY s_name;
</code></pre>
<ol start="9">
<li>查询没有<code>学全</code>所有课程的同学的信息</li>
</ol>
<pre><code>SELECT s.* FROM student s 
LEFT JOIN score s1 ON s.s_id=s1.s_id 
GROUP BY s.s_id 
HAVING COUNT(s1.c_id) &lt; (SELECT COUNT(*) FROM course);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进入Flask世界！ ]]></title>
        <id>https://yihangliak.github.io/post/flask-chao-qing-dao-wu-fa-xiang-xiang</id>
        <link href="https://yihangliak.github.io/post/flask-chao-qing-dao-wu-fa-xiang-xiang">
        </link>
        <updated>2019-06-21T08:44:53.000Z</updated>
        <summary type="html"><![CDATA[<p>Flask 是一个 Python 实现的 Web 开发微框架。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Flask 是一个 Python 实现的 Web 开发微框架。</p>
<!-- more -->
<h1 id="flask简介">Flask简介</h1>
<blockquote>
<p>Flask是一个使用<code>Python</code>编写的轻量级web应用框架<br>
WSGI工具箱采用<code>Werzeug</code>，模板引擎使用<code>Jinjia2</code></p>
</blockquote>
<h1 id="进入flask世界">进入Flask世界</h1>
<h2 id="1安装python">1.安装Python</h2>
<p>略</p>
<h2 id="2安装python虚拟环境">2.安装Python虚拟环境</h2>
<p>Python虚拟环境常用命令</p>
<pre><code>安装virtualenv  pip install virtualenv
安装虚拟环境管理工具  virtualenvwrapper-win（Windows系统） 
创建虚拟环境：mkvirtualenv   xxx
切换到某个虚拟环境：workon xxx
退出当前虚拟环境：deactivate xxx
删除某个虚拟环境：rmvirtualenv  xxx
列出所有虚拟环境：lsvirtualenv
进入虚拟环境目录：cdvirtualenv
</code></pre>
<p>在虚拟环境中安装Flask</p>
<pre><code>cmd中：
1.首先切换到已经创建好的虚拟环境
2.输入：pip install flask
</code></pre>
<h1 id="url与视图">URL与视图</h1>
<h2 id="1服务器解释">1.服务器解释</h2>
<p><img src="https://i.loli.net/2019/06/05/5cf698581159673776.png" alt=""></p>
<h2 id="2第一个flask程序">2.第一个Flask程序</h2>
<p>Flask的优势：</p>
<ul>
<li>微型框架，简洁，扩展性强</li>
<li>flask相关依赖非常优秀（jinja2）</li>
<li>开发效率高</li>
<li>社会活跃度高</li>
</ul>
<p>新建一个first_flask_project.py文件</p>
<pre><code class="language-python">from flask import Flask #导入Flask类

from demo import config

app = Flask(__name__)  # 实例化Flask

@app.route('/')   # URL映射到对应视图函数
def hello_world():
    return 'Hello World!'


if __name__=='__main__':
    app.run(debug=True, port=81) # 测试使用的应用服务器


</code></pre>
<p>执行这个py文件</p>
<p><img src="https://i.loli.net/2019/06/05/5cf69949b9fd033530.png" alt=""></p>
<p>浏览器访问hello_world视图函数对应的网址</p>
<p><img src="https://i.loli.net/2019/06/05/5cf6998ce1e2a79941.png" alt=""></p>
<h2 id="3dubug模式">3.DUBUG模式</h2>
<h3 id="31-为什么要开启dubug模式">3.1 为什么要开启DUBUG模式</h3>
<ul>
<li>代码抛出异常后，在浏览器中可以看到错误信息</li>
<li>更新代码以后，只要保存就会使代码自动生效</li>
</ul>
<h3 id="32-开启debug模式的4种方式">3.2 开启DEBUG模式的4种方式</h3>
<p>第一种：在app.run()中传递一个debug=True参数</p>
<pre><code class="language-python">if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
<p>第二种：使用app.debug=True</p>
<pre><code class="language-python">app = Flask(__name__)  
app.debug = True
</code></pre>
<p>第三种：使用update方法，以字典追加的形式将debug参数加到config字典中</p>
<pre><code class="language-python">app = Flask(__name__) 
app.config.update(DEBUG=True)
print(isinstance(app.config, dict))  # 确认config是否是字典
</code></pre>
<p>第四种：加载配置文件的形式</p>
<ul>
<li>
<p>创建一个配置文件，再以模块形式导入</p>
</li>
<li>
<p><img src="https://i.loli.net/2019/06/05/5cf69af23e58681823.png" alt=""></p>
<pre><code class="language-python">from demo import config

app = Flask(__name__)  
app.config.from_object(config)
</code></pre>
</li>
<li>
<p>导入配置文件的形式加载配置</p>
<pre><code class="language-python">from flask import Flask 

app = Flask(__name__)  
app.config.from_pyfile('config.py') # 这样可以少些一行倒模块方法
# 注意要写文件全名（包含文件路径）
# 不仅仅是py文件，其他格式文件也可以
# 这里还有一个silent参数，设为True的话，即使文件不存在也不会报错
</code></pre>
</li>
</ul>
<h2 id="4-url的传参方式">4. URL的传参方式</h2>
<ul>
<li>视图函数上面的装饰器中URL的传参语法为：<code>/&lt;参数名&gt;</code></li>
</ul>
<blockquote>
<p>视图函数中要定义同名参数</p>
</blockquote>
<ul>
<li>
<p>举例，新增一个url_view.py文件，url为文章详情页面</p>
</li>
<li>
<pre><code class="language-python">from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World'

@app.route('/p/&lt;articel_id&gt;')
def article_detail(articel_id):  # 在视图函数中也要定义同名参数
    return '您请求的文章是：{}'.format(articel_id)

if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
</li>
</ul>
<h2 id="5url参数的数据类型">5.URL参数的数据类型</h2>
<p>1.如果没有指定具体的数据类型,那么就是使用<code>string</code>类型</p>
<p>2.<code>int</code>类型只能传递整数类型</p>
<ul>
<li>
<pre><code>@app.route('/article/&lt;int:test&gt;')
</code></pre>
</li>
</ul>
<p>3.<code>float</code>传递浮点型数据</p>
<p>4.<code>path</code>数据类型和<code>string</code>类型都可以接受任意的字符串,但是path可以接收路径,也就是说可以包含斜杠</p>
<pre><code class="language-python">@app.route('/article/&lt;path:test&gt;')
def page_detail(test):
    return '您请求的页面是:{}'.format(test)
</code></pre>
<p>请求之后的页面：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8cf06db0f727689.png" alt=""></p>
<p>5.uuid：接受符合<code>uuid</code>规则的字符串，全宇宙唯一，缺点就是太长了，一般用来做表的主键</p>
<p>先导包生成一个uuid</p>
<pre><code class="language-python">import uuid

print(uuid.uuid4())
</code></pre>
<p>在URL对应的视图函数中验证</p>
<pre><code class="language-python">@app.route('/u/&lt;uuid:user_id&gt;')
def user_detail(user_id):
    return '用户的uuid为：%s' %user_id
</code></pre>
<p>效果图</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8d2853c4ba94451.png" alt=""></p>
<p>6.any：多个URL映射到同一个视图函数</p>
<p>代码</p>
<pre><code class="language-python">@app.route('/&lt;any(user,blog):url_path&gt;/&lt;id&gt;/')
def detail(url_path, id):
    if url_path == 'user':
        return '用户id是：%s' %id
    else:
        return '博客详情是：%s' %id
</code></pre>
<p>验证<img src="https://i.loli.net/2019/06/06/5cf8d4b30d41953293.png" alt=""></p>
<h2 id="6接收用户传递的参数">6.接收用户传递的参数</h2>
<p>第一种：使用path形式（将参数嵌入到路径中）（就是上面说的）</p>
<p>第二种：使用查询字符串的方式，就是通过<code>?key=value</code>形式传递</p>
<p>代码：</p>
<pre><code class="language-python">@app.route('/d/')
def d():
    wd = request.args.get('wd')  # 注意到导入request
    return '通过字符串传递的参数是：%s' %wd
</code></pre>
<p>验证</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8dad77772c11673.png" alt=""></p>
<p>如果有多个键值对做为参数时，使用<code>&amp;</code>符号进行分割</p>
<p>实例</p>
<pre><code class="language-python">@app.route('/d/')
def d():
    wd = request.args.get('wd')
    ie = request.args.get('ie')  # 多个参数再写一个请求即可
    return '通过字符串传递的参数是：wd=%s,ie=%s' %(wd,ie)
</code></pre>
<p><img src="https://i.loli.net/2019/06/06/5cf8dbe03246a52713.png" alt=""></p>
<p><mark>如果页面想要做SEO优化，就是被搜索引擎搜索到，那么推荐使用第一种（path）传递方式，如果不在乎SEO，则可以使用第二种</mark></p>
<h2 id="7-url_for">7. url_for</h2>
<p>url_for第一个参数，应该是视图函数的名字的字符串，后面的参数传递给url</p>
<h2 id="8自定义url转换器">8.自定义URL转换器</h2>
<p>1.定义一个类，集成<code>BaseConverter</code></p>
<p>2.在这个类中，重写<code>regex</code>，也就是正则表达式</p>
<p>3.将自定义好的类，映射到<code>app.url_map.converters</code>上</p>
<pre><code class="language-python">from flask import Flask
from werkzeug.routing import BaseConverter

app = Flask(__name__)

# 定义自己的参数转换器，匹配手机号
class TelephoneConverter(BaseConverter):
    regex = r'1[85734]\d{9}'

app.url_map.converters['tel'] = TelephoneConverter # 将自定转换器添加到url_map中（字典方式添加）

@app.route('/')
def hello():
    return 'hello world'

@app.route('/user/&lt;int:user_id&gt;/')   # 自带url转换器
def user_profile(user_id):
    return '您输入的user_id为%s' %user_id

@app.route('/telephone/&lt;tel:user_phone&gt;/')   # 使用自定义url转换器
def user_phone(user_phone):
    return '您的手机号为：%s' %user_phone

if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
<p>to_python的作用：这个方法的返回值，将会传递到view函数中作为参数</p>
<pre><code class="language-python">class ListConverter(BaseConverter):
    def to_python(self, value):
        return value.split('+')
app.url_map.converters['list'] = ListConverter

@app.route('/post/&lt;list:borads&gt;/')
def posts(borads):
    return '您提交的版块是：%s' %borads
</code></pre>
<p>to_url的作用：这个方法的返回值，将会调用url_for函数的时候生成符合要求的url形式</p>
<h2 id="9其他细节知识点">9.其他细节知识点</h2>
<h3 id="91-其他电脑访问">9.1 其他电脑访问</h3>
<p>如果想在同一个局域网下让其他电脑访问本机上的flask网站</p>
<p>要设置<code>host=0.0.0.0</code>才能访问得到</p>
<h3 id="92-指定端口">9.2 指定端口</h3>
<p>设置<code>port=端口号</code></p>
<h3 id="93-url唯一">9.3 URL唯一</h3>
<p>在定义URL时，一定要记得在最后加一个斜杠</p>
<ul>
<li>如果不加斜杠，那么在浏览器中访问这个url时，如果加了斜杠就会访问不到，这样用户体验不好</li>
<li>搜索引擎会将加与不加的视为两个不同的URL，其实两个都是同一个URL，会给搜索引擎造成误解</li>
</ul>
<p>代码里面加了斜杠以后，访问时 加与不加 都可以访问</p>
<h3 id="94-请求方式">9.4 请求方式</h3>
<p>flask中的route方法，默认使用get请求</p>
<p>如果想要自定义请求方式，那么应该传递一个<code>method</code>参数</p>
<pre><code class="language-python">@app.route('/list/', methods=['GET', 'POST'])
def list():
    return 'hi'
</code></pre>
<h2 id="10页面跳转和重定向">10.页面跳转和重定向</h2>
<p>重定向分为永久性重定向和暂时性重定向，在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面</p>
<p>比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面</p>
<ul>
<li>永久性重定向：<code>http</code>的状态码是<code>301</code>，多用于旧网址被废弃了要转到一个新的网址确保用户的访问</li>
<li>暂时性重定向，<code>http</code>的状态码是<code>302</code>，表示页面的暂时性跳转。比如一个需要权限的网址，如果当前用户没有登录，应该重定向登录页面，这种情况下，应该暂时性重定向</li>
</ul>
<p>在flask中，重定向是通过<code>flask.redirect(location, code=302)</code>这个函数来实现的，<code>location</code>表示需要重定向到的URL，应该配合之前的<code>url_for</code>函数来使用，<code>code</code>表示采用哪个重定向，默认是<code>302</code>，即<code>暂时性重定向</code>，也可以修改成<code>301</code>来实现永久性重定向</p>
<p>代码案例：</p>
<pre><code class="language-python">from flask import Flask, request, url_for
from werkzeug.utils import redirect

app = Flask(__name__)

@app.route('/')
def hello():
    return 'hello world'

@app.route('/login/')
def login():
    return '这是登录页面'

@app.route('/profile/')   # 个人中心视图函数
def profile():
    if request.args.get('name'):  # 使用request检查url中是否有name参数
        return '个人中心页面'
    else:
        return redirect(url_for('login'))  # 使用redirect+url_for重定向url，注意，可以定义code参数，默认302即暂时性重定向

if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
<p>访问profile在没有加name参数的情况下会自动暂时性重定向到登录页面</p>
<p><img src="https://i.loli.net/2019/06/11/5cff5e9c07a6469200.gif" alt=""></p>
<p>访问profile加了name参数以后，正常访问到个人中心页面</p>
<p><img src="https://i.loli.net/2019/06/11/5cff5f0d7c57687406.png" alt=""></p>
<h2 id="11关于响应response">11.关于响应（Response）</h2>
<p>视图函数的返回值会被自动转换为一个响应对象，flask的转换逻辑如下：</p>
<ul>
<li>如果返回的是一个合法的响应对象，则直接返回</li>
<li>如果返回的是一个字符串，那么flask会重新创建一个<code>werkzeug.wrappers.Response</code>对象，<code>Response</code>对象将该字符串作为主体，状态码为<code>200</code>，<code>MIME</code>类型为<code>text/html</code>，然后返回该<code>Response</code>对象</li>
<li>如果返回的是一个元祖，元祖中的数据类型是（response,status,headers）。status值会覆盖默认的200状态码，headers可以是一个列表或者字典，作为额外的消息头</li>
<li>如果以上条件都不满足，flask会假设返回值是一个合法的<code>WSGI</code>应用程序，并通过<code>Response.force_type(rv,request,environ)</code>转换为一个请求对象</li>
</ul>
<blockquote>
<p>第一个例子，直接使用<code>Response</code>创建：</p>
</blockquote>
<pre><code class="language-python">from flask import Flask, Response

@app.route('/about/')
def about():
    resp = Response(response='about page', status=200, content_type='text/html;charset=utf-8')
    return resp
</code></pre>
<blockquote>
<p>第二个例子，使用<code>字符串</code>创建：</p>
</blockquote>
<pre><code class="language-python">@app.route('/')
def hello():
    return 'hello world' # 直接返回字符串，flask也会自动组装成一个Response对象返回
</code></pre>
<blockquote>
<p>第三个例子，使用<code>元祖</code>创建：</p>
</blockquote>
<pre><code class="language-python">@app.route('/about2/')
def about2():
    return 'about2',200,{'X-NAME':'Alex'}
</code></pre>
<p><img src="https://i.loli.net/2019/06/12/5d00680c5542521648.png" alt=""></p>
<blockquote>
<p>第四个例子，<code>自定义响应</code>，自定义响应必须满足三个条件：</p>
</blockquote>
<ul>
<li>必须继承自<code>Respone</code>类</li>
<li>实现类方法<code>force_type(cls,rv,nviron=None)</code></li>
<li>必须指定<code>app.respone_class</code>为你自定义的<code>Respone</code></li>
</ul>
<p><code>Restful API</code>都是通过<code>json</code>的形式进行传递，如果你的后台跟前台进行交互，所有的<code>URL</code>参数都是发送<code>json</code>数据，那么此时，可以定义一个叫做<code>JSONResponse</code>的类来代替<code>Response</code>类</p>
<pre><code class="language-python">from flask import Flask, Response, jsonify

# 将视图函数中返回的字典，转换成json对象，然后返回
class JSONResponse(Response):
    @classmethod
    def force_type(cls, response, environ=None):
        if isinstance(response, dict):
            response = jsonify(response)
        return super(JSONResponse, cls).force_type(response,environ)

app.response_class = JSONResponse

@app.route('/json/')
def json_response():
    return {'username':'alex'}
</code></pre>
<p><img src="https://i.loli.net/2019/06/12/5d0099fd2a97e99449.png" alt=""></p>
<h1 id="jinja2模板">Jinja2模板</h1>
<h2 id="1模板基础">1.模板基础</h2>
<p>在渲染模板的时候，默认会从项目根目录下的<code>templates</code>目录下查找模板</p>
<p>如果不想把模板文件放在<code>templates</code>目录下，那么可以在<code>Flask</code>初始化的时候给<code>template_folder</code>参数传值，来指定模板的路径</p>
<blockquote>
<p>在默认模板目录下查找模板</p>
</blockquote>
<pre><code class="language-python">from flask import Flask, render_template

@app.route('/')
def hello():
    return render_template('index.html')  # 在templates目录下查找模板
</code></pre>
<h2 id="2模板参数">2.模板参数</h2>
<p>在使用<code>render_template</code>渲染模板的时候，可以传递关键字参数，以后直接在模板中使用就可以了</p>
<p>如果参数过多，那么可以将所有的参数放到一个字典中，然后在传这个字典参数的时候，使用两个星号，将字典中的数据组成关键字参数传递</p>
<blockquote>
<p>举例</p>
</blockquote>
<p>视图函数中渲染模板传递参数：</p>
<pre><code class="language-python">@app.route('/')
def hello():
    context = {
        'username':'alex',
        'tel':17688165555
    }
    return render_template('index.html',**context)
</code></pre>
<p><code>HTML</code>中调用<code>视图函数</code>中的参数</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;alex&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;这是模板渲染的数据&lt;/h1&gt;
    &lt;p&gt;{{username}}&lt;/p&gt;  &lt;!-- 调用视图函数中的参数 --&gt;
    &lt;p&gt;{{tel}}&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3模板中的url_for">3.模板中的url_for</h2>
<p>模板中的<code>url_for</code>与后台视图函数中的使用基本是一致的</p>
<p>也是传递视图函数的名字，也可以传递参数</p>
<blockquote>
<p>注意：在模板中使用url_for需要在左右两边加上一对花括号，{{ url_for() }}</p>
</blockquote>
<p>举例：</p>
<p>在首页模板中添加一个<code>登录</code>链接</p>
<blockquote>
<p>在这个首页模板中使用<code>url_for</code>来与login视图函数对应</p>
<p>这个的好处就是，一旦视图函数的url变化，模板中使用url的地方会相应变化</p>
</blockquote>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt; &lt;a href=&quot;{{ url_for('login')}}&quot;&gt;登录&lt;/a&gt; &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>然后新建一个<code>login</code>模板</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;alex&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;这是登录页面&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>新建一个<code>login</code>视图函数</p>
<pre><code class="language-python">from flask import Flask, render_template, url_for

app = Flask(__name__)


@app.route('/')
def hello():
    context = {
        'username':'alex',
        'tel':17688165555
    }
    return render_template('index.html',**context)

@app.route('/login/')
def login():
    # url_for('login')
    return render_template('login.html')

if __name__ == '__main__':
    app.run(debug=True, port=81)

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Selenium 从入门到实战]]></title>
        <id>https://yihangliak.github.io/post/selenium-cong-ru-men-dao-shi-zhan</id>
        <link href="https://yihangliak.github.io/post/selenium-cong-ru-men-dao-shi-zhan">
        </link>
        <updated>2019-06-21T03:29:54.000Z</updated>
        <summary type="html"><![CDATA[<p>Selenium是一个用于Web应用程序自动化测试工具</p>
]]></summary>
        <content type="html"><![CDATA[<p>Selenium是一个用于Web应用程序自动化测试工具</p>
<!-- more -->
<h1 id="第一章-自动化环境搭建">第一章  自动化环境搭建</h1>
<h2 id="1安装python3">1.安装Python3</h2>
<ul>
<li>安装好Python3</li>
<li>配置好环境变量</li>
</ul>
<h2 id="2安装selenium">2.安装Selenium</h2>
<ul>
<li>
<p>win+r，打开命令行窗口</p>
</li>
<li>
<p>使用pip安装Selenium</p>
<pre><code>  # 安装Selenium的最新版本
  pip install selenium

  # 安装Selenium指定版本
  pip install selenium==2.53.0
</code></pre>
</li>
</ul>
<h2 id="3下载webdriver驱动">3.下载webdriver驱动</h2>
<ul>
<li>以chrome浏览器为例</li>
<li>查看chrome浏览器版本：在地址栏输入<code>chrome://version</code></li>
</ul>
<p><img src="https://i.loli.net/2018/12/21/5c1c98f627bb7.png" alt="查看chrome版本"></p>
<ul>
<li>chromedriver下载地址：http://chromedriver.storage.googleapis.com/index.html</li>
<li>淘宝镜像站：http://npm.taobao.org/mirrors/chromedriver/</li>
<li>下载与浏览器版本对应的chrome driver</li>
<li>将下载好的chrome driver 解压，并放至到Python安装路径的根目录</li>
</ul>
<h2 id="4第一个自动化测试脚本">4.第一个自动化测试脚本</h2>
<ul>
<li>需求
<ul>
<li>打开浏览器</li>
<li>访问百度首页</li>
</ul>
</li>
</ul>
<pre><code class="language-python">from selenium import webdriver   # 导入webdriver

d = webdriver.Chrome()           # 创建浏览器对象
d.get('https://www.baidu.com')   # 调用get方法访问百度首页

d.close()                        # 关闭浏览器
</code></pre>
<h1 id="第二章-webdriver-api">第二章  webdriver API</h1>
<h2 id="1浏览器操作">1.浏览器操作</h2>
<h3 id="11浏览器最大化">1.1浏览器最大化</h3>
<ul>
<li>
<p><code>driver.maximize_window()</code></p>
</li>
<li>
<p>在统一的浏览器大小下运行用例，可以提高用例的适用性</p>
</li>
</ul>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

print('浏览器最大化')
driver.maximize_window()
driver.close()
</code></pre>
<h3 id="12-设置浏览器宽-高">1.2 设置浏览器宽、高</h3>
<ul>
<li>在不同浏览器大小下运行用例，可以对缩放、样式等进行评估</li>
<li><code>driver.set_window_size(480, 800)</code></li>
</ul>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

print('设置浏览器宽480，高800显示')
driver.set_window_size(480, 800)

sleep(2)
driver.close()
</code></pre>
<h3 id="13-控制浏览器前进-后退">1.3 控制浏览器前进、后退</h3>
<ul>
<li>前进：<code>driver.forward()</code></li>
<li>后退：<code>driver.back()</code></li>
</ul>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()

#访问百度首页
driver.get('https://www.baidu.com')
#访问百度新闻
driver.find_element_by_link_text('新闻').click()
#暂停1秒
sleep(1)
#后退到百度首页
driver.back()
#暂停1秒
sleep(1)
#前进到百度新闻
driver.forward()
#暂停1秒
sleep(1)

#关闭浏览器
driver.close()
</code></pre>
<h3 id="14-关闭浏览器">1.4 关闭浏览器</h3>
<ul>
<li>关闭当前窗口：<code>driver.close()</code></li>
<li>关闭浏览器：<code>driver.quit()</code></li>
</ul>
<h3 id="15-浏览器刷新">1.5 浏览器刷新</h3>
<ul>
<li><code>driver.refresh()</code></li>
</ul>
<h3 id="16-获取当前url">1.6 获取当前URL</h3>
<ul>
<li>
<p><code>driver.current_url</code></p>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 获取当前页面的URL
url = driver.current_url
print(url)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code>https://www.baidu.com/
</code></pre>
</li>
</ul>
<h3 id="17-获取当前title">1.7 获取当前title</h3>
<ul>
<li>
<p><code>driver.title</code></p>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

title = driver.title
print(title)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code>百度一下，你就知道
</code></pre>
</li>
</ul>
<h3 id="18-浏览器截图">1.8 浏览器截图</h3>
<ul>
<li>
<p><code>driver.save_screenshot()</code></p>
<ul>
<li>路径参数必填</li>
<li>图片格式必须为png</li>
</ul>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 截图并保存到当前路径下，名字为s1.png
driver.save_screenshot('s1.png')

# 关闭浏览器
driver.close()
</code></pre>
<h2 id="2html基础">2.HTML基础</h2>
</li>
</ul>
<h3 id="21-什么是html">2.1 什么是HTML</h3>
<ul>
<li>HTML：超文本标记语言（Hyper Text Markup Language）</li>
<li>HTML使用标记标签来描述网页</li>
</ul>
<h3 id="22-html标签">2.2 HTML标签</h3>
<ul>
<li>标签由尖括号包围</li>
<li>标签是成对出现的</li>
<li>标签对中：第一个为开始标签，第二个为结束标签</li>
</ul>
<h3 id="23-第一个网页">2.3 第一个网页</h3>
<pre><code class="language-html">&lt;html&gt;
    &lt;body&gt;
        &lt;h1&gt;我的第一个标题&lt;/h1&gt;
        &lt;p&gt;我的第一个段落&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="24-元素常见的属性">2.4 元素常见的属性</h3>
<ul>
<li>class：元素的类名</li>
<li>id：元素的唯一id</li>
<li>name：元素名，大部分情况唯一</li>
</ul>
<h3 id="25-常见的标签">2.5 常见的标签</h3>
<ul>
<li><code>&lt;a&gt;</code>：超链接</li>
<li><code>&lt;input&gt;</code>：输入标签，如输入框，按钮等</li>
<li><code>&lt;div&gt;</code>：块级元素，把文档分割为独立的、不同的部分</li>
<li><code>&lt;form&gt;</code>：为用户输入创建HTML表单</li>
<li><code>&lt;img&gt;</code>：图片</li>
<li><code>&lt;iframe&gt;</code>：定义内嵌框架，在一个HTML中嵌入另一个HTML（QQ邮箱）</li>
<li><code>&lt;span&gt;</code>：组合行内元素</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
    &lt;body&gt;
        &lt;h1&gt;我的第一个标题&lt;/h1&gt;
        &lt;p&gt;我的第一个段落&lt;/p&gt;
        &lt;form&gt;
            账号
            &lt;input type=&quot;text&quot; name=&quot;uaername&quot;&gt;
            &lt;/br&gt;
            密码
            &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3元素定位">3.元素定位</h2>
<ul>
<li>元素定位和操作是自动化测试的核心部分</li>
<li>一个元素就像一个人，有自己的特征（属性）</li>
<li>webdriver提供了一系列的元素定位方法，常用的有下面几种：
<ul>
<li>id：根据元素id值</li>
<li>name：根据元素name值</li>
<li>class name：根据元素class值</li>
<li>tag name：根据元素标签名字</li>
<li>link text：根据超链接的文本内容</li>
<li>partial link text：根据超链接的部分文本内容</li>
<li>xpath：根据xpath</li>
<li>css selector：通过css定位</li>
</ul>
</li>
</ul>
<h3 id="31-id和name定位">3.1 id和name定位</h3>
<ul>
<li>id：规定元素的唯一id</li>
<li><code>driver.find_element_by_id('su')</code></li>
<li><code>driver.find_element_by_name('wd')</code></li>
</ul>
<pre><code class="language-html"># 百度搜索框元素
&lt;input id=&quot;kw&quot; name=&quot;wd&quot; class=&quot;s_ipt&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt;

# 搜索按钮元素
&lt;input type=&quot;submit&quot; id=&quot;su&quot; value=&quot;百度一下&quot; class=&quot;bg s_btn&quot;&gt;
</code></pre>
<ul>
<li>根据id定位搜索框，根据name定位到搜索按钮</li>
</ul>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

driver.maximize_window()

# 根据id定位到百度搜索框,并输入Selenium
driver.find_element_by_name('wd').send_keys('Selenium')

# 根据name定位到搜索按钮，并点击
driver.find_element_by_id('su').click()

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
<h3 id="32-tag-name和class-name定位">3.2 tag name和class name定位</h3>
<p>HTML文本</p>
<pre><code class="language-html">&lt;div id=&quot;searchform&quot; class=&quot;jhp_big&quot; style=&quot;margin-top:-2px&quot;&gt;
&lt;form id=&quot;tsf&quot; onsubmit=&quot;return name=&quot;f&quot; method=&quot;GET&quot; action=&quot;/search&quot;&gt;
&lt;input id=&quot;kw&quot; class=&quot;s_ipt&quot; type=&quot;text&quot; name=&quot;wd&quot; autocomplete=&quot;off&quot;&gt;
</code></pre>
<ul>
<li>tag name
<ul>
<li>通过标签名定位</li>
<li>不推荐使用，因为HTML文件中有很多同名的标签名，不唯一</li>
</ul>
</li>
</ul>
<pre><code class="language-python">&lt;div&gt;
find_element_by_tag_name('div')
</code></pre>
<ul>
<li>class name：直接访问百度首页讲解，可以通过class name定位到输入框</li>
</ul>
<pre><code>class=&quot;s_ipt&quot;
find_element_by_class_name('s_ipt')
</code></pre>
<h3 id="33-link-text和partial-link-text定位">3.3 link text和partial link text定位</h3>
<ul>
<li>根据链接文本定位：<code>driver.find_element_by_link_text('新闻')</code></li>
<li>根据链接部分文本定位：<code>driver.find_element_by_partial_link_text('央视快评')</code></li>
<li>根据超链接中的文本内容定位</li>
</ul>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 根据link_text定位到百度新闻超链接，并点击
driver.find_element_by_link_text('新闻').click()
# 暂停1秒
sleep(1)
# 在新闻新闻页面，根据一条新闻链接的部分文本定位，并点击
driver.find_element_by_partial_link_text('央视快评').click()
# 暂停1秒
sleep(1)

# 关闭浏览器,quit关闭所有浏览器窗口
driver.quit()
</code></pre>
<h3 id="34-xpath定位">3.4 XPath定位</h3>
<ul>
<li>
<p>XPath是一种在XML文档中定位元素的语言，有多种可能性</p>
</li>
<li>
<p>语法</p>
<ul>
<li><code>/</code>：从根节点选取（绝对路径）</li>
<li><code>//</code>：从当前节点选取，不考虑节点的位置（相对路径）</li>
<li><code>.</code>：选取当前节点</li>
<li><code>..</code>：选取当前节点的父节点    搜索框的上两级父节点：<code>//*[@id='kw']/../..</code></li>
<li><code>@</code>：选取属性</li>
</ul>
</li>
<li>
<p>绝对路径定位上面文档中的输入框</p>
<ul>
<li>不推荐使用绝对路径定位</li>
<li>难以阅读和维护</li>
</ul>
</li>
<li>
<p>xpath定位元素时，元素没有属性，可以定位他的父节点再定位到他本身</p>
</li>
</ul>
<blockquote>
<p>注意：如果一个元素本身没有任何属性值，则可以通过xapth定位到它的父级元素再定位到它自己</p>
</blockquote>
<p><code>案例：</code><br>
使用<code>绝对路径</code>定位百度首页输入框：<code>/html/body/div/div/div/div/div/form/span/input</code><br>
使用<code>相对路径</code>定位百度首页输入框：<code>//input[@id=&quot;kw&quot;]</code><br>
当子节点有多个<code>同名</code>标签时，可以用[数字]的方法按顺序选取元素：<code>//input[@id=&quot;kw&quot;]/input[2]</code>  (选取百度首页输入框下的第二个input)</p>
<pre><code>百度搜索框：//*[@id=&quot;form&quot;]/span/input
</code></pre>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 通过绝对路径定位到输入框，并且输入selenium
driver.find_element_by_xpath(&quot;/html/body/div/div/div/div/div/form/span/input&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
<ul>
<li>相对路径定位上面文档中的输入框</li>
</ul>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 通过相对路径定位到输入框，并且输入selenium
# // 从当前节点选取
# *：匹配任何标签
# @：选取id属性为kw的节点
# 另一种写法：//input[@id='kw']
driver.find_element_by_xpath(&quot;//*[@id='kw']&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
<h3 id="35-css定位">3.5 CSS定位</h3>
<ul>
<li>
<p>语法</p>
<ul>
<li><code>#</code>：元素id属性选取，如 #kw：id为kw的元素</li>
<li><code>.</code>：元素class属性选取，如 .s_ipt：class值为s_ipt的元素</li>
<li><code>[]</code>：其他属性选取，如 [id='kw']</li>
<li>层级关系选取，如 #form &gt; span:nth-of-type(1) &gt;input
<ul>
<li>第几个span用“span:nth-of-type(n)”表示</li>
</ul>
</li>
</ul>
</li>
<li>
<p>范例</p>
<ul>
<li>
<p><code>#</code>：元素id属性选取</p>
</li>
<li>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 使用# 通过id属性定位到百度首页搜索框，并输入selenium
driver.find_element_by_css_selector(&quot;#kw&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code class="language-python">
from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 使用. 通过class值定位百度首页搜索框，并输入selenium
driver.find_element_by_css_selector(&quot;.s_ipt&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()

</code></pre>
</li>
<li>
<p><code>[]</code>：其他属性选取</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 使用[] 通过id属性定位百度首页搜索框，并输入selenium
driver.find_element_by_css_selector(&quot;[id='kw']&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
</li>
<li>
<p>层级关系选取</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# css层级关系定位
# 首先通过id属性定位到form
# 然后定位form里面的第一个span
# 最后再span的子节点input为最终选取的节点
driver.find_element_by_css_selector(&quot;#form &gt; span:nth-of-type(1) &gt;input&quot;).send_keys('selenium')

# 暂停2秒
sleep(2)

# 关闭浏览器
driver.close()
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="36-捕获元素定位失败异常">3.6 捕获元素定位失败异常</h3>
<p>在元素可能定位失败时，为了让代码继续执行，可以捕获异常</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
from selenium.common.exceptions import NoSuchElementException # 需要先导入异常包

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

try:
    driver.find_element_by_id('kw123').send_keys('python')
except NoSuchElementException as e:
    print('元素定位失败，异常信息是：{}'.format(e))

sleep(2)
driver.quit()
</code></pre>
<p>输出信息：</p>
<pre><code>元素定位失败，异常信息是：Message: no such element: Unable to locate element: {&quot;method&quot;:&quot;id&quot;,&quot;selector&quot;:&quot;kw123&quot;}
  (Session info: chrome=73.0.3683.86)
  (Driver info: chromedriver=70.0.3538.97 (d035916fe243477005bc95fe2a5778b8f20b6ae1),platform=Windows NT 10.0.14393 x86_64)
</code></pre>
<h2 id="4元素操作">4.元素操作</h2>
<h3 id="41-输入内容">4.1 输入内容</h3>
<ul>
<li>
<p>send_keys()</p>
<pre><code class="language-python">driver.find_element_by_id('kw').send_keys('selenium')
</code></pre>
</li>
</ul>
<h3 id="42-点击元素">4.2 点击元素</h3>
<ul>
<li>
<p>click（）</p>
<pre><code class="language-python">driver.find_element_by_id('kw').click()
</code></pre>
</li>
</ul>
<h3 id="43-清空元素中的内容">4.3 清空元素中的内容</h3>
<ul>
<li>
<p>clear（）</p>
<pre><code class="language-python">driver.find_element_by_id('kw').clear()
</code></pre>
</li>
</ul>
<h3 id="44-获取元素文本内容">4.4 获取元素文本内容</h3>
<ul>
<li>
<p>text</p>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 定位到新闻超链接，再获取元素文本
text = driver.find_element_by_link_text(&quot;新闻&quot;).text
print(text)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code>新闻
</code></pre>
</li>
</ul>
<h3 id="45-获取元素的尺寸">4.5 获取元素的尺寸</h3>
<ul>
<li>
<p>size</p>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 定位到搜索框，再获取元素尺寸
size = driver.find_element_by_css_selector('#kw').size
print(size)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code>{'height': 22, 'width': 500}
</code></pre>
</li>
</ul>
<h3 id="46-获取元素属性">4.6 获取元素属性</h3>
<ul>
<li>
<p>get_attribute（）</p>
<pre><code class="language-python">from selenium import webdriver

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 定位到搜索框，再获取元素属性
attribute = driver.find_element_by_css_selector('#kw').get_attribute('type')
print(attribute)

# 关闭浏览器
driver.close()
</code></pre>
<pre><code>text
</code></pre>
</li>
</ul>
<h3 id="47-提交表单">4.7 提交表单</h3>
<ul>
<li>
<p>submit（）</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 定位到搜索框
driver.find_element_by_css_selector('#kw').send_keys('selenium')
# 使用submit，代替click
driver.find_element_by_css_selector('#su').submit()

sleep(2)
# 关闭浏览器
driver.close()
</code></pre>
</li>
</ul>
<h2 id="5设置等待时间">5.设置等待时间</h2>
<h3 id="51-强制等待">5.1 强制等待</h3>
<ul>
<li>导入time模块下的sleep</li>
<li>强制让代码等待若干秒</li>
</ul>
<h3 id="52-隐式等待">5.2 隐式等待</h3>
<ul>
<li>
<p><code>driver.implicitly_wait（）</code></p>
</li>
<li>
<p>隐式等待是在等待周期内一直检测元素是否出现，元素出现后则马上继续，如果等待超时就会报错</p>
</li>
<li>
<p>隐式等待只需设置一次即可对整个测试周期生效</p>
</li>
<li>
<p>任何时候都应该加上隐式等待</p>
</li>
<li>
<p>建议设置等待时间：30s内</p>
</li>
<li>
<p>隐式等待缺陷</p>
<ul>
<li>对一些一直存在但值在变化的元素没有意义</li>
<li>如网页title</li>
</ul>
<pre><code class="language-python">
from selenium import webdriver

from time import sleep

driver = webdriver.Chrome()

driver.get('https://www.baidu.com')

# 添加智能等待

driver.implicitly_wait(10)

# 获取当前页面的title

old_title  = driver.title

print(old_title)

# 进行搜索操作

driver.find_element_by_css_selector('#kw').send_keys('selenium')

driver.find_element_by_css_selector('#su').click()

# 实验：添加强制等待后再获取新title

#sleep(3)

# 获取搜索界面的title

new_title = driver.title

print(new_title)

if old_title == new_title:

    print('智能等待对title失效，title还没有变化')

else:

    print('智能等待对title已生效')

driver.close()
</code></pre>
</li>
</ul>
<h3 id="53-显示等待ex">5.3 显示等待（ex）</h3>
<h4 id="531-title-is">5.3.1 title is</h4>
<pre><code class="language-python">from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait  # 导入webdriverwait类
from selenium.webdriver.support.expected_conditions import title_is

driver = webdriver.Chrome()         # 创建浏览器对象

# 创建webdriverwait对象
# 最长超时时间为10s
wait = WebDriverWait(driver, 10)

# 访问百度首页
driver.get('https://www.baidu.com')

# 百度首页的页面标题为：百度一下，你就知道
# 使用title_is判断
title = wait.until(title_is('百度一下，你就知道'))

# 打印title值，true表示页面标题正确，反之不正确
print(title)

# 这部分会抛出timeout异常
# 因为10s后，页面标题还是百度一下，你就知道
# 注意是用的until_not
title2 = wait.until_not(title_is('百度一下，你就知道'))
print(title2)

driver.quit()
</code></pre>
<h2 id="6浏览器控制滚动条">6.浏览器控制滚动条</h2>
<ul>
<li>
<p>阅读用户协议等页面时，通过滚动条是否拉到最下方判断用户阅读情况</p>
</li>
<li>
<p>需要操作的元素不在视觉范围内，需要拖动滚动条</p>
</li>
<li>
<p><mark>注意：拖动滚动条要加强制等待，不然拖不了</mark></p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://www.baidu.com')

# 添加智能等待
driver.implicitly_wait(10)

# 进行搜索操作
driver.find_element_by_css_selector('#kw').send_keys('selenium')
driver.find_element_by_css_selector('#su').click()

# 加一个等待，避免页面没有加载完成导致不能拖动
sleep(1)

# 将页面滚动条拖动到底部（纵坐标）
js = 'window.scrollTo(0,10000)'
driver.execute_script(js)

# 横坐标可以与纵坐标结合使用

sleep(1)

# 将滚动条拖动到最右（横坐标）
js2 = 'window.scrollTo(10000,0)'
driver.execute_script(js2)

sleep(2)

driver.quit()
</code></pre>
</li>
</ul>
<h2 id="7下拉框操作">7.下拉框操作</h2>
<ul>
<li>下拉框源码</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
	&lt;body&gt;
		&lt;select  id='kw'&gt;
			&lt;option  value='1'&gt;湖南&lt;/option&gt;
			&lt;option  value='2'&gt;广东&lt;/option&gt;
			&lt;option  value='3'&gt;湖北&lt;/option&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="71-使用二次定位">7.1 使用二次定位</h3>
<ul>
<li>
<p>先定位到下拉框，再点击里面的选项</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
import os

driver = webdriver.Chrome()
file_path = 'file:///' + os.path.abspath('下拉框.html')
driver.get(file_path)

sleep(2)

# 定位到下拉框
m = driver.find_element_by_id('kw')
# 再点击选择里面的选项
m.find_element_by_xpath(&quot;//option[@value='2']&quot;).click()

sleep(3)

driver.quit()
</code></pre>
</li>
</ul>
<h3 id="73-使用select库">7.3 使用Select库</h3>
<ul>
<li>
<p>导入selenium自带的select库</p>
</li>
<li>
<p>再通过索引、值、文本等定位下拉框选项</p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
import os
from selenium.webdriver.support.select import Select # 导入select

driver = webdriver.Chrome()
file_path = 'file:///' + os.path.abspath('下拉框.html')
driver.get(file_path)

sleep(2)

# 定位到下拉框
m = driver.find_element_by_id('ShippingMethod')

# 使用select库选择
#Select(m).select_by_index(2)  # 根据索引选择，注意索引从0开始
#Select(m).select_by_value(&quot;7.45&quot;) # 根据value值选择
Select(m).select_by_visible_text('UPS Ground ==&gt; $8.34')  # 根据标签文本选择

sleep(3)

driver.quit()
</code></pre>
</li>
</ul>
<h2 id="8多窗口处理">8.多窗口处理</h2>
<ul>
<li>
<p>根据窗口的handle值进行切换</p>
</li>
<li>
<p>获取当前窗口：<code>driver.current_window_handle</code></p>
</li>
<li>
<p>切换到指定窗口：<code>driver.switch_to.window()</code></p>
</li>
<li>
<p>获取所有窗口：<code>driver.window_handles</code></p>
<pre><code class="language-python">from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get('https://news.baidu.com')
driver.implicitly_wait(20)

# 获取当前窗口handle
shouye_handle = driver.current_window_handle
print('新闻首页窗口的handle是：{}'.format(shouye_handle))

# 打开一条新闻
driver.find_element_by_partial_link_text('创新是').click()

sleep(3)

# 切换到新闻首页窗口
driver.switch_to.window(shouye_handle)

#获取所有窗口handle，返回列表
all_handle = driver.window_handles
print('所有窗口的handle是:{}'.format(all_handle))

sleep(2)

driver.quit()
</code></pre>
</li>
</ul>
<h2 id="9弹框处理">9.弹框处理</h2>
<ul>
<li>弹框源码（test目录中alert.html）</li>
<li>点击弹框中的确定：<code>driver.switch_to.alert.accept()</code></li>
<li>点击弹框中的取消：<code>driver.switch_to.alert.dismiss()</code></li>
<li>弹框中输入文本：<code>driver.switch_to.alert.send_keys('xiaoming')</code></li>
<li>获取弹框中的文本：<code>driver.switch_to.alert.text</code></li>
</ul>
<h3 id="91-点击弹框中的确定">9.1 点击弹框中的确定</h3>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
import os

driver = webdriver.Chrome()
file_path = 'file:///' + os.path.abspath('alert.html')
driver.get(file_path)

# 点击第三种弹框
driver.find_element_by_id('b3').click()
sleep(1)
# 点击弹框中的确定
driver.switch_to.alert.accept()
sleep(1)

# 点击第三种弹框
driver.find_element_by_id('b3').click()
sleep(1)
# 点击弹框中的取消
driver.switch_to.alert.dismiss()

# 点击第二种弹框
driver.find_element_by_id('b2').click()
sleep(1)
# 在弹框中输入xiaoming
driver.switch_to.alert.send_keys('xiaoming')
sleep(2)
# 点击确定
driver.switch_to.alert.accept()
sleep(2)    # 输入小明后，有一句提示语
driver.switch_to.alert.accept()

# 点击第三种弹框
driver.find_element_by_id('b3').click()
print(driver.switch_to.alert.text)

sleep(2)

driver.quit()
</code></pre>
<h2 id="10框架切换">10.框架切换</h2>
<ul>
<li>
<p>框架：frame</p>
</li>
<li>
<p>通过frame中的id/name切换：<code>driver.switch_to.frame(frame id/name)</code></p>
</li>
<li>
<p>返回默认框架：<code>driver.switch_to.default_content()</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;窗口切换&lt;/title&gt;
&lt;/head&gt;
&lt;frameset rows=&quot;50%,50%&quot; ,border=&quot;0&quot; scrolling=&quot;no&quot;
    noresize=&quot;noresize&quot;&gt;
    &lt;frame src=&quot;https://www.baidu.com/&quot; name=&quot;top&quot; noresize=&quot;noresize&quot; /&gt;
    &lt;frame src=&quot;https://www.taobao.com/&quot; name=&quot;bottom&quot; /&gt;
&lt;/frameset&gt;
&lt;/frameset&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-python">from selenium import webdriver
from time import sleep
driver = webdriver.Chrome()
file_path = 'file:///C:/Users/%E6%9D%8E%E4%B8%80%E6%9D%AD/Desktop/frame.html'
driver.get(file_path)
driver.implicitly_wait(20)

# 切换到最顶层frame
driver.switch_to.frame('top')
# 在百度搜索框中输入selenium
driver.find_element_by_id('kw').send_keys('selenium')

# 返回默认层
driver.switch_to.default_content()

# 切换到中间层frame
driver.switch_to.frame('body')
# 如果frame没有id/name属性，则通过二次定位解决
# f = driver.find_element_by_xpath('/html/frameset/frame[2]')
# driver.switch_to.frame(f)
# 点击新浪首页中的新闻链接
driver.find_element_by_link_text('新闻').click()

sleep(2)

# 返回默认层
driver.switch_to.default_content()

driver.quit()
</code></pre>
</li>
</ul>
<pre><code class="language-python"># QQ登录
from selenium import webdriver
from time import sleep

driver = webdriver.Chrome()
driver.get(&quot;https://mail.qq.com&quot;)  #/cgi-bin/loginpage
driver.implicitly_wait(30)

# 切换到登录frame
driver.switch_to.frame('login_frame')
# 切换到账号密码登录
driver.find_element_by_id('switcher_plogin').click()
# 输入用户名
driver.find_element_by_id('u').send_keys('630746762')
# 输入密码
driver.find_element_by_id('p').send_keys('wo@NI123')
# 点击登录
driver.find_element_by_id('login_button').click()

sleep(2)
driver.quit()
</code></pre>
]]></content>
    </entry>
</feed>