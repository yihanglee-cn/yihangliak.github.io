<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yihangliak.github.io</id>
    <title>一杭的博客</title>
    <updated>2019-09-11T03:56:54.215Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yihangliak.github.io"/>
    <link rel="self" href="https://yihangliak.github.io/atom.xml"/>
    <subtitle>你好  靓仔   :D</subtitle>
    <logo>https://yihangliak.github.io/images/avatar.png</logo>
    <icon>https://yihangliak.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 一杭的博客</rights>
    <entry>
        <title type="html"><![CDATA[Python全栈（二）：私有属性与私有方法]]></title>
        <id>https://yihangliak.github.io/post/dz4T-djIi</id>
        <link href="https://yihangliak.github.io/post/dz4T-djIi">
        </link>
        <updated>2019-09-11T03:51:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>基本介绍</p>
</blockquote>
<ul>
<li><strong>私有属性</strong> 就是 <strong>对象</strong> 不希望公开的属性</li>
<li><strong>私有方法</strong> 就是 <strong>对象</strong> 不希望公开的方法</li>
</ul>
<blockquote>
<p>定义方式</p>
</blockquote>
<p>在定义属性或者方法时，在属性或者方法名前增加 <strong>两个下划线</strong> ，这就是定义私有属性或者私有方法</p>
<blockquote>
<p>提示</p>
</blockquote>
<ul>
<li>私有属性或者私有方法，在类外无法访问，但是在类中是可以访问的</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<p><strong>私有方法</strong></p>
<pre><code class="language-python">class Test():
    def test1(self):
        print('普通方法')
        self.__test3()     # 私有方法可以在类内部被调用

    def _test2(self):
        print('普通方法')

    def __test3(self):      # 双斜线开头则为私有方法
        print('私有方法')

t = Test()
t.test1()
t._test2()
# t.__test3()        # 私有方法在外部不能被调用
</code></pre>
<p><strong>私有属性</strong></p>
<pre><code class="language-python">class Person():
    def __init__(self, name):
        self.__name = name   # 双下划线+属性名=私有属性
        self.sex = 'boy'

    def get_name(self):
        return self.__name

    def set_name(self, new_name):   # 定义一个修改name属性的方法，一旦name长度小于5则报错
        if len(new_name)&gt;=5:
            self.__name = new_name   # 私有属性在类中是可以访问的
        else:
            print('error:名字长度需要大于或者等于5')


p = Person('zs')
print(p.sex)           # 普通属性在类外是可以访问到的
# print(p.__name)      # 私有属性在类外不能访问
p.set_name('hiiii')    # 调用修改name属性的方法
print(p.get_name())    # 访问被修改之后的name属性
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python全栈（一）：子类扩展父类方法]]></title>
        <id>https://yihangliak.github.io/post/QpPt8XA7M</id>
        <link href="https://yihangliak.github.io/post/QpPt8XA7M">
        </link>
        <updated>2019-09-10T15:54:29.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>基本介绍</p>
</blockquote>
<p>如果在开发中，<strong>子类方法的实现中包含父类方法的实现</strong>，即<strong>父类封装的方法是子类实现的一部分</strong></p>
<p>则可以使用 <strong>扩展</strong>的方式</p>
<blockquote>
<p>使用步骤：</p>
</blockquote>
<ol>
<li>在子类中 <strong>重写</strong> 父类方法</li>
<li>在需要的位置使用<code>super().父类方法</code>来调用父类方法的执行</li>
<li>代码其他位置针对子类的需求，编写 <strong>子类特有的代码实现</strong></li>
</ol>
<blockquote>
<p>关于super</p>
</blockquote>
<ul>
<li>在python中，super是一个 <strong>特殊</strong> 的类</li>
<li>super（）就是使用super类创建出来的对象</li>
<li>最常使用的场景就是在 <strong>重写父类方法时</strong>，调用 <strong>在父类中的方法实现</strong></li>
</ul>
<blockquote>
<p>代码实现</p>
</blockquote>
<pre><code class="language-python"># 定义父类：动物类
class Animal():
    def eat(self):
        print('吃')

    def run(self):
        print('跑')

    def bark(self):
        print('狗吠')

xiaohei = Animal()  # 实例化狗类
xiaohei.eat()       # 生成对象调用父类方法

print('='*50)

class Dog(Animal):   # 定义狗类，并继承动物类
    def bark(self):
        print('汪汪叫')

xiaobai = Dog()
xiaobai.bark()       # 调用狗吠方法

print('='*50)

class xiaotianquan(Dog):   # 定义哮天犬类继承狗类
    def bark(self):
        super().bark()  # 使用super().父类方法调用父类方法并执行
        print('eqweqdasdasdasdsad')  # 编写子类特有的功能，哮天犬除了狗吠还会鸟语...

xtq = xiaotianquan()
xtq.bark()  # 哮天犬除了不仅会狗吠，还会说鸟语...
</code></pre>
<pre><code>吃
==================================================
汪汪叫
==================================================
汪汪叫
eqweqdasdasdasdsad
</code></pre>
<blockquote>
<p>提示</p>
</blockquote>
<p>在Python2.x时，如果需要调用父类方法，还可以使用以下方式实现：</p>
<pre><code>父类名.方法（self）
</code></pre>
<ul>
<li>这种方式，在目前的Python3.x中依旧支持</li>
<li>但是不推荐使用这种方法，因为一旦父类名发生变化，子类中涉及到父类 <strong>类名</strong> 的位置同样需要修改</li>
</ul>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>在开发时，父类名和super（）两种方式不要混用</li>
<li>如果使用当前子类名调用方法，会形成递归调用，<strong>出现死循环</strong></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[实用工具大搜罗]]></title>
        <id>https://yihangliak.github.io/post/UQ96yPt5M</id>
        <link href="https://yihangliak.github.io/post/UQ96yPt5M">
        </link>
        <updated>2019-09-10T06:30:01.000Z</updated>
        <summary type="html"><![CDATA[<p>盘点那些不为人知的工具-们！</p>
]]></summary>
        <content type="html"><![CDATA[<p>盘点那些不为人知的工具-们！</p>
 <!-- more -->
<h1 id="文字编辑">文字编辑    📕</h1>
<p><strong>思维导图</strong></p>
<ul>
<li>幕布：<a href="https://mubu.com/">https://mubu.com</a></li>
<li>xmind<br>
xmind ZEN：<a href="http://dl2.xmind.cn/XMind-ZEN-Update-2019-for-Windows-64bit-9.2.0-201904271935.exe">http://dl2.xmind.cn/XMind-ZEN-Update-2019-for-Windows-64bit-9.2.0-201904271935.exe</a><br>
破解补丁：<a href="https://carrot.ctfile.com/dir/11269771-31680249-fdf2c2/">https://carrot.ctfile.com/dir/11269771-31680249-fdf2c2/</a></li>
</ul>
<p><strong>Markdown编辑器</strong></p>
<ul>
<li>Typora：<a href="https://www.typora.io/">https://www.typora.io/</a></li>
</ul>
<p><strong>万能编辑器</strong></p>
<ul>
<li>notepad ++</li>
</ul>
<p><strong>文档，表格，幻灯片</strong></p>
<ul>
<li>WPS（政企专版，无广告）：<a href="http://wpspro.support.wps.cn/gov/heilongjiang/daqing/installation/WPS_Office_2019_%E5%A4%A7%E5%BA%86%E5%B8%82%E5%85%9A%E6%94%BF%E6%9C%BA%E5%85%B3%E4%B8%93%E7%94%A8%E7%89%88.exe">http://wpspro.support.wps.cn/gov/heilongjiang/daqing/installation/WPS_Office_2019_大庆市党政机关专用版.exe</a></li>
<li>在线emoji：<a href="http://emojihomepage.com/">http://emojihomepage.com/</a></li>
</ul>
<h1 id="开发工具">开发工具    💻</h1>
<p><strong>图形化Git工具</strong></p>
<ul>
<li>sourcetree：<a href="https://www.sourcetreeapp.com/">https://www.sourcetreeapp.com/</a></li>
</ul>
<p><strong>python编辑器</strong></p>
<ul>
<li>pycharm：<a href="http://www.jetbrains.com/pycharm/">http://www.jetbrains.com/pycharm/</a></li>
</ul>
<p><strong>MySQL连接软件</strong></p>
<ul>
<li>Navicat for mysql 绿色版：<a href="https://www.cr173.com/soft/38153.html">https://www.cr173.com/soft/38153.html</a></li>
</ul>
<p><strong>Java8</strong></p>
<ul>
<li>JDK下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li>
</ul>
<p><strong>淘宝镜像站</strong></p>
<ul>
<li>地址：<a href="https://npm.taobao.com">https://npm.taobao.com</a></li>
</ul>
<h1 id="生活类">生活类    👀</h1>
<p><strong>护眼</strong></p>
<ul>
<li>护眼宝：<a href="http://www.huyanapp.com/portal.php">http://www.huyanapp.com/portal.php</a></li>
</ul>
<h1 id="图片处理类">图片处理类    🎨</h1>
<p><strong>截图工具</strong></p>
<ul>
<li>Snipaste：<a href="https://www.snipaste.com/">https://www.snipaste.com/</a></li>
</ul>
<p><strong>免费图床</strong></p>
<ul>
<li>smpic：<a href="https://github.com/kookob/smpic">https://github.com/kookob/smpic</a></li>
<li>聚合图床：<a href="https://www.superbed.cn/">https://www.superbed.cn/</a></li>
<li>智图图片压缩：<a href="https://zhitu.isux.us/">https://zhitu.isux.us/</a></li>
</ul>
<h1 id="系统美化类">系统美化类    🐼</h1>
<p><strong>任务栏全透明</strong></p>
<ul>
<li>TranslucentTB：<a href="https://translucenttb.en.softonic.com/">https://translucenttb.en.softonic.com/</a></li>
</ul>
<p><strong>Windows字体优化</strong></p>
<ul>
<li>Mactype：<a href="https://www.mactype.net/">https://www.mactype.net/</a></li>
</ul>
<p><strong>超美壁纸</strong></p>
<ul>
<li>Pexels：<a href="https://www.pexels.com/">https://www.pexels.com/</a></li>
</ul>
<h1 id="效率类">效率类     📚</h1>
<p><strong>待办事项管理</strong></p>
<ul>
<li>MicrosoftToDo：<a href="https://todo.microsoft.com/">https://todo.microsoft.com/</a></li>
</ul>
<p><strong>本地文件搜索工具（一秒找到文件）</strong></p>
<ul>
<li>everything：<a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></li>
</ul>
<p><strong>百度云不限速下载</strong></p>
<ul>
<li>speedpan：<a href="https://www.speedpan.com/">https://www.speedpan.com/</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dcoker 安装MySQL]]></title>
        <id>https://yihangliak.github.io/post/SuD1zwuyw</id>
        <link href="https://yihangliak.github.io/post/SuD1zwuyw">
        </link>
        <updated>2019-08-30T08:40:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="dcoker-安装mysql">Dcoker 安装MySQL</h1>
<h2 id="前言">前言</h2>
<blockquote>
<p>什么是Docker？</p>
</blockquote>
<p>Docker是一个开源的应用容器引擎，可以将应用程序打包成镜像，然后发布到任何的Linux机器上，也可以实现虚拟化</p>
<p>简单来说，Docker就好比是虚拟机，虚拟机可以模拟出电脑硬件，并且可以很方便的克隆，但是虚拟机的缺点也非常明显，它会占用宿主机非常多的硬件资源，而且启动速度也非常慢。而Linux在此基础之上发展出了一种新的容器技术，容器与宿主机共用硬件资源，启动速度也非常快，这个容器就是Docker。</p>
<h2 id="1-安装docker">1. 安装Docker</h2>
<p>Docker的安装十分简单，在Linux系统中，使用<code>yum</code>安装即可（需联网）</p>
<pre><code>yum -r install docker
# -r表示后续所有的需要确认的步骤都默认选择“是”
</code></pre>
<h2 id="2启动docker">2.启动Docker</h2>
<pre><code>service docker start
</code></pre>
<h2 id="3镜像-容器-仓库">3.镜像 容器 仓库</h2>
<p>Docker中有仓库，镜像，容器这个三个比较重要的概念。</p>
<ul>
<li>仓库类似代码仓库，集中存放镜像的场所</li>
<li>镜像类似虚拟机的镜像</li>
<li>容器则是从镜像创建的一个运行实例</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/H508f8c2700f043c79194c1ef521c17fao.jpg" alt=""></p>
<h2 id="4拉取镜像">4.拉取镜像</h2>
<p>拉取MySQL镜像，版本选择5.7</p>
<pre><code>docker pull mysql:5.7
</code></pre>
<h2 id="5查看镜像">5.查看镜像</h2>
<p>验证刚刚拉取的镜像是否成功</p>
<pre><code>docker images
</code></pre>
<p><img src="https://ae01.alicdn.com/kf/Hb52cbf8cac344605b2c688b9bff42b73t.jpg" alt=""></p>
<h2 id="6创建mysql目录">6.创建MySQL目录</h2>
<p>创建MySQL的储存目录，用来存放数据库数据</p>
<p><code>mkdir -p</code>可以递归创建目录</p>
<pre><code>mkdir -p /usr/local/mysql/conf /usr/local/mysql/data /usr/local/mysql/logs
</code></pre>
<h2 id="7运行容器">7.运行容器</h2>
<pre><code class="language-shell">docker run -p 3309:3306 --name firstmysql -v /usr/local/mysql/conf:/etc/mysql/conf.d -v /usr/local/mysql/logs:/logs -v /usr/local/mysql/data:/var/lib/mysql -e mysql_root_password=123456 -d mysql:5.7
</code></pre>
<p>命令说明：</p>
<ul>
<li><code>--name</code>：容器命名为firstmysql</li>
<li><code>-p 3309:3306</code>：将容器的3309端口映射到宿主机的3306</li>
<li><code>-v</code>：将容器的某个目录挂载到主机的目录</li>
<li><code>-e mysql_root_password=123456</code>：初始化数据库root用户的密码为123456</li>
<li><code>-d</code>：挂后台运行</li>
</ul>
<h2 id="8查看容器状态">8.查看容器状态</h2>
<p>查看容器状态命令：</p>
<pre><code>docker ps -a
</code></pre>
<p><img src="https://ae01.alicdn.com/kf/H30935c3f43784024a3b9d640e6a4baf0w.jpg" alt=""></p>
<h2 id="9进入容器">9.进入容器</h2>
<pre><code>docker exec -i -t firstmysql bash
</code></pre>
<p><img src="https://ae01.alicdn.com/kf/Ha34afe45477240aa8e74e6a1d5eec0fdu.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LuckyFrame自动化测试平台部署指南]]></title>
        <id>https://yihangliak.github.io/post/luckyframe</id>
        <link href="https://yihangliak.github.io/post/luckyframe">
        </link>
        <updated>2019-08-28T02:09:31.000Z</updated>
        <summary type="html"><![CDATA[<p>LuckyFrame测试平台是一款免费开源的测试平台，最大的特点是全纬度覆盖了接口自动化、WEB UI自动化、APP自动化，并且支持分布式测试，测试关键字驱动也很大程度上解决了测试同学代码基础弱的问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>LuckyFrame测试平台是一款免费开源的测试平台，最大的特点是全纬度覆盖了接口自动化、WEB UI自动化、APP自动化，并且支持分布式测试，测试关键字驱动也很大程度上解决了测试同学代码基础弱的问题。</p>
<!-- more -->
<h1 id="关于luckyframe">关于LuckyFrame</h1>
<p>​	<code>LuckyFrame</code>测试平台是一款免费开源的测试平台，最大的特点是全纬度覆盖了<code>接口自动化</code>、<code>WEB UI自动化</code>、<code>APP自动化</code>，并且支持<code>分布式测试</code>，<code>测试关键字驱动</code>也很大程度上解决了测试同学代码基础弱的问题。同时也集成了<code>质量管理</code>相关的一些功能，解决QA的日常工作中，项目过程数据的收集问题，并能展示一些简单质量报表。</p>
<h1 id="windows平台部署">Windows平台部署</h1>
<h2 id="1-安装jdk">1. 安装JDK</h2>
<ul>
<li>部署LuckyFrame之前，需要先安装jdk，且版本要求在<code>1.8</code>以上</li>
<li>JDK去<code>oracle</code>官网下载即可</li>
<li>打开环境变量配置界面，在用户变量中新增<code>JAVA_HOME=jdk安装路径</code>，再将<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</code>添加至系统变量<code>path</code>中即可</li>
<li>在命令行中输入<code>java -version</code>验证</li>
</ul>
<h2 id="2-安装mysql">2. 安装MySQL</h2>
<p>下载xampp集成环境，免去单独配置安装MySQL的麻烦</p>
<ul>
<li>将xampp解压到某磁盘根目录</li>
<li>打开xampp-control程序，启动MySQL</li>
<li>进入xampp中的<code>mysql\bin</code>目录，在当前路径下打开命令行</li>
<li>使用<code>mysql -uroot -p</code>登录（xampp集成的MySQL无密码）</li>
<li>切换到MySQL数据库：<code>use mysql</code></li>
<li>修改MySQL密码：<code>update user set password=password('123456') where user='root'</code></li>
<li>刷新权限：<code>flush privileges</code></li>
</ul>
<h2 id="3-下载luckyframe">3. 下载LuckyFrame</h2>
<p>访问Luckyframe官网，直接下载编译包，下载地址如下：</p>
<pre><code>链接：  https://pan.baidu.com/s/1SNUhzoKFgH2TRQN2Rx711A 密码：u845
</code></pre>
<blockquote>
<p>注意：下载3.0bata版本，同时还要下载数据库初始化sql文件</p>
</blockquote>
<h2 id="4修改编译包数据库配置">4.修改编译包数据库配置</h2>
<ul>
<li>使用压缩工具打开下载好的编译包</li>
<li>找到编译包目录中<code>BOOT-INF\classes\application-druid.yml</code>文件</li>
<li>用notepad打开，将其中的<code>主数据库源</code>配置项中的密码改成本机MySQL的密码</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/Heabb9bbbc3f94b159ac29c938f9602741.png" alt=""></p>
<h2 id="5导入sql文件">5.导入SQL文件</h2>
<p>在启动LuckyFrame之前，需要先在MySQL数据库中导入<code>初始化sql</code>文件</p>
<ul>
<li>登录MySQL，新建<code>luckyframe</code>数据库：<code>create database luckyframe charset=utf8;</code></li>
<li>回到命令行，使用<code>mysql -h localhost -uroot -p luckyframe &lt; V3.sql --default-character-set=utf8</code>将初始化SQL文件导入进数据库，注意要在sql文件所在目录执行该命令</li>
</ul>
<h2 id="6启动luckyframe">6.启动LuckyFrame</h2>
<ul>
<li>
<p>进入LuckyFrame服务端jar包存放目录，在此目录打开命令行</p>
</li>
<li>
<p>命令行输入：<code>java -jar LuckyFrameWeb.jar</code>启动服务即可</p>
</li>
<li>
<p>启动成功后，会看到如下提示</p>
</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/H3bb471a358a64da28a46a31a45dd130eN.png" alt=""></p>
<h2 id="7访问">7.访问</h2>
<ul>
<li>在浏览器中输入<code>本机ip：80</code>即可访问LuckyFrame，默认为80端口，可以省略不写</li>
<li>如要修改端口号，需要在编译包中找到<code>BOOT-INF\classes\application.yml</code>文件，修改默认端口配置</li>
</ul>
<p>访问效果图如下：</p>
<p><img src="https://ae01.alicdn.com/kf/H50d41bdd78bd40889b1bfdc4a47e89cdr.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jemeter性能测试完整入门]]></title>
        <id>https://yihangliak.github.io/post/begin_jemeter</id>
        <link href="https://yihangliak.github.io/post/begin_jemeter">
        </link>
        <updated>2019-07-23T01:18:12.000Z</updated>
        <summary type="html"><![CDATA[<p>性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p>
]]></summary>
        <content type="html"><![CDATA[<p>性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p>
<!-- more -->
<h1 id="第一章-性能基础知识">第一章 性能基础知识</h1>
<h2 id="1-性能测试的概念">1. 性能测试的概念</h2>
<p>通过性能测试工具模拟多种正常，峰值，以及异常负载条件来对系统的各项性能指标进行测试</p>
<h2 id="2性能测试的目的">2.性能测试的目的</h2>
<ul>
<li>评估系统能力</li>
<li>测试系统可靠性</li>
<li>识别系统的弱点（内存泄漏）</li>
<li>性能调优（满足用户需求，优化瓶颈，提高整体性能）</li>
</ul>
<blockquote>
<p>性能测试时间点，功能测试之后</p>
</blockquote>
<h2 id="3性能测试归属">3.性能测试归属</h2>
<p>测试阶段划分：系统测试</p>
<p>性能测试属于黑盒测试</p>
<p>属于6大质量特性中的：效率特性</p>
<h1 id="第二章-性能测试的分类">第二章 性能测试的分类</h1>
<h2 id="1-负载测试">1 负载测试</h2>
<ul>
<li>通过逐步给服务器增加压力，直到某项数据不达标，测试软件的瓶颈</li>
<li>评测和评估对象在不同工作量条件下的性能行为</li>
<li>负载的目标是确保系统测试超出预期工作量的情况下仍然可以继续运行</li>
</ul>
<h2 id="2-压力测试">2 压力测试</h2>
<ul>
<li>强度测试，通过高负载的手段来使服务器资源处于极限状态，直到某项数据失效，测试系统的极限</li>
<li>通过高负载的手段，可以更快的发现系统内存泄漏以及稳定性等问题</li>
</ul>
<h2 id="3-失效恢复性测试">3 失效恢复性测试</h2>
<ul>
<li>出现问题后能否根据预先制定的策略恢复，且恢复后能正常工作</li>
</ul>
<h2 id="4-并发测试">4 并发测试</h2>
<ul>
<li>测试多用户按照预定的场景请求某个业务或者功能时，是否会出现问题</li>
<li>几乎所有的性能测试都会涉及到并发测试，并发测试的主要目的是找出并发问题（资源争用）</li>
</ul>
<h2 id="5-稳定性测试">5 稳定性测试</h2>
<ul>
<li>一般使用目标负载的1.5-2倍的负载量或者CPU占用达到70%，测试系统长时间运行（7x24），观察系统稳定性</li>
</ul>
<h2 id="6-配置测试">6 配置测试</h2>
<ul>
<li>通过调整系统软件、硬件环境，了解在不同情况下系统性能指标情况，从而找到系统最优配置</li>
</ul>
<blockquote>
<p>新产品上线以前，先做一个配置测试，找到最优配置，然后进行负载，压力，稳定，失效恢复性等测试</p>
<p>产品上线以后主要做压力测试</p>
<p>当然，具体做什么类型的性能测试，需要根据项目背景去灵活选择</p>
</blockquote>
<h1 id="第三章-性能术语">第三章 性能术语</h1>
<h2 id="1-事务">1 事务</h2>
<p>一个任务从开始到结束的过程</p>
<blockquote>
<p>事务具有原子性</p>
<p>原子性：整个程序操作过程中的所有操作，要么全部完成，要么全部不完成</p>
</blockquote>
<h2 id="2-响应时间">2 响应时间</h2>
<p>系统对请求作出响应的时间（一个事务处理完成的时间）</p>
<blockquote>
<p>响应时间=网络传输时间+web服务器处理时间+DB服务器处理时间+浪费时间</p>
<p>258原则：</p>
<p>&lt;2秒快<br>
大于2小于5秒可以<br>
大于5小于8秒勉强接受<br>
大于8秒不耐烦了，或者认为系统已经失去响应，而选择离开这个Web站点，或者发起第二次请</p>
</blockquote>
<h2 id="3-吞吐量">3 吞吐量</h2>
<p>每秒服务器处理的请求或者事务数</p>
<p>吞吐量衡量单位：</p>
<ul>
<li>每秒请求数</li>
<li>每秒事务数（TPS）</li>
<li>每秒页面数</li>
<li>每秒查询数（QPS）</li>
</ul>
<h2 id="4-并发">4 并发</h2>
<ul>
<li>绝对并发：不同用户，在同一时刻，做同一个操作</li>
<li>相对并发：不用用户，在同一时刻，做不同操作</li>
</ul>
<h2 id="5-并发数">5 并发数</h2>
<p>同一时间操作的用户个数</p>
<h2 id="6-场景">6 场景</h2>
<p>模拟用户的真实操作过程</p>
<p>分类：</p>
<ul>
<li>单一场景：单个操作</li>
<li>混合场景：多个组合操作</li>
</ul>
<h2 id="7-思考时间">7 思考时间</h2>
<p>用户每个操作之间的间隔时间，增加间隔时间可以更真实地模拟用户使用的场景</p>
<h2 id="8-性能瓶颈">8 性能瓶颈</h2>
<p>软件的性能缺陷</p>
<p>这个缺陷主要分布在：</p>
<ul>
<li>硬件：如cpu等配置过低</li>
<li>应用服务器：如web服务器，数据库系统等</li>
<li>程序：程序设计的问题</li>
<li>操作系统：如Windows虚拟内存交换效果不理想等</li>
<li>网络设备：防火墙，交换机等</li>
</ul>
<h1 id="第四章-性能测试工具">第四章 性能测试工具</h1>
<h2 id="1-工具分类">1 工具分类</h2>
<p><strong>jmeter</strong></p>
<ul>
<li>免费，开源</li>
<li>支持二次开发</li>
<li>支持分布式部署</li>
<li>支持命令行模式</li>
</ul>
<p><strong>LoadRunner</strong></p>
<ul>
<li>商业，收费</li>
</ul>
<p><strong>Locust</strong></p>
<ul>
<li>python开源性能测试工具</li>
</ul>
<p><strong>Apache ab</strong></p>
<ul>
<li>Apache的web性能测试工具</li>
</ul>
<h1 id="第五章-jmeter原理与安装">第五章  Jmeter原理与安装</h1>
<h2 id="1-工作原理">1 工作原理</h2>
<p>使用取样器向服务器发送请求，从服务器获取响应结果，然后通过线程组模拟服务器压力</p>
<h2 id="2-安装">2 安装</h2>
<p>安装JDK并配置环境变量</p>
<p>官网下载jmeter压缩包，并解压</p>
<p>双击bin目录下的jmeter.bat启动即可</p>
<h2 id="3-常用组件">3 常用组件</h2>
<p>Test Plan：测试计划（场景）</p>
<ul>
<li>Thread Group：线程组，模拟并发数
<ul>
<li>http request ：取样器，模拟用户请求
<ul>
<li>view result tree：查看结果树，监听取样器的结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/05/23/5ce651c23611220681.png" alt=""></p>
<p>在取样器中添加响应断言</p>
<p><img src="https://i.loli.net/2019/05/23/5ce654857964383456.png" alt=""></p>
<p>断言界面详解</p>
<p><img src="https://i.loli.net/2019/05/23/5ce655cf44fc126049.png" alt=""></p>
<p>添加聚合报告</p>
<p><img src="https://i.loli.net/2019/05/23/5ce656572cffc62167.png" alt=""></p>
<p>聚合报告详情</p>
<p><img src="https://i.loli.net/2019/05/23/5ce658c11d59d64211.png" alt=""></p>
<h2 id="4-第一个脚本">4 第一个脚本</h2>
<p>1.新建测试计划</p>
<p>2.创建线程组</p>
<p>3.添加http取样器</p>
<p>4.添加监听器-view result tree</p>
<p>5.添加断言-response assertion</p>
<p>6.添加聚合报告</p>
<p>ecshop登录脚本</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66637dacc955298.png" alt=""></p>
<h1 id="第六章-jmeter常用组件">第六章 jmeter常用组件</h1>
<h2 id="1-参数化">1 参数化</h2>
<p>1.设置用户自定义变量</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66b3899da523409.png" alt=""></p>
<p>调用方式与RF一致，${变量名}</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66f8a9d53b90774.png" alt=""></p>
<p>添加参数化文件读取组件</p>
<p><img src="https://i.loli.net/2019/05/23/5ce66f2c1f19c73246.png" alt=""></p>
<p><img src="https://i.loli.net/2019/05/23/5ce66fa76129952059.png" alt=""></p>
<h2 id="2-cookie关联">2 cookie关联</h2>
<p>把上一个取样器的结果关联到一下个取样器</p>
<p>http cookie manager 可以把cookie自动关联到下一个取样器的请求中</p>
<p>在同一个线程组中添加一个 HTTP cookie manager</p>
<p><img src="https://i.loli.net/2019/05/24/5ce75a94d259889153.png" alt=""></p>
<p>添加完成以后无需配置，即可将第一个取样器中的cookie自动同步至所有线程组</p>
<h2 id="3-上传文件">3  上传文件</h2>
<p>以ecshop留言上传文件为例</p>
<p>首先添加一个发表留言并且要上传文件的取样器，并配置好取样器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce75d54d671b93977.png" alt=""></p>
<p>配置文件上传参数</p>
<p><img src="https://i.loli.net/2019/05/24/5ce75e271af0025911.png" alt=""></p>
<p>运行成功示意图</p>
<h2 id="4-正则提取器">4  正则提取器</h2>
<p>提取取样器结果中的任何内容</p>
<p>通过表达式从一堆数据中提取符合表达式规则的数据</p>
<p>语法：</p>
<pre><code>[0-9]  : 表示任意一个数字，等价于/d
[a-z]  : 表示任意一个小写字母
[A-Z]  : 表示任意一个大写字母
\w     : 表示任意一个字符，包含大小写字母，中文，数字以及一个_
\s     : 表示一个空格
{}     : 表示匹配前面表达式的连续n个
{m,n}  : 表示匹配前面表达式的连续m-n个
+      : 表示匹配前面表达式的一个或多个
\      : 去转义
.      : 表示出了换行符之外的任意一个字符
$      : 结尾
^      : 开头
？     ： 非贪婪匹配，匹配到一个结果后结束匹配
()     : 需要提取的内容用小括号包围

</code></pre>
<p>添加正则提取器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce79fbf48c9a19994.png" alt=""></p>
<p>配置正则提取器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7a0dc8de5817775.png" alt=""></p>
<p>在一下个查询订单详情的取样器中使用上述提取出的变量</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7a1a2cae6f21453.png" alt=""></p>
<h2 id="5-添加debug组件">5  添加debug组件</h2>
<p>该组件可以查看所有使用过的变量</p>
<p>添加debug组件</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7aa82246b181060.png" alt=""></p>
<p>为该组件添加一个结果树，即可查看使用过的变量</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1558686516491.png" alt=""></p>
<h2 id="6-逻辑控制器">6  逻辑控制器</h2>
<p>逻辑控制器，可以控制取样器的执行顺序</p>
<h3 id="61-for">6.1 for</h3>
<p>添加for循环控制器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ae70d9dda97533.png" alt=""></p>
<p>将查询订单详情挪至for控制器里面</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ae13e19b824772.png" alt=""></p>
<p>配置for控制器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ba0abf23475823.png" alt=""></p>
<p>修改正则提取中的配置</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7af62df31663732.png" alt=""></p>
<p>在查询订单中使用遍历出来得变量即可</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7ba3b3d35a16894.png" alt=""></p>
<h3 id="62-if">6.2 if</h3>
<p>添加if控制器</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7bb8e3673832089.png" alt=""></p>
<p>确定判断逻辑</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1558691180942.png" alt=""></p>
<p>在第一步登录取样器中提取登录结果</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7bdb68b02631353.png" alt=""></p>
<p>然后分别配置登录成功与登录失败需要执行的步骤</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7be22baf8b41429.png" alt=""></p>
<p><img src="https://i.loli.net/2019/05/24/5ce7be509b33387820.png" alt=""></p>
<h2 id="7-开关控制器">7 开关控制器</h2>
<p>方式一：通过0和1决定执行哪个，0执行第一个，1执行第二个</p>
<p>方式二：通过取样器名字决定执行哪个，名字必须与取样器完成一致才会执行</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7c63a893d843848.png" alt=""></p>
<h2 id="8-循环控制器">8  循环控制器</h2>
<p>对单个取样器进行循环操作</p>
<p><img src="https://i.loli.net/2019/05/24/5ce7c6e140e4d40844.png" alt=""></p>
<h1 id="第七章-并发数">第七章  并发数</h1>
<h2 id="1-平均并发数">1 平均并发数</h2>
<p>计算平均并发数</p>
<pre><code>平均并发数 = 每日活跃用户数*用户使用时间/访问时间段
</code></pre>
<p>一个系统，每天2000个用户访问，访问时间集中在上午9-12点，平均每个用户访问10分钟，计算并发数</p>
<pre><code>(2000*10)/(60*3)=111(大约)
# 2000为用户数量
# 10为用户使用时间
# 60*3是为了前后单位统一，访问时间段为3个小时
</code></pre>
<h2 id="2-峰值用户数">2 峰值用户数</h2>
<pre><code>峰值用户数 = 平均并发数 + 3*sqrt（平均并发数）
</code></pre>
<h1 id="第八章-搭建资源监控环境">第八章  搭建资源监控环境</h1>
<h2 id="1服务端">1.服务端</h2>
<ul>
<li>在服务器端安装java，并且配置环境变量</li>
</ul>
<pre><code>创建java存放目录：/usr/local/java
Linux配置环境变量
cd ~   # 进入root目录
vi .bash_profile


yum -y install java-1.8.0-openjdk*
</code></pre>
<ul>
<li>上传ServerAgent.zip到/opt目录，然后解压</li>
<li>进入ServerAgent目录，启动该代理</li>
</ul>
<pre><code>./startAgent.sh     # 启动监控代理
./startAgent.sh &amp;   # 以进程方式启动监控代理
</code></pre>
<h2 id="2-jmeter端">2. jmeter端</h2>
<ul>
<li>jmeter安装插件管理器</li>
</ul>
<pre><code>将jmeter-plugins-manager-1.3.jar放至jmeter安装目录下的lib\ext中
重启jmeter
</code></pre>
<ul>
<li>在option菜单中启动插件管理器</li>
<li>在打开的插件管理器安装</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebad6c81ac693657.png" alt=""></p>
<ul>
<li>在jmeter脚本线程组中添加jpgc监听器</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebadd487f8598359.png" alt=""></p>
<ul>
<li>配置该监听器</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebae25df76815710.png" alt=""></p>
<ul>
<li>不要忘了设置线程组，配置几个线程，运行时间等</li>
</ul>
<p><img src="https://i.loli.net/2019/05/27/5cebaf5d655f499007.png" alt=""></p>
<h1 id="第九章-性能测试流程">第九章  性能测试流程</h1>
<ul>
<li>需求分析(学习业务，分析规格文档)</li>
<li>场景设计(测试场景、测试类型、并发数、步长、思考时间)</li>
<li>编写计划</li>
<li>环境搭建、数据准备、脚本开发</li>
<li>性能测试(性能数据收集)</li>
<li>性能分析、性能调优</li>
<li>性能测试报告</li>
<li>结束</li>
</ul>
<h1 id="第十章-centos搭建ecshop">第十章  centos搭建ecshop</h1>
<p>1.上传xampp压缩包并解压</p>
<pre><code>tar -xzvf xampp-linux-1.7.7.tar.gz
</code></pre>
<p>2.进入lampp目录</p>
<p>3.输入命令启动xampp</p>
<pre><code class="language-shell">./lampp start

# 如果提示xampp只能在32位系统运行
# 使用yum命令安装32位包
yum install -y glibc*i686
</code></pre>
<p>3.启动成功后，验证是否启动成功</p>
<pre><code>netstat -anp|grep 80   # 查看httpd端口是否启动，httpd就是Apache的进程
netstat -anp|grep 3306 # 查看mysql的端口是否存在
</code></pre>
<p><img src="https://i.loli.net/2019/05/27/5cec07cf0cd3824063.png" alt=""></p>
<p>4.上传ecshop项目包到htdocs目录</p>
<p>5.解压安装即可</p>
<h1 id="第十一章-练习">第十一章  练习</h1>
<h2 id="1-ecshop登录实现参数化">1. ecshop登录实现参数化</h2>
<h3 id="11-创建登录脚本">1.1 创建登录脚本</h3>
<p>创建测试计划</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81d0f7d9b041641.png" alt=""></p>
<p>添加线程组</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81d3fdfca938484.png" alt=""></p>
<p>添加取样器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81d6076a3d26826.png" alt=""></p>
<p>配置取样器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81f7d0f95e89886.png" alt=""></p>
<p>添加观察结果树</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81f9cb20ea79058.png" alt=""></p>
<p>验证是否登录成功</p>
<p><img src="https://i.loli.net/2019/05/25/5ce81fe80066343193.png" alt=""></p>
<h3 id="12-添加参数化组件">1.2 添加参数化组件</h3>
<p>添加参数读取组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82020025e261962.png" alt=""></p>
<p>创建参数化文件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce820debcf3155100.png" alt=""></p>
<p>配置参数化组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce821bec8c8c90652.png" alt=""></p>
<p>重新用参数化形式配置取样器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce823c7235d651409.png" alt=""></p>
<h3 id="13-添加循环控制器">1.3 添加循环控制器</h3>
<p>添加一个循环控制器</p>
<p><img src="https://i.loli.net/2019/05/25/5ce8229f4b87e20141.png" alt=""></p>
<p>配置循环控制器，循环执行次数为3次，与参数化源文件数量对应</p>
<p><img src="https://i.loli.net/2019/05/25/5ce822c29a73c34944.png" alt=""></p>
<h3 id="14-验证结果">1.4 验证结果</h3>
<p>执行，验证是否三个账号都登录成功</p>
<p>添加断言</p>
<p><img src="https://i.loli.net/2019/05/25/5ce825276b49549803.png" alt=""></p>
<p>手工验证</p>
<p><img src="https://i.loli.net/2019/05/25/5ce824161278f49947.png" alt=""></p>
<h2 id="2-ecshop浏览器商品">2. ecshop浏览器商品</h2>
<h3 id="21-准备工作">2.1 准备工作</h3>
<p>以登录脚本为基础</p>
<ul>
<li>去掉参数化配置</li>
<li>去掉循环控制器</li>
<li>保证登录成功</li>
</ul>
<h3 id="22-关联cookie">2.2 关联cookie</h3>
<p>添加cookie关联</p>
<p><img src="https://i.loli.net/2019/05/25/5ce8282a21f5839026.png" alt=""></p>
<h3 id="23-配置用户自定义变量">2.3 配置用户自定义变量</h3>
<p>配置用户自定义变量可以在创建多个取样器时，方便取样器的配置统一性</p>
<p>添加用户自定义变量组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce829196fa8387851.png" alt=""></p>
<p>配置用户自定义变量组件</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82962c2e9b75133.png" alt=""></p>
<p>修改登录取样器，调用用户自定义变量</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82999679b343666.png" alt=""></p>
<p>修改浏览商品取样器配置</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82a15dd3b776964.png" alt=""></p>
<h3 id="24-观察结果与断言">2.4 观察结果与断言</h3>
<p>为浏览器商品分别添加结果树，断言，以及整个线程组的聚合报告</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82af98792689035.png" alt=""></p>
<h3 id="25-验证结果">2.5 验证结果</h3>
<p>执行脚本，查看聚合报告中的结果是否正确</p>
<p><img src="https://i.loli.net/2019/05/25/5ce82b68eefdf11673.png" alt=""></p>
<h1 id="第十二章-图形化报告">第十二章 图形化报告</h1>
<p>以命令行的模式运行jmeter脚本,生成图形化的报告</p>
<pre><code>jmeter -n -t C:\Users\Administrator\Desktop\lejifen.jmx -l result.jtl -e -o E:\apache-jmeter-5.1.1\bin\WebReport
</code></pre>
<ul>
<li>n：非GUI模式执行JMeter；</li>
<li>t： 脚本文件(.jmx文件)的路径；</li>
<li>l： 指定生成测试结果的保存文件(.jtl格式)，此文件必须不存在；</li>
<li>e：测试结束后，生成测试报告；</li>
<li>o：用于存放测试报告的路径；</li>
</ul>
<blockquote>
<p>注意：如果要重新生成一份测试报告，都需要将Jmeter的bin目录下的jtl文件以及webreport文件夹进行删除。<br>
可以在Jmeter的bin目录下手动直接删除，也可以通过命令删除。</p>
</blockquote>
<pre><code>del /s /Q D:\Jmeter\apache-jmeter-3.2\bin\result.jtl //删除jtl文件
rd /s /Q D:\Jmeter\apache-jmeter-3.2\bin\WebReport //删除webreport文件夹
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2019 年中总结]]></title>
        <id>https://yihangliak.github.io/post/2019_mid_year</id>
        <link href="https://yihangliak.github.io/post/2019_mid_year">
        </link>
        <updated>2019-07-22T08:22:12.000Z</updated>
        <summary type="html"><![CDATA[<p>月亮总不会被太阳抛弃  所以等你的日子不值一提</p>
]]></summary>
        <content type="html"><![CDATA[<p>月亮总不会被太阳抛弃  所以等你的日子不值一提</p>
<!-- more -->
<p>不知不觉，19年已经过去大半啦<br>
马上就要再一次经历<code>happy birthday</code>的洗礼<br>
回顾这大半年  除了工作 好像没干啥事儿<br>
<strong>视力不断<code>↓</code></strong><br>
走在路上   四五米开外的东西  已是时见一斑<br>
<strong>体重不断<code>↑</code></strong><br>
办了张健身卡 从刚开始拿到卡的打鸡血模式 现在演变成了 耶 又下雨了 可以不用去跑步了的状态<br>
6月份  公司组织去桂林旅游<br>
WTF  大学毕业旅行就是去的桂林   时隔多年 竟想不到以这种方式故地重游<br>
想我一湖南人  张家界都没有去过 竟然去了桂林两次  还是旅游<br>
心态崩了<br>
最近迷上焦迈奇的歌   有一首里面写到<br>
<code>月亮总不会被太阳抛弃 所以等你的日子不值一提</code><br>
唱的真好  干的漂亮<br>
原来有时候  一个人干着不为人知的事情  very洒脱<br>
写这篇总结断断续续<br>
从早上写到晚上<br>
绞尽脑汁   东拼西凑<br>
可是到现在还是混乱得 宛如一片残垣<br>
得<br>
还是来根<code>寂寞</code>再说<br>
记忆是个好东西  可惜我没有<br>
以摆动的二郎腿结束这篇<code>zongjie</code><br>
愿顺利度过余下半年 白发少几根  体重减几斤  工资涨几分</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python Requests]]></title>
        <id>https://yihangliak.github.io/post/python-requests</id>
        <link href="https://yihangliak.github.io/post/python-requests">
        </link>
        <updated>2019-07-20T01:53:31.000Z</updated>
        <summary type="html"><![CDATA[<p>Requests 唯一的一个非转基因的 Python HTTP 库，人类可以安全享用。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Requests 唯一的一个非转基因的 Python HTTP 库，人类可以安全享用。</p>
<!-- more -->
<h1 id="requests">Requests</h1>
<h1 id="1-安装requests">1. 安装requests</h1>
<p>命令行使用pip安装：<code>pip install requests</code></p>
<h1 id="2-get请求">2. get请求</h1>
<h2 id="21-get请求">2.1 get请求</h2>
<p>该方法用于向目标网址发送请求，接收响应</p>
<p><code>get</code>方法中的参数说明：</p>
<ul>
<li>url：必填，指定请求的目标网址</li>
<li>params：字典类型，指定请求参数</li>
</ul>
<p>该方法返回一个response对象，常用的方法和属性如下：</p>
<pre><code class="language-python">import requests

r = requests.get('https://api.github.com/events')  # 使用get请求访问github
print(r.status_code)                      # 打印响应状态码
print(r.text)                             # 返回str类型的响应
print(r.url)                              # 返回请求网站的url
print(r.encoding)                         # 返回响应时间的编码方式
print(r.cookies)                          # 返回响应的cookies信息
print(r.headers)                          # 返回响应头部
print(r.content)                          # 返回bytes类型的响应体
print(r.json())                           # 返回字典类型的响应体
</code></pre>
<h2 id="22-传递url参数">2.2 传递URL参数</h2>
<blockquote>
<p>注意：<code>httpbin.org</code>是一个开源的，用于测试网页请求的网站</p>
</blockquote>
<p>在get请求中，使用<code>params</code>关键字参数，可将字典类型的自定义参数传入到URL中进行拼接</p>
<pre><code class="language-python">import requests

url = 'http://httpbin.org/get'   # 定义请求目标网址
params = {                       # 定义自定义请求参数
    'key1':'value1',
    'key2':'value2'
}
r = requests.get(url, params=params)  # get请求中传入自定义参数
print(r.status_code)               # 打印状态码
print(r.url)                       # 打印传入参数后的URL
print(r.json())                    # 返回dict响应
</code></pre>
<pre><code># 状态码
200
# 传入参数后的url
http://httpbin.org/get?key1=value1&amp;key2=value2    
# 返回的dict类型数据中可以看到自定义参数
{'args': {'key1': 'value1', 'key2': 'value2'}, 'headers': {'Accept': '*/*', 'Accept-Encodinh': 'gzip, deflate', 'Connectioo': 'keep-alive', 'Host': 'httpbin.org', 'User-Agent': 'python-requests/2.18.4'}, 'origin': '119.123.77.203, 119.123.77.203', 'url': 'https://httpbin.org/get?key1=value1&amp;key2=value2'}

</code></pre>
<h2 id="23-实例">2.3 实例</h2>
<p>以百度搜索为例</p>
<pre><code class="language-python">import requests

url = 'http://www.baidu.com/s'
params = {'wd':'python'}
r = requests.get(url, params=params)  # get方法中传入params参数，可以讲自定义参数拼接到URL中
print(r.url)                          # 打印拼接过后的URL
print(r.text)                         # 打印响应文本内容
</code></pre>
<pre><code>http://www.baidu.com/s?wd=python
</code></pre>
<h1 id="3-post请求">3. post请求</h1>
<p>在web课程中我们已经知晓了，客户端发送一些敏感的信息时，我们需要通过post请求方式，这种传输方式比get请求安全，而且是通过加密的方式传输比较安全，下面我们就介绍一下怎样通过requests库进行发送post请求</p>
<h2 id="31-data">3.1 data</h2>
<p>如果想要发送一些编码为表单形式的数据，只需要传递一个字典给<code>data</code>关键字参数，你的字典数据在发出请求时自动编码为表单形式</p>
<pre><code class="language-python">import requests

# 给data传入字典数据
r = requests.post('http://httpbin.org/post', data={'key1':'value1', 'key2':'value2'})
print(r.text)
</code></pre>
<pre><code>{
  &quot;args&quot;: {}, 
  &quot;data&quot;: &quot;&quot;, 
  &quot;files&quot;: {}, 
  &quot;form&quot;: {               # data传入到这里，以表单形式
    &quot;key1&quot;: &quot;value1&quot;, 
    &quot;key2&quot;: &quot;value2&quot;
  }, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Content-Length&quot;: &quot;23&quot;, 
    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot;
  }, 
  &quot;json&quot;: null, 
  &quot;origin&quot;: &quot;119.123.77.203, 119.123.77.203&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/post&quot;
}
</code></pre>
<h2 id="32-json">3.2 json</h2>
<p>post方法还可以以<code>json</code>关键字参数传入json数据，传入json数据时，<code>header</code>中的<code>Content-Type</code>默认为<code>application/json</code></p>
<p>将字典数据转化为<code>json</code>数据，需要导入<code>json</code>模块，并用<code>dumps</code>进行转换</p>
<pre><code class="language-python">import requests

data = {'key1':'value1', 'key2':'value2'}   # 定义字典数据

# 将字典转化为json并传入请求中
r = requests.post('http://httpbin.org/post', json=json.dumps(data))  
print(r.text)
</code></pre>
<pre><code>{
  &quot;args&quot;: {}, 
  &quot;data&quot;: &quot;\&quot;{\\\&quot;key1\\\&quot;: \\\&quot;value1\\\&quot;, \\\&quot;key2\\\&quot;: \\\&quot;value2\\\&quot;}\&quot;&quot;,   # json传到这里
  &quot;files&quot;: {}, 
  &quot;form&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, 
    &quot;Content-Length&quot;: &quot;46&quot;, 
    &quot;Content-Type&quot;: &quot;application/json&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot;
  }, 
  &quot;json&quot;: &quot;{\&quot;key1\&quot;: \&quot;value1\&quot;, \&quot;key2\&quot;: \&quot;value2\&quot;}&quot;, 
  &quot;origin&quot;: &quot;119.123.77.203, 119.123.77.203&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/post&quot;
}

</code></pre>
<h2 id="33-实例">3.3 实例</h2>
<blockquote>
<p>在真实场景中，如何能够确定<code>post</code>请求中应该传入<code>data</code>还是<code>json</code>呢？</p>
</blockquote>
<p>确定<code>post</code>请求中，应该传入<code>data</code>还是<code>json</code>，可以通过抓包工具抓取请求数据，查看请求<code>header</code>中<code>Content-Type</code>的值：</p>
<ul>
<li><code>Content-Type：application/from</code>：传入data</li>
<li><code>Content-Type：application/json</code>：传入json</li>
</ul>
<p>ecshop登录实例：</p>
<p>首先，通过<code>fiddler</code>抓包，查看ecshop登录请求头中的<code>Content-Type</code>，可以看到请求中的数据是以<code>from</code>的形式发送到服务器的，如图：</p>
<p><img src="https://i.loli.net/2019/07/22/5d352bcc4179d47999.png" alt=""></p>
<p>所以，在使用<code>requests</code>发送<code>post</code>请求时，用户名与密码都会以<code>data</code>关键字参数传入</p>
<pre><code class="language-python">import requests
import re

url = 'http://localhost:82/ecshop/user.php'
datas = {'username':'liyihang', 'password':'tashi123', 'act':'act_login'}
r = requests.post(url, data=datas)
print(r.text)

# 加入判断进行断言
if &quot;欢迎您回来！&quot; in result:
    print('登录成功')
else:
	print('登录失败')
</code></pre>
<h1 id="4-保持会话">4. 保持会话</h1>
<p>一般在项目中，很多操作都是需要先登录再进行，所以需要先发送登录请求，登录成功后，保持登录状态，再进行后续操作，在requests中保持会话，我们可以用<code>session</code>来保持登录状态</p>
<blockquote>
<p><strong>为什么session可以实现保持会话呢？</strong></p>
<p>因为底层使用的是urllib3.connectionpool 一看到连接池就会联想到数据库的连接池，对就是池化的概念。且链接是采用的HTTP 长链接，再底层是用HTTP1.1 Connection: keep-alive来实现的</p>
</blockquote>
<pre><code class="language-python">import requests

# 保持登录，然后充值100
s = requests.session()  # 建立一个session

# 定义登录与充值需要的数据
url = 'http://localhost:82/ecshop/user.php'
datas1 = {'username':'liyihang', 'password':'tashi123', 'act':'act_login'}
datas2 = {'amount':'100', 'user_note':'jiekou', 'payment_id':'2', 'act':'act_account'}

# 使用建立的session对象发送登录请求
# 登录成功后会返回的cookie会被保存在该session中
r = s.post(url, data=datas1)
# print(r.cookies)
# 发送充值请求
r2 = s.post(url, data=datas2 )
print(r2.text)

# 这里可以加一个简单判断用来断言结果是否正确
</code></pre>
<h1 id="5自定义请求头">5.自定义请求头</h1>
<h2 id="51-获取请求头">5.1 获取请求头</h2>
<blockquote>
<p><code>httpbin.org/headers</code>会返回发送请求的请求头</p>
</blockquote>
<p>请求头内容可以用<code>r.headers</code>获取</p>
<pre><code class="language-python">import requests

r = requests.get('http://httpbin.org/headers')
print(r.headers)
print(r.text)

</code></pre>
<p>结果如下，可以看到<code>user-agent</code>为requests</p>
<pre><code>{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate&quot;, 
    &quot;Connectioo&quot;: &quot;keep-alive&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;python-requests/2.18.4&quot;   
  }
}
</code></pre>
<h2 id="52-自定义请求头">5.2 自定义请求头</h2>
<p>很多网站为了保证安全会设置<code>反爬虫机制</code>，也就是说对于<code>非浏览器</code>的访问拒绝响应，在这种情况下，就需要修改请求中的<code>headers</code>信息<code>伪装</code>成浏览器访问</p>
<p><strong>使用浏览器访问httpbin 获取headers</strong></p>
<p>打开浏览器，在地址栏中输入：<code>http://httpbin.org/headers</code></p>
<p>该URL会返回发送请求的请求头，所以会将浏览器发送的请求头部返回，如下：</p>
<pre><code>{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, 
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate&quot;, 
    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, 
    &quot;Connectioo&quot;: &quot;keep-alive&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, 
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
  }
}
</code></pre>
<p><strong><code>headers</code>中各参数的作用如下：</strong></p>
<ul>
<li>accept：指定客户单接受的内容类型，<code>/</code>表示任意类型，其余按照字义</li>
<li><s>accept-encoding：指定客户端接受的编码类型</s></li>
<li><s>accept-language：指定客户端接受的语言类型，<code>q=0.9</code>表示喜欢程度，不写则是1，数值越高越喜欢</s></li>
<li>connection：指定长链接处理方式，<code>keep-alive</code>表示希望保持传输链接，http本身是无状态的</li>
<li>host：服务器主机名</li>
<li>user-agent：用户代理，服务器从此处知道客户端的系统类型以及版本等信息</li>
</ul>
<p><strong>将获取到的headers 传给<code>get</code></strong></p>
<pre><code class="language-python">import requests

url = 'http://httpbin.org/headers'
header = {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;,
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate&quot;,
    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;,
    &quot;Connectioo&quot;: &quot;keep-alive&quot;,
    &quot;Host&quot;: &quot;httpbin.org&quot;,
    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
  }
# url = 'http://www.baidu.com'
r = requests.get(url, headers=header)  # 将自定义headers信息通过headers关键字参数传入
# print(r.headers)
print(r.text)
</code></pre>
<p>自定义headers后，返回的结果如下：</p>
<pre><code>{
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, 
    &quot;Accept-Encodinh&quot;: &quot;gzip, deflate,gzip, deflate&quot;, 
    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;, 
    &quot;Connectioo&quot;: &quot;keep-alive,keep-alive&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, 
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
  }
}

</code></pre>
<h2 id="53-实例">5.3 实例</h2>
<p>以<code>知乎发现</code>页面为例，在没有通过自定义请求头<code>伪装</code>成真实浏览器时，是获取不到该页面中的信息的，只有在将请求头伪装成与真实浏览器一样以后，才可以获取到该页面的信息</p>
<p>首先，用<code>fiddler</code>抓取知乎-发现页面请求信息，在headers中找到<code>user-agent</code>信息，并将其复制</p>
<p><img src="https://mypic-1256006100.cos.ap-chengdu.myqcloud.com/markdown_pic/Snipaste_2019-07-24_10-24-41.png" alt=""></p>
<p>然后在代码中自定义header</p>
<pre><code class="language-python">import requests

# 未定义请求头之前
# r = requests.get('https://www.zhihu.com/explore')
# print(r.text)   # 不能正常访问页面信息

header = {
    &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 &quot;
                 &quot;(KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
}

# 通过headers关键字参数将自定义header传入
r = requests.get('https://www.zhihu.com/explore', headers=header)
print(r.text)    # 正常访问知乎发现页面

</code></pre>
<h1 id="6发送https请求">6.发送HTTPS请求</h1>
<h2 id="61-sslerror">6.1 SSLError</h2>
<p>requests在发送<code>HTTPS</code>请求时，有时会报证书错误，</p>
<p>别在开启<code>Fiddler</code>抓包工具时，发送访问百度首页时会报证书错误</p>
<p>代码与错误如下：</p>
<pre><code class="language-python">import requests

r = requests.get(&quot;https://www.baidu.com&quot;)
print(r.status_code)
</code></pre>
<p>执行上述代码会报证书错误：<code>requests.exceptions.SSLError: HTTPSConnectionPool</code></p>
<h2 id="62-关闭证书验证">6.2 关闭证书验证</h2>
<blockquote>
<p>解决办法为：关闭证书验证</p>
</blockquote>
<p>Requests的请求默认<code>verify=True</code>，如果你将<code>verify</code>设置为<code>False</code>，Requests 也能忽略对 SSL 证书的验<br>
证</p>
<pre><code class="language-python">import requests

r = requests.get(&quot;https://www.baidu.com&quot;, verify=False)  # 关闭证书验证
print(r.status_code)
</code></pre>
<h2 id="63-忽略警告信息">6.3 忽略警告信息</h2>
<pre><code class="language-python">import urllib3

# 关闭警告
urllib3.disable_warnings()
r = requests.get(&quot;https://www.baidu.com&quot;, verify=False)  # 关闭证书验证
print(r.status_code)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Postman使用技巧]]></title>
        <id>https://yihangliak.github.io/post/postman-shi-yong-ji-qiao</id>
        <link href="https://yihangliak.github.io/post/postman-shi-yong-ji-qiao">
        </link>
        <updated>2019-07-19T03:40:49.000Z</updated>
        <summary type="html"><![CDATA[<p>Postman是一个接口测试工具，在做接口测试的时候，Postman相当于一个客户端，它可以模拟用户发起的各类HTTP请求，将请求数据发送至服务端，获取对应的响应结果，从而验证响应中的结果数据是否和预期值相匹配；并确保开发人员能够及时处理接口中的bug，进而保证产品上线之后的稳定性和安全性。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Postman是一个接口测试工具，在做接口测试的时候，Postman相当于一个客户端，它可以模拟用户发起的各类HTTP请求，将请求数据发送至服务端，获取对应的响应结果，从而验证响应中的结果数据是否和预期值相匹配；并确保开发人员能够及时处理接口中的bug，进而保证产品上线之后的稳定性和安全性。</p>
<!-- more -->
<h1 id="postman使用教程">Postman使用教程</h1>
<h1 id="1介绍">1.介绍</h1>
<p>postman是一个接口测试工具，在做接口测试的时候，postman相当于一个客户端，他可以模拟用户发起各类的<code>HTTP请求</code>，将<code>请求</code>你数据发送至<code>服务端</code>，获取对应的响应结果，从而验证响应中的结果是否与预期值匹配；并确保开发人员能够及时处理接口中的bug，进而保证产品上线后的<code>稳定性</code>与<code>安全性</code></p>
<h1 id="2优势">2.优势</h1>
<ul>
<li>简单易用的图形用户界面</li>
<li>可以保存API请求历史记录</li>
<li>可用集合Runner来自动化测试</li>
<li>灵活的API监控</li>
</ul>
<h1 id="3安装">3.安装</h1>
<p>官网下载地址：<a href="https://www.getpostman.com/downloads/">https://www.getpostman.com/downloads/</a></p>
<p>下载安装包安装即可，注意系统位数</p>
<h1 id="4工具界面简介">4.工具界面简介</h1>
<p><img src="https://i.loli.net/2019/07/19/5d3122915979f43319.png" alt=""></p>
<h1 id="5发送请求">5.发送请求</h1>
<h2 id="51-创建请求选项卡">5.1 创建请求选项卡</h2>
<p>点击请求构建器中的<code>+</code>号，创建一个新的选项卡</p>
<p><img src="https://i.loli.net/2019/07/19/5d3123fcbb04589086.png" alt=""></p>
<h2 id="52-填写请求地址">5.2 填写请求地址</h2>
<p>以百度首页为例，在请求地址栏中填写请求地址：<code>https://www.baidu.com/s?wd=python</code></p>
<p>请求方式选择<code>get</code></p>
<p><img src="https://i.loli.net/2019/07/23/5d365e4b03f0020602.png" alt=""></p>
<p>在响应内容中：</p>
<ul>
<li>
<p><code>pretty</code>显示为格式化后的json</p>
</li>
<li>
<p><code>raw</code>是未经处理的数据</p>
</li>
<li>
<p><code>preview</code>可以预览HTML页面</p>
</li>
<li>
<p><code>status</code>为状态码</p>
</li>
</ul>
<h1 id="6使用用例集">6.使用用例集</h1>
<p>postman中可以通过新建<code>Collections</code>的方式来保存测试请求</p>
<h2 id="61-新建用例集">6.1 新建用例集</h2>
<p><img src="https://i.loli.net/2019/07/19/5d313511d1a8180663.png" alt=""></p>
<h2 id="62-添加请求到用例集">6.2 添加请求到用例集</h2>
<p>点击发送请求后的<code>save</code>按钮，保存请求到用例集</p>
<p><img src="https://i.loli.net/2019/07/19/5d3135a1c1aff47874.png" alt=""></p>
<h1 id="7断言">7.断言</h1>
<p>postman中可以为每个请求设置<code>断言</code>，用来判断接口功能是否正常</p>
<h2 id="71-添加断言">7.1 添加断言</h2>
<p>在请求界面中，点击<code>test</code>选项卡，然后在断言输入框中写入断言即可，注意要按<code>ctrl +s</code>保存</p>
<p><img src="https://i.loli.net/2019/07/19/5d31395bc5a2485354.png" alt=""></p>
<h2 id="72-查看断言结果">7.2 查看断言结果</h2>
<p>在响应界面中，点击<code>Test Results</code>可以查看到断言的结果</p>
<p><img src="https://i.loli.net/2019/07/19/5d3139b3199e187114.png" alt=""></p>
<h2 id="73-常用的断言方法">7.3 常用的断言方法</h2>
<pre><code class="language-js">pm.test(&quot;Status code is 200&quot;, function () {
    pm.response.to.have.status(200);
}); //断言状态码是200可以

pm.test(&quot;Body matches string “yunda”&quot;, function () {
    pm.expect(pm.response.text()).to.include(&quot;yunda&quot;);
}); //检查响应主体中是否包含指定字符串

pm.test(&quot;Response time is less than 200ms&quot;, function () {
    pm.expect(pm.response.responseTime).to.be.below(200);
}); //检查响应时间是否小于200ms
</code></pre>
<h1 id="8批量运行用例集">8.批量运行用例集</h1>
<p>用例集创建好并且每个请求都写好断言以后，则可以批量执行用例集，并生成相应的报告</p>
<p>首先点击用例集列表中的箭头，调出批量执行界面，点击<code>run</code></p>
<p><img src="https://i.loli.net/2019/07/19/5d3161067b60254081.png" alt=""></p>
<p>配置执行参数</p>
<p><img src="https://i.loli.net/2019/07/19/5d3161e332ee623513.png" alt=""></p>
<p>执行结果页面</p>
<p><img src="https://i.loli.net/2019/07/19/5d31622bc6e0673691.png" alt=""></p>
<h1 id="9设置环境变量">9.设置环境变量</h1>
<h2 id="91-添加环境变量">9.1 添加环境变量</h2>
<p>在postman中，设置环境变量可以快速变换接口地址</p>
<p>比如分别设置<code>生产环境</code>与<code>测试环境</code>环境变量，之后需要改变接口地址只需切换不同的环境即可</p>
<p><img src="https://i.loli.net/2019/07/19/5d3166b3ec8f688394.png" alt=""></p>
<h2 id="93-切换环境">9.3 切换环境</h2>
<p>在接口请求界面右上角可以切换该接口的环境，</p>
<p>在接口地址使用变量为双花括号包围变量名，如：</p>
<p><code>{{url}}autonumber/autoComNum?resultv2=1&amp;text=3102615141528</code></p>
<p><img src="https://i.loli.net/2019/07/19/5d31681ac9dbb19061.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL  整理]]></title>
        <id>https://yihangliak.github.io/post/mysql-lian-xi</id>
        <link href="https://yihangliak.github.io/post/mysql-lian-xi">
        </link>
        <updated>2019-06-24T02:11:00.000Z</updated>
        <summary type="html"><![CDATA[<p>MySQL -- 最流行的关系型数据库管理系统</p>
]]></summary>
        <content type="html"><![CDATA[<p>MySQL -- 最流行的关系型数据库管理系统</p>
<!-- more -->
<h1 id="准备数据">准备数据</h1>
<p><strong>创建学生表</strong></p>
<pre><code>CREATE TABLE `student`(
	`s_id` VARCHAR(20),
	`s_name` VARCHAR(20) NOT NULL DEFAULT '',
	`s_birth` VARCHAR(20) NOT NULL DEFAULT '',
	`s_sex` VARCHAR(10) NOT NULL DEFAULT '',
	PRIMARY KEY(`s_id`)
);
</code></pre>
<p><strong>创建课程表</strong></p>
<pre><code>CREATE TABLE `course`(
	`c_id` VARCHAR(20),
    `c_name` VARCHAR(20) NOT NULL DEFAULT '',
    `t_id` VARCHAR(20) NOT NULL,
    PRIMARY KEY(`c_id`)
);
</code></pre>
<p><strong>创建教师表</strong></p>
<pre><code>CREATE TABLE `teacher`(
	`t_id` VARCHAR(20),
    `t_name` VARCHAR(20) NOT NULL DEFAULT '',
    PRIMARY KEY(`t_id`)
);
</code></pre>
<p><strong>创建成绩表</strong></p>
<pre><code>CREATE TABLE `score`(
	`s_id` VARCHAR(20),
    `c_id` VARCHAR(20),
    `s_score` INT(3),
    PRIMARY KEY(`s_id`, `c_id`)
);
</code></pre>
<p><strong>在学生表中插入数据</strong></p>
<pre><code>insert into student values('01', '赵雷', '1990-01-01', '男');
insert into student values('02' , '钱电' , '1990-12-21' , '男');
insert into student values('03' , '孙风' , '1990-05-20' , '男');
insert into student values('04' , '李云' , '1990-08-06' , '男');
insert into student values('05' , '周梅' , '1991-12-01' , '女');
insert into student values('06' , '吴兰' , '1992-03-01' , '女');
insert into student values('07' , '郑竹' , '1989-07-01' , '女');
insert into student values('08' , '王菊' , '1990-01-20' , '女');

</code></pre>
<p><strong>在课程表中插入数据</strong></p>
<pre><code>insert into course values('01' , '语文' , '02');
insert into course values('02' , '数学' , '01');
insert into course values('03' , '英语' , '03');
</code></pre>
<p><strong>在教师表中插入数据</strong></p>
<pre><code>insert into teacher values('01' , '张三');
insert into teacher values('02' , '李四');
insert into teacher values('03' , '王五');
</code></pre>
<p><strong>在成绩表中插入数据</strong></p>
<pre><code>insert into score values('01' , '01' , 80);
insert into score values('01' , '02' , 90);
insert into score values('01' , '03' , 99);
insert into score values('02' , '01' , 70);
insert into score values('02' , '02' , 60);
insert into score values('02' , '03' , 80);
insert into score values('03' , '01' , 80);
insert into score values('03' , '02' , 80);
insert into score values('03' , '03' , 80);
insert into score values('04' , '01' , 50);
insert into score values('04' , '02' , 30);
insert into score values('04' , '03' , 20);
insert into score values('05' , '01' , 76);
insert into score values('05' , '02' , 87);
insert into score values('06' , '01' , 31);
insert into score values('06' , '03' , 34);
insert into score values('07' , '02' , 89);
insert into score values('07' , '03' , 98);
</code></pre>
<p><strong>最终数据结构</strong></p>
<p><img src="https://i.loli.net/2019/06/24/5d1047a00429076901.png" alt=""></p>
<h1 id="练习">练习</h1>
<ol>
<li>查询<code>01</code>课程比<code>02</code>课程成绩高的学生的信息及课程分数</li>
</ol>
<pre><code>select a.* ,b.s_score as 01_score,c.s_score as 02_score from student a join
score b on a.s_id=b.s_id and b.c_id='01'left join score c on a.s_id=c.s_id 
and c.c_id='02' or c.c_id = NULL where b.s_score&gt;c.s_score;
</code></pre>
<ol start="2">
<li>查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</li>
</ol>
<pre><code>select b.s_id,b.s_name,ROUND(AVG(a.s_score),2) as avg_score from student b
join score a on b.s_id=a.s_id GROUP BY b.s_id HAVING avg_score&gt;=60;
</code></pre>
<ol start="3">
<li>查询平均成绩小于60的同学的学生编号和学生姓名和平均成绩</li>
</ol>
<pre><code>SELECT b.s_id,b.s_name,AVG(a.s_score) as avg_score FROM student
b join score a ON b.s_id=a.s_id GROUP BY b.s_id HAVING avg_score&lt;=60;
</code></pre>
<ol start="4">
<li>查询所有同学的编号，姓名，选课总数，所有课程总成绩</li>
</ol>
<pre><code>SELECT a.s_id,a.s_name,COUNT(b.c_id) as sum_course,SUM(b.s_score) as
sum_score FROM student a JOIN score b ON a.s_id=b.s_id GROUP BY a.s_id;
</code></pre>
<ol start="5">
<li>查询姓<code>李</code>的老师的数量</li>
</ol>
<pre><code>SELECT COUNT(t_id) FROM teacher t WHERE t_name LIKE '李%'; 
</code></pre>
<ol start="6">
<li>查询学过<code>张三</code>老师课程的所有同学的信息</li>
</ol>
<pre><code>SELECT a.* FROM student a JOIN score b ON a.s_id=b.s_idWHERE b.c_id
IN(SELECT c_id FROM course WHERE t_id=(SELECT t_id FROM teacher WHERE
t_name='张三'));
</code></pre>
<ol start="7">
<li>查询没有学过<code>张三</code>老师课程的所有同学的信息</li>
</ol>
<pre><code>SELECT * FROM student c WHERE c.s_id NOT IN( SELECT a.s_id from student a 
JOIN score b on a.s_id=b.s_id WHERE b.c_id IN( SELECT a.c_id FROM course a
JOIN teacher b ON a.t_id=b.t_id WHERE t_name='张三' ) )
</code></pre>
<ol start="8">
<li>查询每个学生姓名的人数</li>
</ol>
<pre><code>SELECT s_name,COUNT(*) FROM student GROUP BY s_name;
</code></pre>
<ol start="9">
<li>查询没有<code>学全</code>所有课程的同学的信息</li>
</ol>
<pre><code>SELECT s.* FROM student s 
LEFT JOIN score s1 ON s.s_id=s1.s_id 
GROUP BY s.s_id 
HAVING COUNT(s1.c_id) &lt; (SELECT COUNT(*) FROM course);
</code></pre>
]]></content>
    </entry>
</feed>