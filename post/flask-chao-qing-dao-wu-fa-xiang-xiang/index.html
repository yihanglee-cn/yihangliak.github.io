<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>进入Flask世界！  | Alex&#39;s Blog</title>
<meta name="description" content="你好  靓仔   :D" />
<link rel="shortcut icon" href="https://yihangliak.github.io/favicon.ico?v=1563783436295">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://yihangliak.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://yihangliak.github.io">
  <img class="avatar" src="https://yihangliak.github.io/images/avatar.png?v=1563783436295" alt="">
  </a>
  <h1 class="site-title">
    Alex&#39;s Blog
  </h1>
  <p class="site-description">
    你好  靓仔   :D
  </p>
  <div class="menu-container">
    
      
        <a href="https://yihangliak.github.io" class="menu">
          首页
        </a>
      
    
      
        <a href="https://yihangliak.github.io/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://yihangliak.github.io/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://yihangliak.github.io/post/guan-yu-wo/" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              进入Flask世界！ 
            </h2>
            <div class="post-info">
              <span>
                2019-06-21
              </span>
              <span>
                4 min read
              </span>
              
                <a href="https://yihangliak.github.io/tag/ZqPdD_sAA" class="post-tag">
                  # flask
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://yihangliak.github.io/post-images/flask-chao-qing-dao-wu-fa-xiang-xiang.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="flask简介">Flask简介</h1>
<blockquote>
<p>Flask是一个使用<code>Python</code>编写的轻量级web应用框架<br>
WSGI工具箱采用<code>Werzeug</code>，模板引擎使用<code>Jinjia2</code></p>
</blockquote>
<h1 id="进入flask世界">进入Flask世界</h1>
<h2 id="1安装python">1.安装Python</h2>
<p>略</p>
<h2 id="2安装python虚拟环境">2.安装Python虚拟环境</h2>
<p>Python虚拟环境常用命令</p>
<pre><code>安装virtualenv  pip install virtualenv
安装虚拟环境管理工具  virtualenvwrapper-win（Windows系统） 
创建虚拟环境：mkvirtualenv   xxx
切换到某个虚拟环境：workon xxx
退出当前虚拟环境：deactivate xxx
删除某个虚拟环境：rmvirtualenv  xxx
列出所有虚拟环境：lsvirtualenv
进入虚拟环境目录：cdvirtualenv
</code></pre>
<p>在虚拟环境中安装Flask</p>
<pre><code>cmd中：
1.首先切换到已经创建好的虚拟环境
2.输入：pip install flask
</code></pre>
<h1 id="url与视图">URL与视图</h1>
<h2 id="1服务器解释">1.服务器解释</h2>
<p><img src="https://i.loli.net/2019/06/05/5cf698581159673776.png" alt=""></p>
<h2 id="2第一个flask程序">2.第一个Flask程序</h2>
<p>Flask的优势：</p>
<ul>
<li>微型框架，简洁，扩展性强</li>
<li>flask相关依赖非常优秀（jinja2）</li>
<li>开发效率高</li>
<li>社会活跃度高</li>
</ul>
<p>新建一个first_flask_project.py文件</p>
<pre><code class="language-python">from flask import Flask #导入Flask类

from demo import config

app = Flask(__name__)  # 实例化Flask

@app.route('/')   # URL映射到对应视图函数
def hello_world():
    return 'Hello World!'


if __name__=='__main__':
    app.run(debug=True, port=81) # 测试使用的应用服务器


</code></pre>
<p>执行这个py文件</p>
<p><img src="https://i.loli.net/2019/06/05/5cf69949b9fd033530.png" alt=""></p>
<p>浏览器访问hello_world视图函数对应的网址</p>
<p><img src="https://i.loli.net/2019/06/05/5cf6998ce1e2a79941.png" alt=""></p>
<h2 id="3dubug模式">3.DUBUG模式</h2>
<h3 id="31-为什么要开启dubug模式">3.1 为什么要开启DUBUG模式</h3>
<ul>
<li>代码抛出异常后，在浏览器中可以看到错误信息</li>
<li>更新代码以后，只要保存就会使代码自动生效</li>
</ul>
<h3 id="32-开启debug模式的4种方式">3.2 开启DEBUG模式的4种方式</h3>
<p>第一种：在app.run()中传递一个debug=True参数</p>
<pre><code class="language-python">if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
<p>第二种：使用app.debug=True</p>
<pre><code class="language-python">app = Flask(__name__)  
app.debug = True
</code></pre>
<p>第三种：使用update方法，以字典追加的形式将debug参数加到config字典中</p>
<pre><code class="language-python">app = Flask(__name__) 
app.config.update(DEBUG=True)
print(isinstance(app.config, dict))  # 确认config是否是字典
</code></pre>
<p>第四种：加载配置文件的形式</p>
<ul>
<li>
<p>创建一个配置文件，再以模块形式导入</p>
</li>
<li>
<p><img src="https://i.loli.net/2019/06/05/5cf69af23e58681823.png" alt=""></p>
<pre><code class="language-python">from demo import config

app = Flask(__name__)  
app.config.from_object(config)
</code></pre>
</li>
<li>
<p>导入配置文件的形式加载配置</p>
<pre><code class="language-python">from flask import Flask 

app = Flask(__name__)  
app.config.from_pyfile('config.py') # 这样可以少些一行倒模块方法
# 注意要写文件全名（包含文件路径）
# 不仅仅是py文件，其他格式文件也可以
# 这里还有一个silent参数，设为True的话，即使文件不存在也不会报错
</code></pre>
</li>
</ul>
<h2 id="4-url的传参方式">4. URL的传参方式</h2>
<ul>
<li>视图函数上面的装饰器中URL的传参语法为：<code>/&lt;参数名&gt;</code></li>
</ul>
<blockquote>
<p>视图函数中要定义同名参数</p>
</blockquote>
<ul>
<li>
<p>举例，新增一个url_view.py文件，url为文章详情页面</p>
</li>
<li>
<pre><code class="language-python">from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World'

@app.route('/p/&lt;articel_id&gt;')
def article_detail(articel_id):  # 在视图函数中也要定义同名参数
    return '您请求的文章是：{}'.format(articel_id)

if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
</li>
</ul>
<h2 id="5url参数的数据类型">5.URL参数的数据类型</h2>
<p>1.如果没有指定具体的数据类型,那么就是使用<code>string</code>类型</p>
<p>2.<code>int</code>类型只能传递整数类型</p>
<ul>
<li>
<pre><code>@app.route('/article/&lt;int:test&gt;')
</code></pre>
</li>
</ul>
<p>3.<code>float</code>传递浮点型数据</p>
<p>4.<code>path</code>数据类型和<code>string</code>类型都可以接受任意的字符串,但是path可以接收路径,也就是说可以包含斜杠</p>
<pre><code class="language-python">@app.route('/article/&lt;path:test&gt;')
def page_detail(test):
    return '您请求的页面是:{}'.format(test)
</code></pre>
<p>请求之后的页面：</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8cf06db0f727689.png" alt=""></p>
<p>5.uuid：接受符合<code>uuid</code>规则的字符串，全宇宙唯一，缺点就是太长了，一般用来做表的主键</p>
<p>先导包生成一个uuid</p>
<pre><code class="language-python">import uuid

print(uuid.uuid4())
</code></pre>
<p>在URL对应的视图函数中验证</p>
<pre><code class="language-python">@app.route('/u/&lt;uuid:user_id&gt;')
def user_detail(user_id):
    return '用户的uuid为：%s' %user_id
</code></pre>
<p>效果图</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8d2853c4ba94451.png" alt=""></p>
<p>6.any：多个URL映射到同一个视图函数</p>
<p>代码</p>
<pre><code class="language-python">@app.route('/&lt;any(user,blog):url_path&gt;/&lt;id&gt;/')
def detail(url_path, id):
    if url_path == 'user':
        return '用户id是：%s' %id
    else:
        return '博客详情是：%s' %id
</code></pre>
<p>验证<img src="https://i.loli.net/2019/06/06/5cf8d4b30d41953293.png" alt=""></p>
<h2 id="6接收用户传递的参数">6.接收用户传递的参数</h2>
<p>第一种：使用path形式（将参数嵌入到路径中）（就是上面说的）</p>
<p>第二种：使用查询字符串的方式，就是通过<code>?key=value</code>形式传递</p>
<p>代码：</p>
<pre><code class="language-python">@app.route('/d/')
def d():
    wd = request.args.get('wd')  # 注意到导入request
    return '通过字符串传递的参数是：%s' %wd
</code></pre>
<p>验证</p>
<p><img src="https://i.loli.net/2019/06/06/5cf8dad77772c11673.png" alt=""></p>
<p>如果有多个键值对做为参数时，使用<code>&amp;</code>符号进行分割</p>
<p>实例</p>
<pre><code class="language-python">@app.route('/d/')
def d():
    wd = request.args.get('wd')
    ie = request.args.get('ie')  # 多个参数再写一个请求即可
    return '通过字符串传递的参数是：wd=%s,ie=%s' %(wd,ie)
</code></pre>
<p><img src="https://i.loli.net/2019/06/06/5cf8dbe03246a52713.png" alt=""></p>
<p><mark>如果页面想要做SEO优化，就是被搜索引擎搜索到，那么推荐使用第一种（path）传递方式，如果不在乎SEO，则可以使用第二种</mark></p>
<h2 id="7-url_for">7. url_for</h2>
<p>url_for第一个参数，应该是视图函数的名字的字符串，后面的参数传递给url</p>
<h2 id="8自定义url转换器">8.自定义URL转换器</h2>
<p>1.定义一个类，集成<code>BaseConverter</code></p>
<p>2.在这个类中，重写<code>regex</code>，也就是正则表达式</p>
<p>3.将自定义好的类，映射到<code>app.url_map.converters</code>上</p>
<pre><code class="language-python">from flask import Flask
from werkzeug.routing import BaseConverter

app = Flask(__name__)

# 定义自己的参数转换器，匹配手机号
class TelephoneConverter(BaseConverter):
    regex = r'1[85734]\d{9}'

app.url_map.converters['tel'] = TelephoneConverter # 将自定转换器添加到url_map中（字典方式添加）

@app.route('/')
def hello():
    return 'hello world'

@app.route('/user/&lt;int:user_id&gt;/')   # 自带url转换器
def user_profile(user_id):
    return '您输入的user_id为%s' %user_id

@app.route('/telephone/&lt;tel:user_phone&gt;/')   # 使用自定义url转换器
def user_phone(user_phone):
    return '您的手机号为：%s' %user_phone

if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
<p>to_python的作用：这个方法的返回值，将会传递到view函数中作为参数</p>
<pre><code class="language-python">class ListConverter(BaseConverter):
    def to_python(self, value):
        return value.split('+')
app.url_map.converters['list'] = ListConverter

@app.route('/post/&lt;list:borads&gt;/')
def posts(borads):
    return '您提交的版块是：%s' %borads
</code></pre>
<p>to_url的作用：这个方法的返回值，将会调用url_for函数的时候生成符合要求的url形式</p>
<h2 id="9其他细节知识点">9.其他细节知识点</h2>
<h3 id="91-其他电脑访问">9.1 其他电脑访问</h3>
<p>如果想在同一个局域网下让其他电脑访问本机上的flask网站</p>
<p>要设置<code>host=0.0.0.0</code>才能访问得到</p>
<h3 id="92-指定端口">9.2 指定端口</h3>
<p>设置<code>port=端口号</code></p>
<h3 id="93-url唯一">9.3 URL唯一</h3>
<p>在定义URL时，一定要记得在最后加一个斜杠</p>
<ul>
<li>如果不加斜杠，那么在浏览器中访问这个url时，如果加了斜杠就会访问不到，这样用户体验不好</li>
<li>搜索引擎会将加与不加的视为两个不同的URL，其实两个都是同一个URL，会给搜索引擎造成误解</li>
</ul>
<p>代码里面加了斜杠以后，访问时 加与不加 都可以访问</p>
<h3 id="94-请求方式">9.4 请求方式</h3>
<p>flask中的route方法，默认使用get请求</p>
<p>如果想要自定义请求方式，那么应该传递一个<code>method</code>参数</p>
<pre><code class="language-python">@app.route('/list/', methods=['GET', 'POST'])
def list():
    return 'hi'
</code></pre>
<h2 id="10页面跳转和重定向">10.页面跳转和重定向</h2>
<p>重定向分为永久性重定向和暂时性重定向，在页面上体现的操作就是浏览器会从一个页面自动跳转到另外一个页面</p>
<p>比如用户访问了一个需要权限的页面，但是该用户当前并没有登录，因此我们应该给他重定向到登录页面</p>
<ul>
<li>永久性重定向：<code>http</code>的状态码是<code>301</code>，多用于旧网址被废弃了要转到一个新的网址确保用户的访问</li>
<li>暂时性重定向，<code>http</code>的状态码是<code>302</code>，表示页面的暂时性跳转。比如一个需要权限的网址，如果当前用户没有登录，应该重定向登录页面，这种情况下，应该暂时性重定向</li>
</ul>
<p>在flask中，重定向是通过<code>flask.redirect(location, code=302)</code>这个函数来实现的，<code>location</code>表示需要重定向到的URL，应该配合之前的<code>url_for</code>函数来使用，<code>code</code>表示采用哪个重定向，默认是<code>302</code>，即<code>暂时性重定向</code>，也可以修改成<code>301</code>来实现永久性重定向</p>
<p>代码案例：</p>
<pre><code class="language-python">from flask import Flask, request, url_for
from werkzeug.utils import redirect

app = Flask(__name__)

@app.route('/')
def hello():
    return 'hello world'

@app.route('/login/')
def login():
    return '这是登录页面'

@app.route('/profile/')   # 个人中心视图函数
def profile():
    if request.args.get('name'):  # 使用request检查url中是否有name参数
        return '个人中心页面'
    else:
        return redirect(url_for('login'))  # 使用redirect+url_for重定向url，注意，可以定义code参数，默认302即暂时性重定向

if __name__=='__main__':
    app.run(debug=True, port=81)
</code></pre>
<p>访问profile在没有加name参数的情况下会自动暂时性重定向到登录页面</p>
<p><img src="https://i.loli.net/2019/06/11/5cff5e9c07a6469200.gif" alt=""></p>
<p>访问profile加了name参数以后，正常访问到个人中心页面</p>
<p><img src="https://i.loli.net/2019/06/11/5cff5f0d7c57687406.png" alt=""></p>
<h2 id="11关于响应response">11.关于响应（Response）</h2>
<p>视图函数的返回值会被自动转换为一个响应对象，flask的转换逻辑如下：</p>
<ul>
<li>如果返回的是一个合法的响应对象，则直接返回</li>
<li>如果返回的是一个字符串，那么flask会重新创建一个<code>werkzeug.wrappers.Response</code>对象，<code>Response</code>对象将该字符串作为主体，状态码为<code>200</code>，<code>MIME</code>类型为<code>text/html</code>，然后返回该<code>Response</code>对象</li>
<li>如果返回的是一个元祖，元祖中的数据类型是（response,status,headers）。status值会覆盖默认的200状态码，headers可以是一个列表或者字典，作为额外的消息头</li>
<li>如果以上条件都不满足，flask会假设返回值是一个合法的<code>WSGI</code>应用程序，并通过<code>Response.force_type(rv,request,environ)</code>转换为一个请求对象</li>
</ul>
<blockquote>
<p>第一个例子，直接使用<code>Response</code>创建：</p>
</blockquote>
<pre><code class="language-python">from flask import Flask, Response

@app.route('/about/')
def about():
    resp = Response(response='about page', status=200, content_type='text/html;charset=utf-8')
    return resp
</code></pre>
<blockquote>
<p>第二个例子，使用<code>字符串</code>创建：</p>
</blockquote>
<pre><code class="language-python">@app.route('/')
def hello():
    return 'hello world' # 直接返回字符串，flask也会自动组装成一个Response对象返回
</code></pre>
<blockquote>
<p>第三个例子，使用<code>元祖</code>创建：</p>
</blockquote>
<pre><code class="language-python">@app.route('/about2/')
def about2():
    return 'about2',200,{'X-NAME':'Alex'}
</code></pre>
<p><img src="https://i.loli.net/2019/06/12/5d00680c5542521648.png" alt=""></p>
<blockquote>
<p>第四个例子，<code>自定义响应</code>，自定义响应必须满足三个条件：</p>
</blockquote>
<ul>
<li>必须继承自<code>Respone</code>类</li>
<li>实现类方法<code>force_type(cls,rv,nviron=None)</code></li>
<li>必须指定<code>app.respone_class</code>为你自定义的<code>Respone</code></li>
</ul>
<p><code>Restful API</code>都是通过<code>json</code>的形式进行传递，如果你的后台跟前台进行交互，所有的<code>URL</code>参数都是发送<code>json</code>数据，那么此时，可以定义一个叫做<code>JSONResponse</code>的类来代替<code>Response</code>类</p>
<pre><code class="language-python">from flask import Flask, Response, jsonify

# 将视图函数中返回的字典，转换成json对象，然后返回
class JSONResponse(Response):
    @classmethod
    def force_type(cls, response, environ=None):
        if isinstance(response, dict):
            response = jsonify(response)
        return super(JSONResponse, cls).force_type(response,environ)

app.response_class = JSONResponse

@app.route('/json/')
def json_response():
    return {'username':'alex'}
</code></pre>
<p><img src="https://i.loli.net/2019/06/12/5d0099fd2a97e99449.png" alt=""></p>
<h1 id="jinja2模板">Jinja2模板</h1>
<h2 id="1模板基础">1.模板基础</h2>
<p>在渲染模板的时候，默认会从项目根目录下的<code>templates</code>目录下查找模板</p>
<p>如果不想把模板文件放在<code>templates</code>目录下，那么可以在<code>Flask</code>初始化的时候给<code>template_folder</code>参数传值，来指定模板的路径</p>
<blockquote>
<p>在默认模板目录下查找模板</p>
</blockquote>
<pre><code class="language-python">from flask import Flask, render_template

@app.route('/')
def hello():
    return render_template('index.html')  # 在templates目录下查找模板
</code></pre>
<h2 id="2模板参数">2.模板参数</h2>
<p>在使用<code>render_template</code>渲染模板的时候，可以传递关键字参数，以后直接在模板中使用就可以了</p>
<p>如果参数过多，那么可以将所有的参数放到一个字典中，然后在传这个字典参数的时候，使用两个星号，将字典中的数据组成关键字参数传递</p>
<blockquote>
<p>举例</p>
</blockquote>
<p>视图函数中渲染模板传递参数：</p>
<pre><code class="language-python">@app.route('/')
def hello():
    context = {
        'username':'alex',
        'tel':17688165555
    }
    return render_template('index.html',**context)
</code></pre>
<p><code>HTML</code>中调用<code>视图函数</code>中的参数</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;alex&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;这是模板渲染的数据&lt;/h1&gt;
    &lt;p&gt;{{username}}&lt;/p&gt;  &lt;!-- 调用视图函数中的参数 --&gt;
    &lt;p&gt;{{tel}}&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3模板中的url_for">3.模板中的url_for</h2>
<p>模板中的<code>url_for</code>与后台视图函数中的使用基本是一致的</p>
<p>也是传递视图函数的名字，也可以传递参数</p>
<blockquote>
<p>注意：在模板中使用url_for需要在左右两边加上一对花括号，{{ url_for() }}</p>
</blockquote>
<p>举例：</p>
<p>在首页模板中添加一个<code>登录</code>链接</p>
<blockquote>
<p>在这个首页模板中使用<code>url_for</code>来与login视图函数对应</p>
<p>这个的好处就是，一旦视图函数的url变化，模板中使用url的地方会相应变化</p>
</blockquote>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt; &lt;a href=&quot;{{ url_for('login')}}&quot;&gt;登录&lt;/a&gt; &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>然后新建一个<code>login</code>模板</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;alex&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;这是登录页面&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>新建一个<code>login</code>视图函数</p>
<pre><code class="language-python">from flask import Flask, render_template, url_for

app = Flask(__name__)


@app.route('/')
def hello():
    context = {
        'username':'alex',
        'tel':17688165555
    }
    return render_template('index.html',**context)

@app.route('/login/')
def login():
    # url_for('login')
    return render_template('login.html')

if __name__ == '__main__':
    app.run(debug=True, port=81)

</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#flask%E7%AE%80%E4%BB%8B">Flask简介</a></li>
<li><a href="#%E8%BF%9B%E5%85%A5flask%E4%B8%96%E7%95%8C">进入Flask世界</a>
<ul>
<li><a href="#1%E5%AE%89%E8%A3%85python">1.安装Python</a></li>
<li><a href="#2%E5%AE%89%E8%A3%85python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83">2.安装Python虚拟环境</a></li>
</ul>
</li>
<li><a href="#url%E4%B8%8E%E8%A7%86%E5%9B%BE">URL与视图</a>
<ul>
<li><a href="#1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E9%87%8A">1.服务器解释</a></li>
<li><a href="#2%E7%AC%AC%E4%B8%80%E4%B8%AAflask%E7%A8%8B%E5%BA%8F">2.第一个Flask程序</a></li>
<li><a href="#3dubug%E6%A8%A1%E5%BC%8F">3.DUBUG模式</a>
<ul>
<li><a href="#31-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E5%90%AFdubug%E6%A8%A1%E5%BC%8F">3.1 为什么要开启DUBUG模式</a></li>
<li><a href="#32-%E5%BC%80%E5%90%AFdebug%E6%A8%A1%E5%BC%8F%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F">3.2 开启DEBUG模式的4种方式</a></li>
</ul>
</li>
<li><a href="#4-url%E7%9A%84%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F">4. URL的传参方式</a></li>
<li><a href="#5url%E5%8F%82%E6%95%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">5.URL参数的数据类型</a></li>
<li><a href="#6%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E4%BC%A0%E9%80%92%E7%9A%84%E5%8F%82%E6%95%B0">6.接收用户传递的参数</a></li>
<li><a href="#7-url_for">7. url_for</a></li>
<li><a href="#8%E8%87%AA%E5%AE%9A%E4%B9%89url%E8%BD%AC%E6%8D%A2%E5%99%A8">8.自定义URL转换器</a></li>
<li><a href="#9%E5%85%B6%E4%BB%96%E7%BB%86%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9">9.其他细节知识点</a>
<ul>
<li><a href="#91-%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91%E8%AE%BF%E9%97%AE">9.1 其他电脑访问</a></li>
<li><a href="#92-%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3">9.2 指定端口</a></li>
<li><a href="#93-url%E5%94%AF%E4%B8%80">9.3 URL唯一</a></li>
<li><a href="#94-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F">9.4 请求方式</a></li>
</ul>
</li>
<li><a href="#10%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91">10.页面跳转和重定向</a></li>
<li><a href="#11%E5%85%B3%E4%BA%8E%E5%93%8D%E5%BA%94response">11.关于响应（Response）</a></li>
</ul>
</li>
<li><a href="#jinja2%E6%A8%A1%E6%9D%BF">Jinja2模板</a>
<ul>
<li><a href="#1%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%A1%80">1.模板基础</a></li>
<li><a href="#2%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0">2.模板参数</a></li>
<li><a href="#3%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84url_for">3.模板中的url_for</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://yihangliak.github.io/post/selenium-cong-ru-men-dao-shi-zhan">
              <h3 class="post-title">
                Selenium 从入门到实战
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by Alexxx | 
  <a class="rss" href="https://yihangliak.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      console.log('section.offsetHeight', section.offsetHeight);
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
